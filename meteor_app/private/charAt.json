[{"dataset": "charAt", "exampleID": 8201, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 208, "guardExpressionEnd": 249, "guardBlockStart": 208, "guardBlockEnd": 377, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 273, "focalAPIEnd": 289, "followUpCheck": "value != c", "checkType": "IF", "followUpCheckExpressionStart": 297, "followUpCheckExpressionEnd": 314, "followUpCheckBlockStart": 297, "followUpCheckBlockEnd": 352, "use": ["StringBuilder.append(value)"], "useStart": [325], "useEnd": [343], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SIB-Colombia/sib-dataportal/tree/master/portal-core/src/main/java/org/gbif/portal/util/taxonomy/TaxonNameSoundEx.java", "rawCode": "  /** Removes repeated characters Can't get the regex version working so pretty primitive... */\n  String removeRepeatedChars(String source) {\n    StringBuilder sb = new StringBuilder();\n    char c = ' ';\n    for (int i = 0; i < source.length(); i++) {\n      char sourceC = source.charAt(i);\n      if (sourceC != c) {\n        sb.append(sourceC);\n      }\n      c = sourceC;\n    }\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8202, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 344, "focalAPIEnd": 365, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addChar(value)"], "useStart": [314], "useEnd": [366], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dekarrin/yuuki-jrpg/tree/master/src/yuuki/animation/TextTween.java", "rawCode": "  /**\n   * Adds the next character(s) to the message box.\n   *\n   * @param propChanges Index \"position\" contains the number of characters to add.\n   */\n  @Override\n  protected void animateSprite(Map<String, Integer> propChanges) {\n    int dp = propChanges.get(\"position\");\n    for (int i = 0; i < dp; i++) {\n      ((MessageBox) sprite).addChar(text.charAt(position));\n      position++;\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8203, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [185], "configurationEnd": [200], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 240, "focalAPIEnd": 258, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.charAt(int)"], "useStart": [278], "useEnd": [296], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Mindtoeye/Hoop/tree/master/src/org/fife/ui/rsyntaxtextarea/modes/XMLTokenMaker.java", "rawCode": "  private static int zzUnpackAction(String packed, int offset, int[] result) {\n    int i = 0; /* index in packed string */\n    int j = offset; /* index in unpacked array */\n    int l = packed.length();\n    while (i < l) {\n      int count = packed.charAt(i++);\n      int value = packed.charAt(i++);\n      do result[j++] = value;\n      while (--count > 0);\n    }\n    return j;\n  }\n"}, {"dataset": "charAt", "exampleID": 8204, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<stringValue.length()", "guardType": "LOOP {", "guardExpressionStart": 386, "guardExpressionEnd": 432, "guardBlockStart": 386, "guardBlockEnd": 479, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 456, "focalAPIEnd": 477, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pushyrpc/pushy/tree/master/java/unittest/pushy/ProtocolTest.java", "rawCode": "  public void testStrings() {\n    Object value = client.evaluate(\"u'\\\\u1234'\");\n    assertEquals(\"\\u1234\", value);\n\n    // Make sure all of the characters 0-255 are returned unscathed.\n    value = client.evaluate(\"''.join([chr(i) for i in range(256)])\");\n    assertTrue(value instanceof String);\n    String stringValue = (String) value;\n    assertEquals(256, stringValue.length());\n    for (int i = 0; i < stringValue.length(); ++i) assertEquals((char) i, stringValue.charAt(i));\n  }\n"}, {"dataset": "charAt", "exampleID": 8205, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 295, "focalAPIEnd": 406, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mitmel/Locast-Android/tree/master/src/com/beoui/geocell/GeocellUtils.java", "rawCode": "  /**\n   * Returns the geocell character in the 4x4 alphabet grid at pos. (x, y).\n   *\n   * @param pos\n   * @return Returns the geocell character in the 4x4 alphabet grid at pos. (x, y).\n   */\n  public static char subdivChar(int[] pos) {\n    // NOTE: This only works for grid size 4.\n    return GEOCELL_ALPHABET.charAt(\n        (pos[1] & 2) << 2 | (pos[0] & 2) << 1 | (pos[1] & 1) << 1 | (pos[0] & 1) << 0);\n  }\n"}, {"dataset": "charAt", "exampleID": 8206, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 106, "guardExpressionEnd": 152, "guardBlockStart": 106, "guardBlockEnd": 367, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 170, "focalAPIEnd": 191, "followUpCheck": "Character.isLetter(value)", "checkType": "IF", "followUpCheckExpressionStart": 199, "followUpCheckExpressionEnd": 225, "followUpCheckBlockStart": 199, "followUpCheckBlockEnd": 361, "use": ["letter(value)", "digit(value)", "other(value)"], "useStart": [226, 293, 333], "useEnd": [254, 320, 360], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/epronk/fitnesse/tree/master/src/fit/GracefulNamer.java", "rawCode": "  public static String disgrace(String fixtureName) {\n    GracefulNamer namer = new GracefulNamer();\n\n    for (int i = 0; i < fixtureName.length(); i++) {\n      char c = fixtureName.charAt(i);\n      if (Character.isLetter(c)) namer.currentState.letter(c);\n      else if (Character.isDigit(c)) namer.currentState.digit(c);\n      else namer.currentState.other(c);\n    }\n\n    return namer.finalName.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8207, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 264, "guardExpressionEnd": 300, "guardBlockStart": 264, "guardBlockEnd": 900, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 318, "focalAPIEnd": 329, "followUpCheck": "value == '\\n'", "checkType": "IF", "followUpCheckExpressionStart": 337, "followUpCheckExpressionEnd": 351, "followUpCheckBlockStart": 337, "followUpCheckBlockEnd": 894, "use": ["toString(value,int)", "StringBuffer.append(value)"], "useStart": [823, 872], "useEnd": [846, 885], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bpd/kale/tree/master/src/org/objectweb/asm/util/Printer.java", "rawCode": "  /**\n   * Appends a quoted string to a given buffer.\n   *\n   * @param buf the buffer where the string must be added.\n   * @param s the string to be added.\n   */\n  public static void appendString(final StringBuffer buf, final String s) {\n    buf.append('\\\"');\n    for (int i = 0; i < s.length(); ++i) {\n      char c = s.charAt(i);\n      if (c == '\\n') {\n        buf.append(\"\\\\n\");\n      } else if (c == '\\r') {\n        buf.append(\"\\\\r\");\n      } else if (c == '\\\\') {\n        buf.append(\"\\\\\\\\\");\n      } else if (c == '\"') {\n        buf.append(\"\\\\\\\"\");\n      } else if (c < 0x20 || c > 0x7f) {\n        buf.append(\"\\\\u\");\n        if (c < 0x10) {\n          buf.append(\"000\");\n        } else if (c < 0x100) {\n          buf.append(\"00\");\n        } else if (c < 0x1000) {\n          buf.append('0');\n        }\n        buf.append(Integer.toString(c, 16));\n      } else {\n        buf.append(c);\n      }\n    }\n    buf.append('\\\"');\n  }\n"}, {"dataset": "charAt", "exampleID": 8208, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(index)!=-1", "guardType": "IF {", "guardExpressionStart": 315, "guardExpressionEnd": 349, "guardBlockStart": 315, "guardBlockEnd": 371, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 357, "focalAPIEnd": 370, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cielavenir/procon/tree/master/tyama_PKU2141.java", "rawCode": "  public static void main(String[] z) {\n    Scanner cin = new Scanner(System.in);\n    String enc = \"abcdefghijklmnopqrstuvwxyz\";\n    enc += enc.toUpperCase();\n    String dec = cin.nextLine();\n    dec += dec.toUpperCase();\n    char[] s = cin.nextLine().toCharArray();\n    int i = 0, j;\n    for (; i < s.length; i++) if ((j = enc.indexOf(s[i])) != -1) s[i] = dec.charAt(j);\n    System.out.print(s);\n  }\n"}, {"dataset": "charAt", "exampleID": 8209, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 233, "focalAPIEnd": 260, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JeremySDev/NetworkingChargenProject/tree/master/src/main/java/edu/wcu/Chargen/NumericCharacterSource.java", "rawCode": "  /**\n   * Gets the next char from data and returns it.\n   *\n   * @return - A char from the current index of data.\n   */\n  public char getNextChar() {\n    if (placeInArray == data.length()) {\n      placeInArray = 0;\n    }\n    return data.charAt(placeInArray++);\n  }\n"}, {"dataset": "charAt", "exampleID": 8210, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [272], "configurationEnd": [289], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 252, "guardExpressionEnd": 295, "guardBlockStart": 252, "guardBlockEnd": 1891, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 632, "focalAPIEnd": 650, "followUpCheck": "value == '<'", "checkType": "IF", "followUpCheckExpressionStart": 658, "followUpCheckExpressionEnd": 672, "followUpCheckBlockStart": 658, "followUpCheckBlockEnd": 706, "use": ["detectMacro(string,int)", "StringBuilder.append(value)"], "useStart": [681, 1862], "useEnd": [705, 1876], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/traycold/crengine/tree/master/android/src/org/coolreader/crengine/HelpFileGenerator.java", "rawCode": "  private String filterTemplate(String template) {\n    StringBuilder buf = new StringBuilder(template.length());\n    StringBuilder binary = new StringBuilder();\n    ArrayList<Boolean> ifStack = new ArrayList<Boolean>();\n    boolean ifState = true;\n    for (int i = 0; i < template.length(); i++) {\n      // <!--cr3:if condition--> (condition may be setting==value or setting!=value or setting\n      // (==\"1\", for bool values)\n      // <!--cr3:else --> else branch of if\n      // <!--cr3:endif --> end if\n      // <!--cr3:image name--> place image here\n      // <!--cr3:setting name-->\n      MacroInfo macro = null;\n      char ch = template.charAt(i);\n      if (ch == '<') macro = detectMacro(template, i);\n      if (macro != null) {\n        boolean condValue = false;\n        switch (macro.type) {\n          case IF:\n            ifStack.add(ifState);\n            ifState = getConditionValue(macro.param1);\n            break;\n          case ELSE:\n            ifState = !ifState;\n            break;\n          case ENDIF:\n            if (ifStack.size() > 0) ifState = ifStack.remove(ifStack.size() - 1);\n            break;\n          case IMAGE:\n            if (ifState) {\n              appendImage(macro.param1, buf, binary);\n            }\n            break;\n          case SETTING:\n            if (ifState) {\n              // TODO: show param value name here\n              String value = getSettingValueName(macro.param1);\n              if (value != null) buf.append(getSettingValueName(macro.param1));\n            }\n            break;\n        }\n        i += macro.len - 1;\n      } else {\n        if (ch == '<'\n            && i >= template.length() - 20\n            && \"</FictionBook>\".equals(template.substring(i, i + 14))) {\n          // before closing </FictionBook> tag put all binary (image) data\n          buf.append(binary);\n        }\n        if (ifState) buf.append(ch);\n      }\n    }\n    return buf.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8211, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(error.charAt(index,)==')'||error.charAt(index,)=='(') && !(error.charAt(index,)=='0'&&error.charAt(index+1,)=='(') && index<error.length()-1", "guardType": "LOOP {", "guardExpressionStart": 120, "guardExpressionEnd": 164, "guardBlockStart": 120, "guardBlockEnd": 598, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 191, "focalAPIEnd": 206, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FoxyCorndog/WorkspaceOld/tree/master/ArrowIDE/src/net/foxycorndog/arrowide/compiler/GLSLCompiler.java", "rawCode": "  private static String formatError(String error, String fileName, boolean tabs) {\n    String formattedError = \"\";\n\n    for (int i = 0; i < error.length() - 1; i++) {\n      try {\n        if (error.charAt(i) == '0' && error.charAt(i + 1) == '(') {\n          formattedError += fileName + \":\";\n        } else if (error.charAt(i) == ')' || error.charAt(i) == '(') {\n\n        } else {\n          formattedError += error.charAt(i);\n\n          if (tabs && error.charAt(i) == '\\n') {\n            formattedError += '\\t';\n          }\n        }\n      } catch (ArrayIndexOutOfBoundsException e) {\n\n      }\n    }\n\n    return formattedError;\n  }\n"}, {"dataset": "charAt", "exampleID": 8212, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 476, "focalAPIEnd": 518, "followUpCheck": "(Character.isJavaIdentifierPart(value) || '.' == value || '-' == value || ';' == value) && !('$' == value)", "checkType": "LOOP {", "followUpCheckExpressionStart": 531, "followUpCheckExpressionEnd": 685, "followUpCheckBlockStart": 531, "followUpCheckBlockEnd": 882, "use": ["string.charAt(int)", "string.substring(int,int)"], "useStart": [833, 946], "useEnd": [875, 997], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vogella/eclipse-platform/tree/master/ant/org.eclipse.ant.ui/Ant Editor/org/eclipse/ant/internal/ui/editor/AntEditorCompletionProcessor.java", "rawCode": "  /**\n   * Returns the prefix in the specified document text with respect to the specified offset.\n   *\n   * @param aDocumentText the whole content of the edited file as String\n   * @param anOffset the cursor position\n   */\n  protected String getPrefixFromDocument(String aDocumentText, int anOffset) {\n    if (currentPrefix != null) {\n      return currentPrefix;\n    }\n    int startOfWordToken = anOffset;\n\n    char token = 'a';\n    if (startOfWordToken > 0) {\n      token = aDocumentText.charAt(startOfWordToken - 1);\n    }\n\n    while (startOfWordToken > 0\n        && (Character.isJavaIdentifierPart(token) || '.' == token || '-' == token || ';' == token)\n        && !('$' == token)) {\n      startOfWordToken--;\n      if (startOfWordToken == 0) {\n        break; // word goes right to the beginning of the doc\n      }\n      token = aDocumentText.charAt(startOfWordToken - 1);\n    }\n\n    if (startOfWordToken != anOffset) {\n      currentPrefix = aDocumentText.substring(startOfWordToken, anOffset).toLowerCase();\n    } else {\n      currentPrefix = IAntCoreConstants.EMPTY_STRING;\n    }\n    return currentPrefix;\n  }\n"}, {"dataset": "charAt", "exampleID": 8213, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length() && !(NodeUtil.isLatin(string,))", "guardType": "IF {", "guardExpressionStart": 124, "guardExpressionEnd": 148, "guardBlockStart": 124, "guardBlockEnd": 172, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 354, "focalAPIEnd": 365, "followUpCheck": "value > 0x1F && value < 0x7F", "checkType": "IF", "followUpCheckExpressionStart": 534, "followUpCheckExpressionEnd": 559, "followUpCheckBlockStart": 534, "followUpCheckBlockEnd": 656, "use": ["StringBuilder.append(value)", "appendHexJavaScriptRepresentation(StringBuilder,value)"], "useStart": [570, 607], "useEnd": [582, 647], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/martinrosstmc/closure-compiler/tree/master/src/com/google/javascript/jscomp/CodeGenerator.java", "rawCode": "  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-Latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8214, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.startsWith(\"[\",)", "guardType": "IF {", "guardExpressionStart": 56, "guardExpressionEnd": 86, "guardBlockStart": 56, "guardBlockEnd": 1134, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 130, "focalAPIEnd": 149, "followUpCheck": "value == '['", "checkType": "LOOP {", "followUpCheckExpressionStart": 183, "followUpCheckExpressionEnd": 199, "followUpCheckBlockStart": 183, "followUpCheckBlockEnd": 297, "use": ["string.charAt(int)", "string.charAt(int)", "string.length()", "string.substring(int,int)", "string.replace(char,char)"], "useStart": [260, 313, 592, 556, 556], "useEnd": [288, 341, 610, 615, 633], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/libgdx/libgdx/tree/master/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/ReflectionCache.java", "rawCode": "  private static String convert(String className) {\n    if (className.startsWith(\"[\")) {\n      int dimensions = 0;\n      char c = className.charAt(0);\n      String suffix = \"\";\n      while (c == '[') {\n        dimensions++;\n        suffix += \"[]\";\n        c = className.charAt(dimensions);\n      }\n      char t = className.charAt(dimensions);\n      switch (t) {\n        case 'Z':\n          return \"boolean\" + suffix;\n        case 'B':\n          return \"byte\" + suffix;\n        case 'C':\n          return \"char\" + suffix;\n        case 'L':\n          return className.substring(dimensions + 1, className.length() - 1).replace('$', '.')\n              + suffix;\n        case 'D':\n          return \"double\" + suffix;\n        case 'F':\n          return \"float\" + suffix;\n        case 'I':\n          return \"int\" + suffix;\n        case 'J':\n          return \"long\" + suffix;\n        case 'S':\n          return \"short\" + suffix;\n        default:\n          throw new IllegalArgumentException(\n              \"Couldn't transform '\" + className + \"' to qualified source name\");\n      }\n    } else {\n      return className.replace('$', '.');\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8215, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 156, "focalAPIEnd": 177, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.substring(int,int)"], "useStart": [356], "useEnd": [397], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dojo/util/tree/master/shrinksafe/src/org/dojotoolkit/shrinksafe/Compressor.java", "rawCode": "  private static int printSourceString(\n      String source, int offset, boolean asQuotedString, StringBuffer sb, boolean escapeUnicode) {\n    int length = source.charAt(offset);\n    ++offset;\n    if ((0x8000 & length) != 0) {\n      length = ((0x7FFF & length) << 16) | source.charAt(offset);\n      ++offset;\n    }\n    if (sb != null) {\n      String str = source.substring(offset, offset + length);\n      if (!asQuotedString) {\n        sb.append(str);\n      } else {\n        sb.append('\"');\n        sb.append(escapeString(str, escapeUnicode));\n        sb.append('\"');\n      }\n    }\n    return offset + length;\n  }\n"}, {"dataset": "charAt", "exampleID": 8216, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 98, "guardExpressionEnd": 140, "guardBlockStart": 98, "guardBlockEnd": 251, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 165, "focalAPIEnd": 182, "followUpCheck": "value < minQual", "checkType": "IF", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 217, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 245, "use": ["string.length()"], "useStart": [263], "useEnd": [279], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/genome/BaseEncoder.java", "rawCode": "  public static int getFirstLowQualityPos(String quality, int minQual) {\n    int qualInt = 0;\n    for (int i = 0; i < quality.length(); i++) {\n      qualInt = (int) quality.charAt(i) - 64;\n      if (qualInt < minQual) {\n        return i;\n      }\n    }\n    return quality.length();\n  }\n"}, {"dataset": "charAt", "exampleID": 8217, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 564, "guardExpressionEnd": 603, "guardBlockStart": 564, "guardBlockEnd": 713, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 621, "focalAPIEnd": 633, "followUpCheck": "value != ' ' && value != '\\r' && value != '\\n' && value != '\\t'", "checkType": "IF", "followUpCheckExpressionStart": 641, "followUpCheckExpressionEnd": 693, "followUpCheckBlockStart": 641, "followUpCheckBlockEnd": 707, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7941/src/net/sourceforge/plantuml/code/Base64Coder.java", "rawCode": "  /**\n   * Decodes a byte array from Base64 format and ignores line separators, tabs and blanks. CR, LF,\n   * Tab and Space characters are ignored in the input data. This method is compatible with <code>\n   * sun.misc.BASE64Decoder.decodeBuffer(String)</code>.\n   *\n   * @param s A Base64 String to be decoded.\n   * @return An array containing the decoded data bytes.\n   * @throws IllegalArgumentException If the input is not valid Base64 encoded data.\n   */\n  public static byte[] decodeLines(String s) {\n    char[] buf = new char[s.length()];\n    int p = 0;\n    for (int ip = 0; ip < s.length(); ip++) {\n      char c = s.charAt(ip);\n      if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t') buf[p++] = c;\n    }\n    return decode(buf, 0, p);\n  }\n"}, {"dataset": "charAt", "exampleID": 8218, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string.equalsIgnoreCase(\"null\",)) && !(string.equalsIgnoreCase(\"true\",)) && !(string.equals(\"\",)) && !(string.equalsIgnoreCase(\"false\",))", "guardType": "IF {", "guardExpressionStart": 248, "guardExpressionEnd": 265, "guardBlockStart": 248, "guardBlockEnd": 289, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 897, "focalAPIEnd": 908, "followUpCheck": "(value >= '0' && value <= '9') || value == '.' || value == '-' || value == '+'", "checkType": "IF", "followUpCheckExpressionStart": 914, "followUpCheckExpressionEnd": 977, "followUpCheckBlockStart": 914, "followUpCheckBlockEnd": 1736, "use": ["string.substring(int)", "parseInt(string,int)", "new Integer(string)", "new Long(string)", "new Double(string)"], "useStart": [1142, 1309, 1460, 1537, 1617], "useEnd": [1156, 1331, 1474, 1548, 1630], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/araqne/core/tree/master/araqne-json/src/main/java/org/json/JSONObject.java", "rawCode": "  /**\n   * Try to convert a string into a number, boolean, or null. If the string can't be converted,\n   * return the string.\n   *\n   * @param s A String.\n   * @return A simple JSON value.\n   */\n  public static Object stringToValue(String s) {\n    if (s.equals(\"\")) {\n      return s;\n    }\n    if (s.equalsIgnoreCase(\"true\")) {\n      return Boolean.TRUE;\n    }\n    if (s.equalsIgnoreCase(\"false\")) {\n      return Boolean.FALSE;\n    }\n    if (s.equalsIgnoreCase(\"null\")) {\n      return JSONObject.NULL;\n    }\n\n    /*\n     * If it might be a number, try converting it. We support the 0- and 0x-\n     * conventions. If a number cannot be produced, then the value will just\n     * be a string. Note that the 0-, 0x-, plus, and implied string\n     * conventions are non-standard. A JSON parser is free to accept\n     * non-JSON forms as long as it accepts all correct JSON forms.\n     */\n\n    char b = s.charAt(0);\n    if ((b >= '0' && b <= '9') || b == '.' || b == '-' || b == '+') {\n      if (b == '0') {\n        if (s.length() > 2 && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n          try {\n            return new Integer(Integer.parseInt(s.substring(2), 16));\n          } catch (Exception e) {\n            /* Ignore the error */\n          }\n        } else {\n          try {\n            return new Integer(Integer.parseInt(s, 8));\n          } catch (Exception e) {\n            /* Ignore the error */\n          }\n        }\n      }\n      try {\n        return new Integer(s);\n      } catch (Exception e) {\n        try {\n          return new Long(s);\n        } catch (Exception f) {\n          try {\n            return new Double(s);\n          } catch (Exception g) {\n            /* Ignore the error */\n          }\n        }\n      }\n    }\n    return s;\n  }\n"}, {"dataset": "charAt", "exampleID": 8219, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 275, "guardExpressionEnd": 313, "guardBlockStart": 275, "guardBlockEnd": 494, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 331, "focalAPIEnd": 344, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getEscape(value)", "string.charAt(int)", "getEscape(value)", "StringBuilder.append(value)"], "useStart": [368, 755, 792, 885], "useEnd": [380, 768, 804, 898], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nkhoang/ja12sec02jav/tree/master/struts-web/src/main/java/com/nkhoang/webapp/jsp/EscapeXml.java", "rawCode": "  /**\n   * Escape a string.\n   *\n   * @param src the string to escape; must not be null\n   * @return the escaped string\n   */\n  public static String escape(String src) {\n    // first pass to determine the length of the buffer so we only allocate once\n    int length = 0;\n    for (int i = 0; i < src.length(); i++) {\n      char c = src.charAt(i);\n      String escape = getEscape(c);\n      if (escape != null) {\n        length += escape.length();\n      } else {\n        length += 1;\n      }\n    }\n\n    // skip copy if no escaping is needed\n    if (length == src.length()) {\n      return src;\n    }\n\n    // second pass to build the escaped string\n    StringBuilder buf = new StringBuilder(length);\n    for (int i = 0; i < src.length(); i++) {\n      char c = src.charAt(i);\n      String escape = getEscape(c);\n      if (escape != null) {\n        buf.append(escape);\n      } else {\n        buf.append(c);\n      }\n    }\n    return buf.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8220, "initialization": ["String string = getName()", "int index = prefix(String)", "int index = length()", "String string = String.substring(int)"], "initializationStart": [194, 243, 600, 678], "initializationEnd": [218, 255, 613, 698], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.substring(int)"], "configurationStart": [678], "configurationEnd": [698], "guardCondition": "string.length()>index && !(isAcronym(string,index,))", "guardType": "IF {", "guardExpressionStart": 596, "guardExpressionEnd": 621, "guardBlockStart": 596, "guardBlockEnd": 980, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 743, "focalAPIEnd": 760, "followUpCheck": "value != lo", "checkType": "IF", "followUpCheckExpressionStart": 825, "followUpCheckExpressionEnd": 838, "followUpCheckBlockStart": 825, "followUpCheckBlockEnd": 962, "use": ["toLowerCase(value)", "string.substring(int)"], "useStart": [788, 929], "useEnd": [813, 949], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/library/metadata/src/main/java/org/geotools/metadata/PropertyAccessor.java", "rawCode": "  /** Returns the name of the property at the given index, or {@code null} if none. */\n  final String name(final int index) {\n    if (index >= 0 && index < getters.length) {\n      String name = getters[index].getName();\n      final int base = prefix(name).length();\n      /*\n       * Remove the \"get\" or \"is\" prefix and turn the first character after the\n       * prefix into lower case. For example the method name \"getTitle\" will be\n       * replaced by the property name \"title\". We will performs this operation\n       * only if there is at least 1 character after the prefix.\n       */\n      if (name.length() > base) {\n        if (isAcronym(name, base)) {\n          name = name.substring(base);\n        } else {\n          final char up = name.charAt(base);\n          final char lo = Character.toLowerCase(up);\n          if (up != lo) {\n            name = lo + name.substring(base + 1);\n          } else {\n            name = name.substring(base);\n          }\n        }\n      }\n      return name;\n    }\n    return null;\n  }\n"}, {"dataset": "charAt", "exampleID": 8221, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.length()>index && !(this.charsToGo>index)", "guardType": "LOOP {", "guardExpressionStart": 583, "guardExpressionEnd": 633, "guardBlockStart": 583, "guardBlockEnd": 2236, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 713, "focalAPIEnd": 744, "followUpCheck": "(value == (this.delimiter[this.charsToGo - 1]))", "checkType": "IF", "followUpCheckExpressionStart": 1661, "followUpCheckExpressionEnd": 1731, "followUpCheckBlockStart": 1661, "followUpCheckBlockEnd": 2222, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/release-3-7-2/src/lib/net/n3/nanoxml/ContentReader.java", "rawCode": "  /**\n   * Reads a block of data.\n   *\n   * @param buffer where to put the read data\n   * @param offset first position in buffer to put the data\n   * @param size maximum number of chars to read\n   * @return the number of chars read, or -1 if at EOF\n   * @throws java.io.IOException if an error occurred reading the data\n   */\n  public int read(char[] buffer, int offset, int size) throws IOException {\n    int charsRead = 0;\n    boolean isEntity[] = new boolean[1];\n    isEntity[0] = false;\n\n    if ((offset + size) > buffer.length) {\n      size = buffer.length - offset;\n    }\n\n    while ((this.charsToGo > 0) && (charsRead < size)) {\n      char ch;\n\n      if (this.charsReadTooMuch.length() > 0) {\n        ch = this.charsReadTooMuch.charAt(0);\n        this.charsReadTooMuch = this.charsReadTooMuch.substring(1);\n      } else {\n        this.pastInitialPrefix = true;\n\n        try {\n          if (useLowLevelReader) {\n            ch = this.reader.read();\n          } else {\n            ch = XMLUtil.read(this.reader, isEntity, this.escapeChar, this.entityResolver);\n\n            if (!isEntity[0]) {\n              if (ch == '&') {\n                this.reader.startNewStream(\n                    XMLUtil.scanEntity(\n                        isEntity, this.reader, this.escapeChar, this.entityResolver));\n                ch = this.reader.read();\n              }\n            }\n          }\n        } catch (XMLParseException e) {\n          throw new RuntimeException(e.getMessage());\n          // necessary to be able to implement Reader\n        }\n      }\n\n      if (isEntity[0]) {\n        buffer[offset + charsRead] = ch;\n        charsRead++;\n      } else {\n        if ((ch == (this.delimiter[this.charsToGo - 1])) && pastInitialPrefix) {\n          --this.charsToGo;\n        } else if (this.charsToGo < this.delimiter.length) {\n          this.charsReadTooMuch =\n              new String(this.delimiter, this.charsToGo + 1, this.delimiter.length - this.charsToGo)\n                  + ch;\n          this.charsToGo = this.delimiter.length;\n          buffer[offset + charsRead] = this.delimiter[this.charsToGo - 1];\n          charsRead++;\n        } else {\n          buffer[offset + charsRead] = ch;\n          charsRead++;\n        }\n      }\n    }\n\n    if (charsRead == 0) {\n      charsRead = -1;\n    }\n\n    return charsRead;\n  }\n"}, {"dataset": "charAt", "exampleID": 8222, "initialization": ["String string = new String(byte[])"], "initializationStart": [155], "initializationEnd": [171], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.charAt(index,)!=0 && index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 177, "guardExpressionEnd": 215, "guardBlockStart": 177, "guardBlockEnd": 298, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 228, "focalAPIEnd": 241, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.append(value)"], "useStart": [258], "useEnd": [283], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/email/src/au/gov/naa/digipres/xena/plugin/email/msg/MsgMessage.java", "rawCode": "  String getString(DocumentEntry entry) throws IOException {\n    byte[] data = getData(entry);\n    StringBuffer buf = new StringBuffer();\n    String res = new String(data);\n    for (int i = 0; i < res.length(); i++) {\n      if (res.charAt(i) != 0) {\n        buf.append(res.charAt(i));\n      }\n    }\n    return buf.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8223, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 201, "focalAPIEnd": 219, "followUpCheck": "Character.toLowerCase(value) != _TAG_SCRIPT[i]", "checkType": "IF", "followUpCheckExpressionStart": 230, "followUpCheckExpressionEnd": 280, "followUpCheckBlockStart": 230, "followUpCheckBlockEnd": 316, "use": ["string.charAt(int)", "isLetter(value)"], "useStart": [339, 448], "useEnd": [355, 472], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/kernel/common.utils/src/main/java/org/flowframe/kernel/common/utils/HTMLUtil.java", "rawCode": "  protected boolean isScriptTag(String text, int pos) {\n    if ((pos + _TAG_SCRIPT.length + 1) <= text.length()) {\n      char item;\n\n      for (int i = 0; i < _TAG_SCRIPT.length; i++) {\n        item = text.charAt(pos++);\n\n        if (Character.toLowerCase(item) != _TAG_SCRIPT[i]) {\n          return false;\n        }\n      }\n\n      item = text.charAt(pos);\n\n      // Check that char after \"script\" is not a letter (i.e. another tag)\n\n      return !Character.isLetter(item);\n    } else {\n      return false;\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8224, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null||string.length()==index)", "guardType": "IF {", "guardExpressionStart": 158, "guardExpressionEnd": 213, "guardBlockStart": 158, "guardBlockEnd": 240, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 288, "focalAPIEnd": 310, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.toUpperCase(value)"], "useStart": [266], "useEnd": [311], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/crux-framework/tree/master/branches/crux/4.0.0/Crux/src/core/org/cruxframework/crux/core/utils/ClassUtils.java", "rawCode": "  /**\n   * @param propertyName\n   * @param baseClass\n   * @return\n   */\n  public static String getGetterMethod(String propertyName, Class<?> baseClass) {\n    if (propertyName == null || propertyName.length() == 0) {\n      return null;\n    }\n    String result = \"\" + Character.toUpperCase(propertyName.charAt(0));\n    result += propertyName.substring(1);\n    if (propertyName.length() > 1) {\n      try {\n        baseClass.getMethod(\"get\" + result, new Class<?>[] {});\n        result = \"get\" + result;\n      } catch (Exception e) {\n        try {\n          baseClass.getMethod(\"is\" + result, new Class<?>[] {});\n          result = \"is\" + result;\n        } catch (Exception e1) {\n          result = null;\n        }\n      }\n    }\n    return result;\n  }\n"}, {"dataset": "charAt", "exampleID": 8225, "initialization": ["int index = String.indexOf(char)"], "initializationStart": [213], "initializationEnd": [227], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(index==-1)", "guardType": "IF {", "guardExpressionStart": 235, "guardExpressionEnd": 247, "guardBlockStart": 235, "guardBlockEnd": 275, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 325, "focalAPIEnd": 336, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.charAt(int)"], "useStart": [347], "useEnd": [358], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cbsa-informatik-uni-siegen/gtitool/tree/master/start/buildfiles/executer/windows/launch4j/src/net/sf/launch4j/config/ConfigPersister.java", "rawCode": "    /** Get property and remove trailing # comments. */\n    public String getProperty(String key) {\n      String p = _properties.getProperty(key);\n      if (p == null) {\n        return null;\n      }\n      int x = p.indexOf('#');\n      if (x == -1) {\n        return p;\n      }\n      do {\n        x--;\n      } while (x > 0 && (p.charAt(x) == ' ' || p.charAt(x) == '\\t'));\n      return (x == 0) ? \"\" : p.substring(0, x + 1);\n    }\n"}, {"dataset": "charAt", "exampleID": 8226, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 45, "guardExpressionEnd": 83, "guardBlockStart": 45, "guardBlockEnd": 534, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 107, "focalAPIEnd": 120, "followUpCheck": "value >= 0xd800 && value < 0xe000", "checkType": "IF", "followUpCheckExpressionStart": 128, "followUpCheckExpressionEnd": 158, "followUpCheckBlockStart": 128, "followUpCheckBlockEnd": 528, "use": ["string.charAt(int)", "appendCodepoint(value)"], "useStart": [184, 496], "useEnd": [199, 519], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rjeschke/neetutils-base/tree/master/src/main/java/com/github/rjeschke/neetutils/String32.java", "rawCode": "  public void append(final String str) {\n    for (int i = 0; i < str.length(); i++) {\n      final char c = str.charAt(i);\n      if (c >= 0xd800 && c < 0xe000) {\n        final char d = str.charAt(++i);\n        if (c < 0xdc00 && d >= 0xdc00 && d < 0xe000) {\n          this.appendCodepoint((((c & 0x3ff) << 10) | (d & 0x3ff)) + 0x10000);\n        } else {\n          if (d < 0xd800 || d > 0xdfff) {\n            i--;\n          }\n          this.appendCodepoint(0xfffd);\n        }\n      } else {\n        this.appendCodepoint(c);\n      }\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8227, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null||string.length()==0) && index<length", "guardType": "IF {", "guardExpressionStart": 185, "guardExpressionEnd": 220, "guardBlockStart": 185, "guardBlockEnd": 244, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 727, "focalAPIEnd": 739, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OMFGB/packages_apps_Gallery3D/tree/master/src/com/cooliris/media/Utils.java", "rawCode": "  /**\n   * A function thats returns a 64-bit crc for string\n   *\n   * @param in : input string\n   * @return 64-bit crc value\n   */\n  public static final long Crc64Long(String in) {\n    if (in == null || in.length() == 0) {\n      return 0;\n    }\n    // http://bioinf.cs.ucl.ac.uk/downloads/crc64/crc64.c\n    long crc = INITIALCRC, part;\n    if (!init) {\n      for (int i = 0; i < 256; i++) {\n        part = i;\n        for (int j = 0; j < 8; j++) {\n          int value = ((int) part & 1);\n          if (value != 0) part = (part >> 1) ^ POLY64REV;\n          else part >>= 1;\n        }\n        CRCTable[i] = part;\n      }\n      init = true;\n    }\n    int length = in.length();\n    for (int k = 0; k < length; ++k) {\n      char c = in.charAt(k);\n      crc = CRCTable[(((int) crc) ^ c) & 0xff] ^ (crc >> 8);\n    }\n    return crc;\n  }\n"}, {"dataset": "charAt", "exampleID": 8228, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<s.length()", "guardType": "LOOP {", "guardExpressionStart": 287, "guardExpressionEnd": 323, "guardBlockStart": 287, "guardBlockEnd": 372, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 353, "focalAPIEnd": 364, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(value)"], "useStart": [332], "useEnd": [365], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vega113/WaveInCloud/tree/master/test/org/waveprotocol/wave/model/experimental/schema/CharacterValidatorTest.java", "rawCode": "  /**\n   * This converts a string into code points, where each character in the given string must\n   * represent a full code point (so surrogate pairs are not allowed).\n   */\n  private Set<Integer> stringToCodePoints(String s) {\n    Set<Integer> codePoints = new TreeSet<Integer>();\n    for (int i = 0; i < s.length(); ++i) {\n      codePoints.add((int) s.charAt(i));\n    }\n    return codePoints;\n  }\n"}, {"dataset": "charAt", "exampleID": 8229, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length() && string!=null", "guardType": "IF {", "guardExpressionStart": 482, "guardExpressionEnd": 503, "guardBlockStart": 482, "guardBlockEnd": 3922, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 647, "focalAPIEnd": 677, "followUpCheck": "Character.isDigit(value)", "checkType": "IF", "followUpCheckExpressionStart": 687, "followUpCheckExpressionEnd": 718, "followUpCheckBlockStart": 687, "followUpCheckBlockEnd": 1849, "use": ["string.charAt(int)", "string.charAt(int)", "string.charAt(int)", "string.substring(int,int)", "string.length()", "string.substring(int,int)"], "useStart": [2010, 2903, 3759, 3968, 4141, 4104], "useEnd": [2038, 2935, 3794, 4014, 4158, 4159], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.10.2/samples/samples/shared/StringConverterAndSplitter.java", "rawCode": "  /**\n   * splits the string complete into a part that contains the number and a remainder part It will\n   * look for the first number that it comes across ignoring any characters before it\n   */\n  private void splitString(String complete) {\n    // int cutPoint = 0;\n    int startOfNumber = 0;\n    int endOfNumber = 0;\n    int startOfRemainder = 0;\n    char current = ' ';\n    boolean numberFound = false;\n    boolean endOfNumberFound = false;\n    boolean letterFound = false;\n\n    if (complete != null) {\n      // looking for any digit/first digit in the string\n      while (!numberFound && startOfNumber < complete.length()) {\n        current = complete.charAt(startOfNumber);\n        if (Character.isDigit(current)) {\n          numberFound = true;\n          // moving startOfNumber back by 1 as incremented at the end of the loop.\n          // However, this does mean that if the first character is a\n          // digit startOfNumber is put back to -1 at this point.\n          // Next check is to see if there is minus symbol or a stop\n          // before the digit\n          // The java string to double convert handles inputs of the type\n          // .3 and -.3 as well as -0.3 so we are allowing them by moving back from the digit\n          // and checking for them.\n          startOfNumber = startOfNumber - 1;\n          if (startOfNumber >= 0) {\n            if (complete.charAt(startOfNumber) == '-') {\n              startOfNumber = startOfNumber - 1;\n            } else if (complete.charAt(startOfNumber) == '.') {\n              startOfNumber = startOfNumber - 1;\n              // startNumber can be -1 here if the stop is the first character in the string\n              if (startOfNumber >= 0 && complete.charAt(startOfNumber) == '-') {\n                startOfNumber = startOfNumber - 1;\n              }\n            }\n          }\n        }\n        startOfNumber++;\n      }\n\n      endOfNumber = startOfNumber + 1;\n      while (!endOfNumberFound && endOfNumber < complete.length()) {\n        current = complete.charAt(endOfNumber);\n        // looking for the first character that is not a digit or a stop\n        // or a minus sign after the start of the number\n        // note that this method will let through number strings of the type\n        // 9. or 0.99.9 or 0.9- etc that will then throw Double.NaN exceptions\n        // on attempting to convert to a double\n        if (!Character.isDigit(current)\n            && (current != '+')\n            && (current != '-')\n            && (current != '.')) {\n          endOfNumberFound = true;\n          // if there is no digit after the e\n          // then it is classed as a letter and not part of the number\n          // if it is part of the number then we reset endOfNumberFound to false\n          // and move on.\n          if (current == 'E' || current == 'e') {\n            if (endOfNumber < complete.length() - 1) {\n              char temp = complete.charAt(endOfNumber + 1);\n              if (Character.isDigit(temp) || (temp == '+') || (temp == '-') || (temp == '.')) {\n                // System.out.println(\"resetting letter found\");\n                endOfNumberFound = false;\n                endOfNumber++;\n              }\n            }\n          }\n          endOfNumber = endOfNumber - 1;\n        }\n        endOfNumber++;\n      }\n\n      // to see if there are any letters in the string after any\n      // number is found. Note that we are looking only for letters\n      // and any symbols before the first letter will be ignored and discarded.\n      // If a number has not been found then it will start at the beginning of the string\n      if (numberFound) {\n        startOfRemainder = endOfNumber;\n      }\n      while (!letterFound && startOfRemainder < complete.length()) {\n        current = complete.charAt(startOfRemainder++);\n        if (Character.isLetter(current)) {\n          letterFound = true;\n          startOfRemainder--;\n        }\n      }\n    }\n\n    if (numberFound) {\n      numberString = complete.substring(startOfNumber, endOfNumber);\n    } else {\n      numberString = \"\";\n    }\n\n    if (letterFound) {\n      unitsString = complete.substring(startOfRemainder, complete.length());\n    } else {\n      unitsString = \"\";\n    }\n    // System.out.println(\"numberString = \" + numberString + \" unitsString = \" + unitsString);\n  }\n"}, {"dataset": "charAt", "exampleID": 8230, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null&&string.length()>0&&index<string.length()", "guardType": "IF {", "guardExpressionStart": 62, "guardExpressionEnd": 121, "guardBlockStart": 62, "guardBlockEnd": 158, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 137, "focalAPIEnd": 151, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/svnkit/tree/master/svnkit/src/main/java/org/tmatesoft/svn/core/internal/wc/patch/SVNPatchHunk.java", "rawCode": "  private static char getChar(final String line, int i) {\n    if (line != null && line.length() > 0 && i < line.length()) {\n      return line.charAt(i);\n    }\n    return (char) 0;\n  }\n"}, {"dataset": "charAt", "exampleID": 8231, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 865, "focalAPIEnd": 889, "followUpCheck": "value == ';'", "checkType": "IF", "followUpCheckExpressionStart": 994, "followUpCheckExpressionEnd": 1014, "followUpCheckBlockStart": 994, "followUpCheckBlockEnd": 1043, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ischweizer/MoSeS--Client-/tree/master/moses/libs/sources-support-v4/src/java/android/support/v4/text/BidiFormatter.java", "rawCode": "    /**\n     * Advances charIndex backward through an HTML character entity tag (after the closing ; has\n     * already been read) and returns Character.DIRECTIONALITY_WHITESPACE. It would be best to\n     * figure out the actual character and return its dirtype, but this is good enough. If there is\n     * no matching &amp;, does not change charIndex and returns\n     * Character.DIRECTIONALITY_OTHER_NEUTRALS (for the ';' that did not start an entity after all).\n     * Nevertheless, the running time for calling skipEntityBackward() in a loop remains linear in\n     * the size of the text, even for a text like \";;;;;;;\", because skipTagBackward() also stops\n     * looking for a matching &amp; when it encounters another ;.\n     */\n    private byte skipEntityBackward() {\n      int initialCharIndex = charIndex;\n      while (charIndex > 0) {\n        lastChar = text.charAt(--charIndex);\n        if (lastChar == '&') {\n          return Character.DIRECTIONALITY_WHITESPACE;\n        }\n        if (lastChar == ';') {\n          break;\n        }\n      }\n      charIndex = initialCharIndex;\n      lastChar = ';';\n      return Character.DIRECTIONALITY_OTHER_NEUTRALS;\n    }\n"}, {"dataset": "charAt", "exampleID": 8232, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string.length()<1)", "guardType": "IF {", "guardExpressionStart": 152, "guardExpressionEnd": 176, "guardBlockStart": 152, "guardBlockEnd": 203, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 216, "focalAPIEnd": 232, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/email/ext/src/poi-3.2-FINAL/src/java/org/apache/poi/hssf/record/formula/functions/Countif.java", "rawCode": "  /** Boolean literals ('TRUE', 'FALSE') treated similarly but NOT same as numbers. */\n  /* package */ static Boolean parseBoolean(String strRep) {\n    if (strRep.length() < 1) {\n      return null;\n    }\n    switch (strRep.charAt(0)) {\n      case 't':\n      case 'T':\n        if (\"TRUE\".equalsIgnoreCase(strRep)) {\n          return Boolean.TRUE;\n        }\n        break;\n      case 'f':\n      case 'F':\n        if (\"FALSE\".equalsIgnoreCase(strRep)) {\n          return Boolean.FALSE;\n        }\n        break;\n    }\n    return null;\n  }\n"}, {"dataset": "charAt", "exampleID": 8233, "initialization": ["String string = toString()"], "initializationStart": [68], "initializationEnd": [78], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null||string.length()<1)", "guardType": "IF {", "guardExpressionStart": 85, "guardExpressionEnd": 117, "guardBlockStart": 85, "guardBlockEnd": 156, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 144, "focalAPIEnd": 155, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.quercus/src/main/java/com/caucho/quercus/env/Value.java", "rawCode": "  /** Converts to a char */\n  public char toChar() {\n    String s = toString();\n\n    if (s == null || s.length() < 1) return 0;\n    else return s.charAt(0);\n  }\n"}, {"dataset": "charAt", "exampleID": 8234, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.length()<3 && string.length()==2", "guardType": "IF {", "guardExpressionStart": 107, "guardExpressionEnd": 128, "guardBlockStart": 107, "guardBlockEnd": 2668, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 174, "focalAPIEnd": 187, "followUpCheck": "letra(value) < 6", "checkType": "IF", "followUpCheckExpressionStart": 224, "followUpCheckExpressionEnd": 257, "followUpCheckBlockStart": 224, "followUpCheckBlockEnd": 423, "use": ["string.charAt(int)", "string.substring(int,int)", "string.charAt(int)", "string.charAt(int)", "string.charAt(int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)"], "useStart": [201, 305, 487, 512, 537, 712, 807, 871, 999, 1059, 1266, 1330, 1406, 1525, 1585, 1760, 1951, 2046, 2110, 2205, 2359, 2419, 2538, 2598], "useEnd": [214, 324, 500, 525, 550, 731, 826, 890, 1018, 1078, 1285, 1349, 1425, 1544, 1604, 1779, 1970, 2065, 2129, 2224, 2378, 2438, 2557, 2617], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cloudfakers/rhymestore/tree/master/common/src/main/java/com/rhymestore/lang/es/SpanishWordParser.java", "rawCode": "  private String silaba(final String str) {\n    String temp = \"\";\n    String s = \"\";\n    char x, y, z;\n    if (str.length() < 3) {\n      if (str.length() == 2) {\n        x = str.charAt(0);\n        y = str.charAt(1);\n        if (letra(x) < 6 && letra(y) < 6) {\n          if (hiato(x, y)) {\n            s = str.substring(0, 1);\n          } else {\n            s = str;\n          }\n        } else {\n          s = str;\n        }\n      } else {\n        s = str;\n      }\n    } else {\n      x = str.charAt(0);\n      y = str.charAt(1);\n      z = str.charAt(2);\n      if (letra(x) < 6) { // V ? ?\n        if (letra(y) < 6) { // V V ?\n          if (letra(z) < 6) { // V V V\n            if (hiato(x, y)) {\n              s = str.substring(0, 1);\n            } else {\n              if (hiato(y, z)) {\n                s = str.substring(0, 2);\n              } else {\n                s = str.substring(0, 3);\n              }\n            }\n          } else { // V V C\n            if (hiato(x, y)) {\n              s = str.substring(0, 1);\n            } else {\n              s = str.substring(0, 2);\n            }\n          }\n        } else { // V C ?\n          if (letra(z) < 6) { // V C V\n            if (letra(y) == 6) { // V H C\n              if (hiato(x, z)) {\n                s = str.substring(0, 1);\n              } else {\n                s = str.substring(0, 3);\n              }\n            } else {\n              s = str.substring(0, 1);\n            }\n          } else { // V C C\n            if (consonantes1(y, z)) {\n              s = str.substring(0, 1);\n            } else {\n              s = str.substring(0, 2);\n            }\n          }\n        }\n      } else { // C ??\n        if (letra(y) < 6) { // C V ?\n          if (letra(z) < 6) { // C V V\n            temp = str.substring(0, 3);\n            if (temp.equals(\"que\")\n                || temp.equals(\"qui\")\n                || temp.equals(\"gue\")\n                || temp.equals(\"gui\")) {\n              s = str.substring(0, 3);\n            } else {\n              if (hiato(y, z)) {\n                s = str.substring(0, 2);\n              } else {\n                s = str.substring(0, 3);\n              }\n            }\n          } else { // C V C\n            s = str.substring(0, 2);\n          }\n        } else { // C C ?\n          if (letra(z) < 6) { // C C V\n            if (consonantes1(x, y)) {\n              s = str.substring(0, 3);\n            } else {\n              s = str.substring(0, 1);\n            }\n          } else { // C C C\n            if (consonantes1(y, z)) {\n              s = str.substring(0, 1);\n            } else {\n              s = str.substring(0, 1);\n            }\n          }\n        }\n      }\n    }\n    return s;\n  }\n"}, {"dataset": "charAt", "exampleID": 8235, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 61, "focalAPIEnd": 81, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.toUpperCase(value)"], "useStart": [39], "useEnd": [82], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thebohemian/android-buglabsdemo-build/tree/master/tools/droiddoc/src/KeywordEntry.java", "rawCode": "  public char firstChar() {\n    return Character.toUpperCase(this.label.charAt(0));\n  }\n"}, {"dataset": "charAt", "exampleID": 8236, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 1808, "focalAPIEnd": 1827, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.toUpperCase(value)", "string.length()"], "useStart": [1786, 1854], "useEnd": [1828, 1872], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/htmlunit-fork/tree/master/htmlunit/src/test/java/com/gargoylesoftware/htmlunit/javascript/regexp/mozilla/MozillaTestGenerator.java", "rawCode": "  /**\n   * Outputs java test case for the specified JavaScript source.\n   *\n   * @param author the author name\n   * @param htmlunitRoot HtmlUnit root path\n   * @param mozillaRoot Mozilla root path\n   * @param jsPath relative JavaScript source path, e.g. \"/js/src/tests/js1_2/regexp/everything.js\"\n   * @param initialScript whether another initial script is needed or not\n   * @throws IOException if a reading error occurs\n   */\n  public static void printMozillaTest(\n      final String author,\n      final String htmlunitRoot,\n      final String mozillaRoot,\n      final String jsPath,\n      final boolean initialScript)\n      throws IOException {\n    for (final Object o : FileUtils.readLines(new File(htmlunitRoot, \"LICENSE.txt\"))) {\n      System.out.println(o);\n    }\n    final String[] jsPathTokens = jsPath.split(\"/\");\n    System.out.println(\n        \"package com.gargoylesoftware.htmlunit.javascript.regexp.mozilla.\" + jsPathTokens[4] + \";\");\n    System.out.println();\n    System.out.println(\"import org.junit.Test;\");\n    System.out.println(\"import org.junit.runner.RunWith;\");\n    System.out.println();\n    System.out.println(\"import com.gargoylesoftware.htmlunit.BrowserRunner;\");\n    System.out.println(\"import com.gargoylesoftware.htmlunit.WebDriverTestCase;\");\n    System.out.println(\"import com.gargoylesoftware.htmlunit.BrowserRunner.Alerts;\");\n    System.out.println();\n    System.out.println(\"/**\");\n    System.out.println(\" * Tests originally in '\" + jsPath + \"'.\");\n    System.out.println(\" *\");\n    System.out.println(\" * @version $Revision$\");\n    System.out.println(\" * @author \" + author);\n    System.out.println(\" */\");\n    System.out.println(\"@RunWith(BrowserRunner.class)\");\n    String className = jsPathTokens[jsPathTokens.length - 1];\n    className =\n        Character.toUpperCase(className.charAt(0)) + className.substring(1, className.length() - 3);\n    System.out.println(\"public class \" + className + \"Test extends WebDriverTestCase {\");\n    final List<String> lines = FileUtils.readLines(new File(mozillaRoot, jsPath));\n    int testNumber = 1;\n    for (int i = 0; i < lines.size(); i++) {\n      final String line = lines.get(i);\n      if (line.startsWith(\"new TestCase\")) {\n        if (line.endsWith(\";\")) {\n          System.out.println(\"ERROR...... test case ends with ; in \" + (i + 1));\n          continue;\n        }\n        int x = i + 1;\n        String next = lines.get(x++).trim();\n        while (!next.endsWith(\";\")) {\n          next = lines.get(x++).trim();\n        }\n        final String expected = getExpected(next);\n        final String script;\n        if (next.startsWith(\"String(\")) {\n          final int p0 = next.indexOf(\"String(\", 1) + \"String(\".length();\n          script = next.substring(p0, next.length() - 3);\n        } else if (next.startsWith(\"\\\"\")) {\n          script = next.substring(expected.length() + 3, next.length() - 2).trim();\n        } else {\n          script = next.substring(next.indexOf(',') + 1, next.length() - 2).trim();\n        }\n        System.out.println();\n        System.out.println(\" /**\");\n        System.out.println(\" * Tests \" + script + \".\");\n        System.out.println(\" * @throws Exception if the test fails\");\n        System.out.println(\" */\");\n        System.out.println(\" @Test\");\n        System.out.println(\" @Alerts(\\\"\" + expected + \"\\\")\");\n        System.out.println(\" public void test\" + testNumber++ + \"() throws Exception {\");\n        if (initialScript) {\n          System.out.print(\" test(initialScript, \");\n        } else {\n          System.out.print(\" test(\");\n        }\n        System.out.println(\"\\\"\" + script.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\") + \"\\\");\");\n        System.out.println(\" }\");\n      }\n    }\n    System.out.println();\n    if (initialScript) {\n      System.out.println(\" private void test(final String script) throws Exception {\");\n      System.out.println(\" test(null, script);\");\n      System.out.println(\" }\");\n      System.out.println(\"\");\n      System.out.println(\n          \" private void test(final String initialScript, final String script) throws Exception {\");\n      System.out.println(\" String html = \\\"<html><head><title>foo</title><script>\\\\n\\\";\");\n      System.out.println(\" if (initialScript != null) {\");\n      System.out.println(\" html += initialScript + \\\";\\\\n\\\";\");\n      System.out.println(\" }\");\n      System.out.println(\" html += \\\" alert(\\\" + script + \\\");\\\\n\\\"\");\n      System.out.println(\" + \\\"</script></head><body>\\\\n\\\"\");\n      System.out.println(\" + \\\"</body></html>\\\";\");\n      System.out.println(\" loadPageWithAlerts2(html);\");\n      System.out.println(\" }\");\n    } else {\n      System.out.println(\" private void test(final String script) throws Exception {\");\n      System.out.println(\" final String html = \\\"<html><head><title>foo</title><script>\\\\n\\\"\");\n      System.out.println(\" + \\\" alert(\\\" + script + \\\");\\\\n\\\"\");\n      System.out.println(\" + \\\"</script></head><body>\\\\n\\\"\");\n      System.out.println(\" + \\\"</body></html>\\\";\");\n      System.out.println(\" loadPageWithAlerts2(html);\");\n      System.out.println(\" }\");\n    }\n    System.out.println(\"}\");\n  }\n"}, {"dataset": "charAt", "exampleID": 8237, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 69, "focalAPIEnd": 80, "followUpCheck": "value >= '0' && value <= '9'", "checkType": "LOOP {", "followUpCheckExpressionStart": 147, "followUpCheckExpressionEnd": 175, "followUpCheckBlockStart": 147, "followUpCheckBlockEnd": 289, "use": ["StringBuilder.append(value)", "string.charAt(int)"], "useStart": [184, 271], "useEnd": [196, 282], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/camunda/camunda-bpm-platform/tree/master/engine/src/main/java/org/camunda/bpm/engine/impl/calendar/CronExpression.java", "rawCode": "  protected ValueSet getValue(int v, String s, int i) {\n    char c = s.charAt(i);\n    StringBuilder s1 = new StringBuilder(String.valueOf(v));\n    while (c >= '0' && c <= '9') {\n      s1.append(c);\n      i++;\n      if (i >= s.length()) {\n        break;\n      }\n      c = s.charAt(i);\n    }\n    ValueSet val = new ValueSet();\n\n    val.pos = (i < s.length()) ? i : i + 1;\n    val.value = Integer.parseInt(s1.toString());\n    return val;\n  }\n"}, {"dataset": "charAt", "exampleID": 8238, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new EntityParseException(String,*)"], "tryExpressionStart": 441, "tryExpressionEnd": 445, "tryBlockStart": 441, "tryBlockEnd": 1050, "catchExpressionStart": 949, "catchExpressionEnd": 970, "catchBlockStart": 949, "catchBlockEnd": 1050, "exceptionHandlingCallStart": [984], "exceptionHandlingCallEnd": [1043], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<bid", "guardType": "LOOP {", "guardExpressionStart": 837, "guardExpressionEnd": 866, "guardBlockStart": 837, "guardBlockEnd": 912, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 886, "focalAPIEnd": 903, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta05/kernel-impl/src/main/java/org/sakaiproject/content/impl/serialize/impl/Type1BaseContentCollectionSerializer.java", "rawCode": "  /**\n   * @deprecated\n   * @param se\n   * @return\n   * @throws EntityParseException\n   */\n  private String serializeString(SerializableEntity se) throws EntityParseException {\n    if (!(se instanceof SerializableCollectionAccess)) {\n      throw new EntityParseException(\n          \"Cant serialize \" + se + \" as it is not a SerializableCollectionAccess \");\n    }\n    SerializableCollectionAccess sc = (SerializableCollectionAccess) se;\n\n    try {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      DataOutputStream ds = new DataOutputStream(baos);\n\n      doSerialize(sc, ds);\n\n      ds.flush();\n      baos.flush();\n      byte[] op = baos.toByteArray();\n      char[] opc = new char[op.length + BLOB_ID.length()];\n      int bid = BLOB_ID.length();\n\n      ByteStorageConversion.toChar(op, 0, opc, bid, op.length);\n\n      for (int i = 0; i < bid; i++) {\n        opc[i] = BLOB_ID.charAt(i);\n      }\n      return new String(opc);\n    } catch (Exception ex) {\n      throw new EntityParseException(\"Failed to serialize entity \", ex);\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8239, "initialization": ["String string = getNextLine()"], "initializationStart": [651], "initializationEnd": [664], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null) && index<string.length()", "guardType": "IF {", "guardExpressionStart": 336, "guardExpressionEnd": 357, "guardBlockStart": 336, "guardBlockEnd": 384, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 781, "focalAPIEnd": 799, "followUpCheck": "value == quotechar", "checkType": "IF", "followUpCheckExpressionStart": 809, "followUpCheckExpressionEnd": 828, "followUpCheckBlockStart": 809, "followUpCheckBlockEnd": 2204, "use": ["string.charAt(int)", "StringBuffer.append(value)", "StringBuffer.append(value)"], "useStart": [1160, 1954, 2181], "useEnd": [1182, 1966, 2193], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/venukumar/bartsy-venue-android/tree/master/src/com/vendsy/bartsy/venue/utils/CSVReader.java", "rawCode": "  /**\n   * Parses an incoming String and returns an array of elements.\n   *\n   * @param nextLine the string to parse\n   * @return the comma-tokenized list of elements, or null if nextLine is null\n   * @throws IOException if bad things happen during the read\n   */\n  private String[] parseLine(String nextLine) throws IOException {\n\n    if (nextLine == null) {\n      return null;\n    }\n\n    List<String> tokensOnThisLine = new ArrayList<String>();\n    StringBuffer sb = new StringBuffer();\n    boolean inQuotes = false;\n    do {\n      if (inQuotes) {\n        // continuing a quoted section, reappend newline\n        sb.append(\"\\n\");\n        nextLine = getNextLine();\n        if (nextLine == null) break;\n      }\n      for (int i = 0; i < nextLine.length(); i++) {\n\n        char c = nextLine.charAt(i);\n        if (c == quotechar) {\n          // this gets complex... the quote may end a quoted block, or escape another quote.\n          // do a 1-char lookahead:\n          if (inQuotes // we are in quotes, therefore there can be escaped quotes in here.\n              && nextLine.length() > (i + 1) // there is indeed another character to check.\n              && nextLine.charAt(i + 1) == quotechar) { // ..and that char. is a quote also.\n            // we have two quote chars in a row == one quote char, so consume them both and\n            // put one on the token. we do *not* exit the quoted text.\n            sb.append(nextLine.charAt(i + 1));\n            i++;\n          } else {\n            inQuotes = !inQuotes;\n            // the tricky case of an embedded quote in the middle: a,bc\"d\"ef,g\n            if (i > 2 // not on the begining of the line\n                && nextLine.charAt(i - 1)\n                    != this.separator // not at the begining of an escape sequence\n                && nextLine.length() > (i + 1)\n                && nextLine.charAt(i + 1) != this.separator // not at the end of an escape sequence\n            ) {\n              sb.append(c);\n            }\n          }\n        } else if (c == separator && !inQuotes) {\n          tokensOnThisLine.add(sb.toString());\n          sb = new StringBuffer(); // start work on next token\n        } else {\n          sb.append(c);\n        }\n      }\n    } while (inQuotes);\n    tokensOnThisLine.add(sb.toString());\n    return (String[]) tokensOnThisLine.toArray(new String[0]);\n  }\n"}, {"dataset": "charAt", "exampleID": 8240, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 95, "focalAPIEnd": 115, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crewpuk/Lulu-delivery/tree/master/lib/dojo/util/shrinksafe/src/org/dojotoolkit/shrinksafe/Compressor.java", "rawCode": "  private static int getNext(String source, int length, int i) {\n    return (i + 1 < length) ? source.charAt(i + 1) : Token.EOF;\n  }\n"}, {"dataset": "charAt", "exampleID": 8241, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 306, "guardExpressionEnd": 342, "guardBlockStart": 306, "guardBlockEnd": 691, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 360, "focalAPIEnd": 371, "followUpCheck": "value == '\\\\'", "checkType": "IF", "followUpCheckExpressionStart": 379, "followUpCheckExpressionEnd": 393, "followUpCheckBlockStart": 379, "followUpCheckBlockEnd": 685, "use": ["string.charAt(int)", "StringBuilder.append(value)"], "useStart": [427, 672], "useEnd": [438, 684], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/antlr/antlrworks/tree/master/src/org/antlr/works/menu/GrammarRefactorMenu.java", "rawCode": "  protected String escapeStringQuote(String s, char escapeQuote, char unescapeQuote) {\n    // Escape the quote found in s.\n    // Example:\n    // \"hello'world\" -> 'hello\\'world'\n    // \"hello\\'world\" -> 'hello\\'world'\n    // \"hello\\\"world\" -> 'hello\"world'\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      if (c == '\\\\') {\n        i++;\n        char c1 = s.charAt(i);\n        if (c1 == unescapeQuote) sb.append(c1);\n        else {\n          sb.append('\\\\');\n          sb.append(c1);\n        }\n      } else if (c == escapeQuote) {\n        sb.append('\\\\');\n        sb.append(escapeQuote);\n      } else sb.append(c);\n    }\n\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8242, "initialization": ["String string = String.substring(int,int)"], "initializationStart": [548], "initializationEnd": [575], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(rightStr.length()<=index) && !(string.length()<=index) && !(separator<index)", "guardType": "IF {", "guardExpressionStart": 414, "guardExpressionEnd": 432, "guardBlockStart": 414, "guardBlockEnd": 525, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 1182, "focalAPIEnd": 1199, "followUpCheck": "value == 'P' || value == 'p'", "checkType": "IF", "followUpCheckExpressionStart": 1205, "followUpCheckExpressionEnd": 1230, "followUpCheckBlockStart": 1205, "followUpCheckBlockEnd": 1485, "use": ["getPeriodType(string)", "parsePeriod(string)", "DateTimeFormatter.parseDateTime(string)"], "useStart": [1275, 1248, 1357], "useEnd": [1297, 1319, 1394], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/timrdf/csv2rdf4lod-automation/tree/master/lib/joda-time-2.0/src/main/java/org/joda/time/convert/StringConverter.java", "rawCode": "  /**\n   * Sets the value of the mutable interval from the string.\n   *\n   * @param writableInterval the interval to set\n   * @param object the String to convert, must not be null\n   * @param chrono the chronology to use, may be null\n   */\n  public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n    String str = (String) object;\n\n    int separator = str.indexOf('/');\n    if (separator < 0) {\n      throw new IllegalArgumentException(\"Format requires a '/' separator: \" + str);\n    }\n\n    String leftStr = str.substring(0, separator);\n    if (leftStr.length() <= 0) {\n      throw new IllegalArgumentException(\"Format invalid: \" + str);\n    }\n    String rightStr = str.substring(separator + 1);\n    if (rightStr.length() <= 0) {\n      throw new IllegalArgumentException(\"Format invalid: \" + str);\n    }\n\n    DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser();\n    dateTimeParser = dateTimeParser.withChronology(chrono);\n    PeriodFormatter periodParser = ISOPeriodFormat.standard();\n    long startInstant = 0, endInstant = 0;\n    Period period = null;\n    Chronology parsedChrono = null;\n\n    // before slash\n    char c = leftStr.charAt(0);\n    if (c == 'P' || c == 'p') {\n      period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr);\n    } else {\n      DateTime start = dateTimeParser.parseDateTime(leftStr);\n      startInstant = start.getMillis();\n      parsedChrono = start.getChronology();\n    }\n\n    // after slash\n    c = rightStr.charAt(0);\n    if (c == 'P' || c == 'p') {\n      if (period != null) {\n        throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n      }\n      period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr);\n      chrono = (chrono != null ? chrono : parsedChrono);\n      endInstant = chrono.add(period, startInstant, 1);\n    } else {\n      DateTime end = dateTimeParser.parseDateTime(rightStr);\n      endInstant = end.getMillis();\n      parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n      chrono = (chrono != null ? chrono : parsedChrono);\n      if (period != null) {\n        startInstant = chrono.add(period, endInstant, -1);\n      }\n    }\n\n    writableInterval.setInterval(startInstant, endInstant);\n    writableInterval.setChronology(chrono);\n  }\n"}, {"dataset": "charAt", "exampleID": 8243, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 66, "focalAPIEnd": 80, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["isLetter(value)", "string.charAt(int)"], "useStart": [47, 104], "useEnd": [81, 122], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7876/src/net/sourceforge/plantuml/suggest/VariatorSwapLetter.java", "rawCode": "  private boolean areTwoLetters() {\n    return Character.isLetter(data.charAt(i)) && Character.isLetter(data.charAt(i + 1));\n  }\n"}, {"dataset": "charAt", "exampleID": 8244, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 115, "focalAPIEnd": 133, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.toUpperCase(value)"], "useStart": [93], "useEnd": [134], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/tools/tree/master/poc/bps/org.eclipse.bpel.validator/src/org/eclipse/bpel/validator/plt/Factory.java", "rawCode": "  @SuppressWarnings(\"nls\")\n  Validator createValidator(String nodeName) {\n\n    String name = Character.toUpperCase(nodeName.charAt(0)) + nodeName.substring(1);\n\n    String validatorClass = PACKAGE_NAME + \".\" + name + \"Validator\";\n\n    Object obj;\n    Class<?> clazz;\n    try {\n      clazz = Class.forName(validatorClass);\n    } catch (ClassNotFoundException e) {\n      mLogger.log(Level.FINE, \"Validator not found in this factory {0}\", e.getMessage());\n      return null;\n    }\n\n    try {\n      obj = clazz.newInstance();\n    } catch (Exception ex) {\n      mLogger.log(Level.WARNING, \"Validator class cannot be created.\", ex);\n      return null;\n    }\n\n    if (obj instanceof Validator) {\n      return (Validator) obj;\n    }\n    mLogger.log(Level.WARNING, \"Object is {0} is not a validator\", obj);\n    return null;\n  }\n"}, {"dataset": "charAt", "exampleID": 8245, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 95, "focalAPIEnd": 110, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setTurn(value)", "string.charAt(int)"], "useStart": [81, 247], "useEnd": [111, 264], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GamesCrafters/GamesmanJava/tree/master/GamesmanJava-parallel/src/main/java/edu/berkeley/gamesman/parallel/game/reversi/Reversi.java", "rawCode": "  @Override\n  public T getPosition(String board) {\n    T state = newState();\n    state.setTurn(board.charAt(0));\n    int i = 1;\n    for (int row = 0; row < height; row++) {\n      for (int col = 0; col < width; col++) {\n        state.set(row, col, board.charAt(i++));\n      }\n    }\n    while (canPass(state)) {\n      state.makePass();\n    }\n    return state;\n  }\n"}, {"dataset": "charAt", "exampleID": 8246, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<T.length()", "guardType": "LOOP {", "guardExpressionStart": 203, "guardExpressionEnd": 239, "guardBlockStart": 203, "guardBlockEnd": 275, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 254, "focalAPIEnd": 265, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wuyq101/acm_test/tree/master/src/com/leetcode/MinWindow.java", "rawCode": "  public String minWindow(String S, String T) {\n    if (S == null || T == null) return \"\";\n    if (S.length() < T.length()) return \"\";\n    int[] total = new int[265];\n    int[] count = new int[256];\n    for (int i = 0; i < T.length(); i++) {\n      total[T.charAt(i)]++;\n    }\n    int cnt = 0;\n    int best_start = -1, best_end = -1;\n    for (int start = 0, end = 0; end < S.length(); end++) {\n      char ch = S.charAt(end);\n      if (total[ch] == 0) continue;\n      count[ch]++;\n      if (count[ch] <= total[ch]) cnt++;\n      if (cnt == T.length()) {\n        // find a window\n        // move start ro right as right as possible\n        while (total[S.charAt(start)] == 0 || count[S.charAt(start)] > total[S.charAt(start)]) {\n          if (count[S.charAt(start)] > total[S.charAt(start)]) count[S.charAt(start)]--;\n          start++;\n        }\n        if (best_start == -1) {\n          best_start = start;\n          best_end = end;\n        } else if (end - start < best_end - best_start) {\n          best_start = start;\n          best_end = end;\n        }\n      }\n    }\n    if (best_start == -1) return \"\";\n    return S.substring(best_start, best_end + 1);\n  }\n"}, {"dataset": "charAt", "exampleID": 8247, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 245, "focalAPIEnd": 260, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SjB/Dart/tree/master/editor/tools/plugins/com.google.dart.tools.core/src/com/google/dart/tools/core/internal/model/DartFunctionImpl.java", "rawCode": "  @Override\n  protected DartElement getHandleFromMemento(\n      String token, MementoTokenizer tokenizer, WorkingCopyOwner owner) {\n    DartCore.notYetImplemented();\n    // TODO(brianwilkerson) This doesn't handle unnamed functions.\n    switch (token.charAt(0)) {\n      case MEMENTO_DELIMITER_FUNCTION:\n        if (!tokenizer.hasMoreTokens()) {\n          return this;\n        }\n        DartFunctionImpl function = new DartFunctionImpl(this, tokenizer.nextToken());\n        return function.getHandleFromMemento(tokenizer, owner);\n      case MEMENTO_DELIMITER_VARIABLE:\n        if (!tokenizer.hasMoreTokens()) {\n          return this;\n        }\n        DartVariableImpl variable = new DartVariableImpl(this, tokenizer.nextToken());\n        return variable.getHandleFromMemento(tokenizer, owner);\n    }\n    return null;\n  }\n"}, {"dataset": "charAt", "exampleID": 8248, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [243], "configurationEnd": [258], "guardCondition": "bitwise", "guardType": "IF {", "guardExpressionStart": 61, "guardExpressionEnd": 149, "guardBlockStart": 61, "guardBlockEnd": 181, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 312, "focalAPIEnd": 328, "followUpCheck": "value == '%'", "checkType": "IF", "followUpCheckExpressionStart": 336, "followUpCheckExpressionEnd": 349, "followUpCheckBlockStart": 336, "followUpCheckBlockEnd": 555, "use": ["StringBuffer.append(value)"], "useStart": [530], "useEnd": [546], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Zearin/BibTeXML/tree/master/bibtexconverter-j-libs/jaxp-isorelax/src/jp/gr/xml/relax/xml/UXML.java", "rawCode": "  public static String escapeEntityQuot(String string) {\n    if (string.indexOf('%') == -1 && string.indexOf('&') == -1 && string.indexOf('\"') == -1) {\n\n      return (string);\n    }\n    StringBuffer buffer = new StringBuffer();\n    int size = string.length();\n    for (int i = 0; i < size; i++) {\n      char c = string.charAt(i);\n      if (c == '%') {\n        buffer.append(\"&---;\");\n      } else if (c == '&') {\n        buffer.append(\"&amp;\");\n      } else if (c == '\"') {\n        buffer.append(\"&quot;\");\n      } else {\n        buffer.append(c);\n      }\n    }\n    return (new String(buffer));\n  }\n"}, {"dataset": "charAt", "exampleID": 8249, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 270, "focalAPIEnd": 289, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/monish001/CPP-Programs/tree/master/General/Timetable Project/Page2nd11.java", "rawCode": "  public static String[] findAvailList(int d, int p, String tableName) {\n    // new myFrame();\n    String[] fullList = ParticularTT.initialOptions(tableName, \"id\");\n    int fullNo = ParticularTT.noOfItems;\n    String[] busyList = ParticularTT.initialOptions(d, p, \"tt\", tableName.charAt(0) + \"id\");\n    int busyNo = ParticularTT.noOfItems;\n    String[] availList;\n    int availNo = fullNo - busyNo + 1;\n    if (availNo <= 1) availList = null;\n    else {\n      availList = new String[availNo];\n      int count = 0;\n      availList[0] = \"-Select \" + tableName + \"-\";\n      boolean flag = true; // true means f is available\n      for (String f : fullList) {\n        flag = true;\n        for (String b : busyList) {\n          if (b.equals(f)) {\n            flag = false;\n            break;\n          }\n        }\n        if (flag == true) {\n          count++;\n          if (count >= availNo)\n            System.out.println(\"Page2nd.java: 380: overflow in availList of \" + tableName);\n          availList[count] = f;\n        }\n      }\n    }\n    return (availList);\n  }\n"}, {"dataset": "charAt", "exampleID": 8250, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [811], "configurationEnd": [825], "guardCondition": "!(string==null) && index<len", "guardType": "IF {", "guardExpressionStart": 528, "guardExpressionEnd": 546, "guardBlockStart": 528, "guardBlockEnd": 557, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 882, "focalAPIEnd": 897, "followUpCheck": "value < 128", "checkType": "IF", "followUpCheckExpressionStart": 2005, "followUpCheckExpressionEnd": 2017, "followUpCheckBlockStart": 2005, "followUpCheckBlockEnd": 2445, "use": ["string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "string.substring(int,int)", "StringBuilder.append(value)", "StringBuilder.append(value)", "string.substring(int,int)"], "useStart": [1009, 1190, 1371, 1553, 1774, 1894, 2053, 2284], "useEnd": [1030, 1211, 1392, 1574, 1795, 1907, 2066, 2305], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sakai-mirror/util/tree/master/util-util/util/src/java/org/sakaiproject/util/Web.java", "rawCode": "  /**\n   * Escape the given value so that it appears as-is in HTML - that is, HTML meta-characters like\n   * '<' are escaped to HTML character entity references like '&lt;'. Markup, amper, quote are\n   * escaped. Whitespace is not.\n   *\n   * @param value The string to escape.\n   * @param escapeNewlines Whether to escape newlines as \"&lt;br /&gt;\\n\" so that they appear as\n   *     HTML line breaks.\n   * @return value fully escaped for HTML.\n   */\n  public static String escapeHtml(String value, boolean escapeNewlines) {\n    if (value == null) return \"\";\n\n    try {\n      // lazily allocate the StringBuilder\n      // only if changes are actually made; otherwise\n      // just return the given string without changing it.\n      StringBuilder buf = (false) ? null : new StringBuilder();\n      final int len = value.length();\n      for (int i = 0; i < len; i++) {\n        char c = value.charAt(i);\n        switch (c) {\n          case '<':\n            {\n              if (buf == null) buf = new StringBuilder(value.substring(0, i));\n              buf.append(\"&lt;\");\n            }\n            break;\n\n          case '>':\n            {\n              if (buf == null) buf = new StringBuilder(value.substring(0, i));\n              buf.append(\"&gt;\");\n            }\n            break;\n\n          case '&':\n            {\n              if (buf == null) buf = new StringBuilder(value.substring(0, i));\n              buf.append(\"&amp;\");\n            }\n            break;\n\n          case '\"':\n            {\n              if (buf == null) buf = new StringBuilder(value.substring(0, i));\n              buf.append(\"&quot;\");\n            }\n            break;\n          case '\\n':\n            {\n              if (escapeNewlines) {\n                if (buf == null) buf = new StringBuilder(value.substring(0, i));\n                buf.append(\"<br />\\n\");\n              } else {\n                if (buf != null) buf.append(c);\n              }\n            }\n            break;\n          default:\n            {\n              if (c < 128) {\n                if (buf != null) buf.append(c);\n              } else {\n                // escape higher Unicode characters using an\n                // HTML numeric character entity reference like \"&#15672;\"\n                if (buf == null) buf = new StringBuilder(value.substring(0, i));\n                buf.append(\"&#\");\n                buf.append(Integer.toString((int) c));\n                buf.append(\";\");\n              }\n            }\n            break;\n        }\n      } // for\n\n      return (buf == null) ? value : buf.toString();\n    } catch (Exception e) {\n      return value;\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8251, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 61, "focalAPIEnd": 72, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/julianhyde/optiq/tree/master/core/src/main/java/net/hydromatic/optiq/runtime/SqlFunctions.java", "rawCode": "  public static Character toCharBoxed(String s) {\n    return s.charAt(0);\n  }\n"}, {"dataset": "charAt", "exampleID": 8252, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [80], "configurationEnd": [92], "guardCondition": "index<len", "guardType": "LOOP {", "guardExpressionStart": 98, "guardExpressionEnd": 127, "guardBlockStart": 98, "guardBlockEnd": 441, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 146, "focalAPIEnd": 159, "followUpCheck": "value == '-'", "checkType": "IF", "followUpCheckExpressionStart": 167, "followUpCheckExpressionEnd": 181, "followUpCheckBlockStart": 167, "followUpCheckBlockEnd": 191, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/distributed/tree/master/Fast_Copy_HDFS/src/test/org/apache/hadoop/security/token/TestToken.java", "rawCode": "  private static void checkUrlSafe(String str) throws Exception {\n    int len = str.length();\n    for (int i = 0; i < len; ++i) {\n      char ch = str.charAt(i);\n      if (ch == '-') continue;\n      if (ch == '_') continue;\n      if (ch >= '0' && ch <= '9') continue;\n      if (ch >= 'A' && ch <= 'Z') continue;\n      if (ch >= 'a' && ch <= 'z') continue;\n      fail(\"Encoded string \" + str + \" has invalid character at position \" + i);\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8253, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length() && !(string.length()%4!=0)", "guardType": "IF {", "guardExpressionStart": 39, "guardExpressionEnd": 63, "guardBlockStart": 39, "guardBlockEnd": 135, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 289, "focalAPIEnd": 300, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.charAt(int)", "string.charAt(int)", "string.charAt(int)", "decode3bytes(byte[],int,value,*,*,*)"], "useStart": [302, 319, 336, 265], "useEnd": [317, 334, 351, 352], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7746/src/net/sourceforge/plantuml/code/AsciiEncoder.java", "rawCode": "  public byte[] decode(String s) {\n    if (s.length() % 4 != 0) {\n      throw new IllegalArgumentException(\"Cannot decode \" + s);\n    }\n    final byte data[] = new byte[(s.length() * 3 + 3) / 4];\n    int pos = 0;\n    for (int i = 0; i < s.length(); i += 4) {\n      decode3bytes(data, pos, s.charAt(i), s.charAt(i + 1), s.charAt(i + 2), s.charAt(i + 3));\n      pos += 3;\n    }\n    return data;\n  }\n"}, {"dataset": "charAt", "exampleID": 8254, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null&&string.length()!=index", "guardType": "IF {", "guardExpressionStart": 46, "guardExpressionEnd": 89, "guardBlockStart": 46, "guardBlockEnd": 164, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 107, "focalAPIEnd": 123, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jgralab/jgralab-dhht/tree/master/src/de/uni_koblenz/jgralab/utilities/tg2dot/greql2/funlib/AbbreviateString.java", "rawCode": "  public String evaluate(String string) {\n    if (string != null && string.length() != 0) {\n      string = string.charAt(0) + string.replaceAll(\"[a-z]+\", \"\");\n    }\n    return string;\n  }\n"}, {"dataset": "charAt", "exampleID": 8255, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [123], "configurationEnd": [136], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 103, "guardExpressionEnd": 142, "guardBlockStart": 103, "guardBlockEnd": 995, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 160, "focalAPIEnd": 174, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["StringBuffer.append(value)"], "useStart": [964], "useEnd": [980], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/commons/tree/master/qa/qa-artifacts/app-server/as-5.2.0/myfaces/javaee7/servlet/async-request-war/src/main/java/org/glassfish/servlet/async_request_war/AjaxCometServlet.java", "rawCode": "  private String escape(String orig) {\n    StringBuffer buffer = new StringBuffer(orig.length());\n\n    for (int i = 0; i < orig.length(); i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\b':\n          buffer.append(\"\\\\b\");\n          break;\n        case '\\f':\n          buffer.append(\"\\\\f\");\n          break;\n        case '\\n':\n          buffer.append(\"<br />\");\n          break;\n        case '\\r':\n          // ignore\n          break;\n        case '\\t':\n          buffer.append(\"\\\\t\");\n          break;\n        case '\\'':\n          buffer.append(\"\\\\'\");\n          break;\n        case '\\\"':\n          buffer.append(\"\\\\\\\"\");\n          break;\n        case '\\\\':\n          buffer.append(\"\\\\\\\\\");\n          break;\n        case '<':\n          buffer.append(\"&lt;\");\n          break;\n        case '>':\n          buffer.append(\"&gt;\");\n          break;\n        case '&':\n          buffer.append(\"&amp;\");\n          break;\n        default:\n          buffer.append(c);\n      }\n    }\n\n    return buffer.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8256, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [251], "configurationEnd": [273], "guardCondition": "string!=null&&string.length()>0 && !(string.equals(\"Server\",))", "guardType": "IF {", "guardExpressionStart": 222, "guardExpressionEnd": 278, "guardBlockStart": 222, "guardBlockEnd": 669, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 467, "focalAPIEnd": 515, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getNumericValue(value)", "new ChallengeMessage(string,int)"], "useStart": [441, 574], "useEnd": [516, 619], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MagnusHedlund/Battleships/tree/master/Client/src/battleships/client/ClientUI.java", "rawCode": "  /**\n   * Action Events in LOBBY WINDOW.\n   *\n   * @param e ActionEvent\n   */\n  private void lobbyEvents(ActionEvent e) {\n    if (e.getSource() == challengeButton) {\n\n      // Skicka ett challenge till den man valt\n      if (lobbySelected != null && lobbySelected.length() > 0) {\n        waitingForChallenge = false;\n\n        // Stter ID och Namn\n        int playerID = 0;\n        if (!lobbySelected.equals(\"Server\"))\n          playerID = Character.getNumericValue(lobbySelected.charAt(lobbySelected.length() - 1));\n\n        // Skicka\n        ChallengeMessage challenge = new ChallengeMessage(lobbySelected, playerID);\n        cNetwork.sendMessage(challenge);\n      }\n    } else if (e.getSource() == refreshButton) {\n      refreshLobby();\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8257, "initialization": ["String string = StringTokenizer.nextToken()"], "initializationStart": [362], "initializationEnd": [375], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.length()==1", "guardType": "IF {", "guardExpressionStart": 383, "guardExpressionEnd": 407, "guardBlockStart": 383, "guardBlockEnd": 1649, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 427, "focalAPIEnd": 442, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["process(string)", "process(string)"], "useStart": [1529, 1616], "useEnd": [1543, 1630], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/tools/org/h2/build/indexer/Indexer.java", "rawCode": "  private void readPage(File file) throws Exception {\n    byte[] data = IOUtils.readBytesAndClose(new FileInputStream(file), 0);\n    String text = new String(data, \"UTF-8\");\n    StringTokenizer t = new StringTokenizer(text, \"<> \\r\\n\", true);\n    boolean inTag = false;\n    title = false;\n    heading = false;\n    while (t.hasMoreTokens()) {\n      String token = t.nextToken();\n      if (token.length() == 1) {\n        char c = token.charAt(0);\n        switch (c) {\n          case '<':\n            {\n              if (inTag) {\n                process(\"???\");\n              }\n              inTag = true;\n              if (!t.hasMoreTokens()) {\n                break;\n              }\n              token = t.nextToken();\n              if (token.startsWith(\"/\")) {\n                title = false;\n                heading = false;\n              } else if (token.equalsIgnoreCase(\"title\")) {\n                title = true;\n              } else if (token.length() == 2\n                  && Character.toLowerCase(token.charAt(0)) == 'h'\n                  && Character.isDigit(token.charAt(1))) {\n                heading = true;\n              }\n              // TODO maybe skip script tags?\n              break;\n            }\n          case '>':\n            {\n              if (!inTag) {\n                process(\"???\");\n              }\n              inTag = false;\n              break;\n            }\n          case '\\r':\n          case '\\n':\n          case ' ':\n            break;\n          default:\n            if (!inTag) {\n              process(token);\n            }\n        }\n      } else {\n        if (!inTag) {\n          process(token);\n        }\n      }\n    }\n\n    if (page.title == null || page.title.trim().length() == 0) {\n      System.out.println(\"Error: not title found in \" + file.getName());\n      page.title = file.getName();\n    }\n    page.title = page.title.trim();\n  }\n"}, {"dataset": "charAt", "exampleID": 8258, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<endIndex && !(string==null||string.length()==0||string.indexOf('\"',)==-1)", "guardType": "IF {", "guardExpressionStart": 309, "guardExpressionEnd": 366, "guardBlockStart": 309, "guardBlockEnd": 390, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 498, "focalAPIEnd": 509, "followUpCheck": "value == '\\\\'", "checkType": "IF", "followUpCheckExpressionStart": 517, "followUpCheckExpressionEnd": 531, "followUpCheckBlockStart": 517, "followUpCheckBlockEnd": 848, "use": ["StringBuffer.append(value)", "string.charAt(int)", "StringBuffer.append(value)"], "useStart": [542, 756, 836], "useEnd": [553, 767, 847], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.0-b02/api/src/main/java/org/sakaiproject/util/ServerCookie.java", "rawCode": "  /**\n   * Escapes any double quotes in the given string.\n   *\n   * @param s the input string\n   * @param beginIndex start index inclusive\n   * @param endIndex exclusive\n   * @return The (possibly) escaped string\n   */\n  private static String escapeDoubleQuotes(String s, int beginIndex, int endIndex) {\n\n    if (s == null || s.length() == 0 || s.indexOf('\"') == -1) {\n      return s;\n    }\n\n    StringBuffer b = new StringBuffer();\n    for (int i = beginIndex; i < endIndex; i++) {\n      char c = s.charAt(i);\n      if (c == '\\\\') {\n        b.append(c);\n        // ignore the character after an escape, just append it\n        if (++i >= endIndex)\n          throw new IllegalArgumentException(\"Invalid escape character in cookie value.\");\n        b.append(s.charAt(i));\n      } else if (c == '\"') b.append('\\\\').append('\"');\n      else b.append(c);\n    }\n\n    return b.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8259, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<state.length()", "guardType": "LOOP {", "guardExpressionStart": 589, "guardExpressionEnd": 629, "guardBlockStart": 589, "guardBlockEnd": 692, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 662, "focalAPIEnd": 677, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RudolfWeeber/eyes-free/tree/master/tags/LastVersionForSDK1.1/there/src/com/google/marvin/there/Guide.java", "rawCode": "  public void onAddressLocated(String address) {\n    currentAddress = \"\";\n    if (address.length() > 0) {\n      // Drop the country\n      address = address.substring(0, address.lastIndexOf(\",\"));\n      // Extract the state and zip and insert spaces in the state name\n      // that the synthesizer will do the right thing.\n      String rawStateZip = address.substring(address.lastIndexOf(\",\") + 1);\n      String zip = rawStateZip.substring(rawStateZip.lastIndexOf(\" \") + 1);\n      String state = rawStateZip.substring(0, rawStateZip.lastIndexOf(\" \") + 1);\n      String stateZip = \"\";\n      for (int i = 0; i < state.length(); i++) {\n        stateZip = stateZip + state.charAt(i) + \" \";\n      }\n      stateZip = stateZip + zip;\n      currentAddress = address.substring(0, address.lastIndexOf(\",\")) + \". \" + stateZip;\n\n      parent.tts.speak(\"Near \" + currentAddress, 1, null);\n    }\n    if (currentLocation != null) {\n      double heading = compass.getCurrentHeadingValue();\n      if (heading != -1) {\n        locator.getStreetsInFrontAndBackAsync(\n            currentLocation.getLatitude(),\n            currentLocation.getLongitude(),\n            compass.getCurrentHeadingValue());\n      }\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8260, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 95, "guardExpressionEnd": 131, "guardBlockStart": 95, "guardBlockEnd": 494, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 149, "focalAPIEnd": 160, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["StringBuilder.append(value)"], "useStart": [467], "useEnd": [479], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/main/java/java/util/prefs/XMLParser.java", "rawCode": "  private static String htmlEncode(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '<':\n          sb.append(\"&lt;\");\n          break;\n        case '>':\n          sb.append(\"&gt;\");\n          break;\n        case '&':\n          sb.append(\"&amp;\");\n          break;\n        case '\"':\n          sb.append(\"&quot;\");\n          break;\n        default:\n          sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8261, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()", "string.length()"], "configurationStart": [92, 121], "configurationEnd": [106, 135], "guardCondition": "index<l", "guardType": "LOOP {", "guardExpressionStart": 141, "guardExpressionEnd": 168, "guardBlockStart": 141, "guardBlockEnd": 758, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 187, "focalAPIEnd": 202, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.substring(int,int)", "StringBuffer.append(value)"], "useStart": [398, 734], "useEnd": [423, 751], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/svnkit/tree/master/svnkit/src/main/java/org/tmatesoft/svn/core/internal/util/SVNEncodingUtil.java", "rawCode": "  public static String xmlDecode(String value) {\n    StringBuffer result = new StringBuffer(value.length());\n    int l = value.length();\n    for (int i = 0; i < l; i++) {\n      char ch = value.charAt(i);\n      if (ch == '&') {\n        String replacement = null;\n        for (int j = i + 1; j < i + 6 && j < l; j++) {\n          if (value.charAt(j) == ';' && j - i > 1) {\n            String escape = value.substring(i, j + 1); // full\n            replacement = (String) XML_UNESCAPE_MAP.get(escape);\n            if (replacement != null) {\n              result.append(replacement);\n              i = j;\n            }\n            break;\n          }\n        }\n        if (replacement != null) {\n          continue;\n        }\n      }\n      result.append(ch);\n    }\n    return result.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8262, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [378], "configurationEnd": [396], "guardCondition": "string.indexOf('@',start,)!=-1 && index<end", "guardType": "IF {", "guardExpressionStart": 492, "guardExpressionEnd": 532, "guardBlockStart": 492, "guardBlockEnd": 766, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 582, "focalAPIEnd": 605, "followUpCheck": "value == '@'", "checkType": "IF", "followUpCheckExpressionStart": 616, "followUpCheckExpressionEnd": 636, "followUpCheckBlockStart": 616, "followUpCheckBlockEnd": 665, "use": ["string.substring(int,int)", "string.charAt(int)", "string.substring(int,int)", "string.substring(int,int)"], "useStart": [710, 892, 1004, 1260], "useEnd": [743, 915, 1037, 1293], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/html/ext/src/xalan-j_2_7_1/src/org/apache/xml/utils/URI.java", "rawCode": "  /**\n   * Initialize the authority (userinfo, host and port) for this URI from a URI string spec.\n   *\n   * @param p_uriSpec the URI specification (cannot be null)\n   * @throws MalformedURIException if p_uriSpec violates syntax rules\n   */\n  private void initializeAuthority(String p_uriSpec) throws MalformedURIException {\n\n    int index = 0;\n    int start = 0;\n    int end = p_uriSpec.length();\n    char testChar = '\\0';\n    String userinfo = null;\n\n    // userinfo is everything up @\n    if (p_uriSpec.indexOf('@', start) != -1) {\n      while (index < end) {\n        testChar = p_uriSpec.charAt(index);\n\n        if (testChar == '@') {\n          break;\n        }\n\n        index++;\n      }\n\n      userinfo = p_uriSpec.substring(start, index);\n\n      index++;\n    }\n\n    // host is everything up to ':'\n    String host = null;\n\n    start = index;\n\n    while (index < end) {\n      testChar = p_uriSpec.charAt(index);\n\n      if (testChar == ':') {\n        break;\n      }\n\n      index++;\n    }\n\n    host = p_uriSpec.substring(start, index);\n\n    int port = -1;\n\n    if (host.length() > 0) {\n\n      // port\n      if (testChar == ':') {\n        index++;\n\n        start = index;\n\n        while (index < end) {\n          index++;\n        }\n\n        String portStr = p_uriSpec.substring(start, index);\n\n        if (portStr.length() > 0) {\n          for (int i = 0; i < portStr.length(); i++) {\n            if (!isDigit(portStr.charAt(i))) {\n              throw new MalformedURIException(\n                  portStr + \" is invalid. Port should only contain digits!\");\n            }\n          }\n\n          try {\n            port = Integer.parseInt(portStr);\n          } catch (NumberFormatException nfe) {\n\n            // can't happen\n          }\n        }\n      }\n    }\n\n    setHost(host);\n    setPort(port);\n    setUserinfo(userinfo);\n  }\n"}, {"dataset": "charAt", "exampleID": 8263, "initialization": ["String string = String.trim()"], "initializationStart": [474], "initializationEnd": [485], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.trim()", "string.length()"], "configurationStart": [474, 504], "configurationEnd": [485, 517], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 635, "focalAPIEnd": 653, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["isDigit(value)", "string.substring(int,int)"], "useStart": [1259, 1575], "useEnd": [1288, 1603], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/formicary/fpml-toolkit-java/tree/master/src-core/com/handcoded/finance/Time.java", "rawCode": "  /**\n   * Parses a character string in the ISO time format and uses the extracted values to construct a\n   * <CODE>Time</CODE> instance.\n   *\n   * @param text The character string to be parsed.\n   * @return A <CODE>Time</CODE> instance constructed from the parsed data.\n   * @throws IllegalArgumentException If the character string is not in the correct format.\n   * @since TFP 1.0\n   */\n  public static Time parse(String text) {\n    char ch;\n\n    if (text != null) text = text.trim();\n\n    int limit = text.length();\n    int index = 0;\n\n    while (true) {\n      // Extract time components\n      if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n      int hours = (ch - '0') * 10;\n      ++index;\n      if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n      hours += ch - '0';\n      ++index;\n\n      if ((index >= limit) || (text.charAt(index++) != ':')) break;\n\n      if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n      int minutes = (ch - '0') * 10;\n      ++index;\n      if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n      minutes += ch - '0';\n      ++index;\n\n      if ((index >= limit) || (text.charAt(index++) != ':')) break;\n\n      int start = index;\n      if ((index >= limit) || !isDigit(text.charAt(index++))) break;\n      if ((index >= limit) || !isDigit(text.charAt(index++))) break;\n\n      if ((index < limit) && (text.charAt(index) == '.')) {\n        do {\n          ++index;\n        } while ((index < limit) && isDigit(text.charAt(index)));\n      }\n      BigDecimal seconds = new BigDecimal(text.substring(start, index));\n\n      // Detect UTC time zone\n      if ((index < limit) && (text.charAt(index) == 'Z')) {\n        return (new Time(hours, minutes, seconds, true));\n      }\n\n      // Detect time offsets\n      if ((index < limit) && (text.charAt(index) == '+')) {\n        ++index;\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        int offset = (ch - '0') * 600;\n        ++index;\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        offset += (ch - '0') * 60;\n        ++index;\n\n        if ((index >= limit) || (text.charAt(index++) != ':')) break;\n\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        offset += (ch - '0') * 10;\n        ++index;\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        offset += (ch - '0');\n        ++index;\n\n        return (new Time(hours, minutes, seconds, offset));\n      }\n\n      if ((index < limit) && (text.charAt(index) == '-')) {\n        ++index;\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        int offset = (ch - '0') * 600;\n        ++index;\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        offset += (ch - '0') * 60;\n        ++index;\n\n        if ((index >= limit) || (text.charAt(index++) != ':')) break;\n\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        offset += (ch - '0') * 10;\n        ++index;\n        if ((index >= limit) || !isDigit(ch = text.charAt(index))) break;\n        offset += (ch - '0');\n        ++index;\n\n        return (new Time(hours, minutes, seconds, -offset));\n      }\n\n      return (new Time(hours, minutes, seconds, false));\n    }\n\n    throw new IllegalArgumentException(\"Value is not in ISO time format\");\n  }\n"}, {"dataset": "charAt", "exampleID": 8264, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 385, "tryExpressionEnd": 389, "tryBlockStart": 385, "tryBlockEnd": 782, "catchExpressionStart": 692, "catchExpressionEnd": 712, "catchBlockStart": 692, "catchBlockEnd": 782, "exceptionHandlingCallStart": [720], "exceptionHandlingCallEnd": [758], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null) && index<string.length()", "guardType": "IF {", "guardExpressionStart": 351, "guardExpressionEnd": 369, "guardBlockStart": 351, "guardBlockEnd": 380, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 504, "focalAPIEnd": 519, "followUpCheck": "value == '\\''", "checkType": "IF", "followUpCheckExpressionStart": 529, "followUpCheckExpressionEnd": 543, "followUpCheckBlockStart": 529, "followUpCheckBlockEnd": 625, "use": ["StringBuilder.append(value)"], "useStart": [601], "useEnd": [614], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc08/kernel-util/src/main/java/org/sakaiproject/util/Validator.java", "rawCode": "  /**\n   * Return a string based on value that is safe to place into a sql statement: sql statements use\n   * the single quote, and this must be doubled as an escape.\n   *\n   * @param value The string to escape.\n   * @return value escaped.\n   * @deprecated use commons-lang StringEscapeUtils\n   */\n  public static String escapeSql(String value) {\n    if (value == null) return \"\";\n    try {\n      StringBuilder buf = new StringBuilder();\n      for (int i = 0; i < value.length(); i++) {\n        char c = value.charAt(i);\n        if (c == '\\'') {\n          buf.append(\"''\");\n        } else {\n          buf.append(c);\n        }\n      }\n\n      String rv = buf.toString();\n      return rv;\n    } catch (Exception e) {\n      M_log.warn(\"Validator.escapeSql: \", e);\n      return \"\";\n    }\n  } // escapeSql\n"}, {"dataset": "charAt", "exampleID": 8265, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(NULL_VALUE.equals(string.toLowerCase(),))", "guardType": "IF {", "guardExpressionStart": 112, "guardExpressionEnd": 155, "guardBlockStart": 112, "guardBlockEnd": 401, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 875, "focalAPIEnd": 890, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Character(value)", "parseDouble(string)", "parseFloat(string)", "parseLong(string)", "parseShort(string)"], "useStart": [861, 982, 1096, 1205, 1315], "useEnd": [891, 1007, 1119, 1226, 1338], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ludovicc/testng-debian/tree/master/src/main/org/testng/internal/Parameters.java", "rawCode": "  public static Object convertType(Class type, String value, String paramName) {\n    Object result = null;\n\n    if (NULL_VALUE.equals(value.toLowerCase())) {\n      if (type.isPrimitive()) {\n        Utils.log(\n            \"Parameters\",\n            2,\n            \"Attempt to pass null value to primitive type parameter '\" + paramName + \"'\");\n      }\n\n      return null; // null value must be used\n    }\n\n    if (type == String.class) {\n      result = value;\n    } else if (type == int.class || type == Integer.class) {\n      result = new Integer(Integer.parseInt(value));\n    } else if (type == boolean.class || type == Boolean.class) {\n      result = Boolean.valueOf(value);\n    } else if (type == byte.class || type == Byte.class) {\n      result = new Byte(Byte.parseByte(value));\n    } else if (type == char.class || type == Character.class) {\n      result = new Character(value.charAt(0));\n    } else if (type == double.class || type == Double.class) {\n      result = new Double(Double.parseDouble(value));\n    } else if (type == float.class || type == Float.class) {\n      result = new Float(Float.parseFloat(value));\n    } else if (type == long.class || type == Long.class) {\n      result = new Long(Long.parseLong(value));\n    } else if (type == short.class || type == Short.class) {\n      result = new Short(Short.parseShort(value));\n    } else {\n      assert false : \"Unsupported type parameter : \" + type;\n    }\n\n    return result;\n  }\n"}, {"dataset": "charAt", "exampleID": 8266, "initialization": ["String string = Book.getTitle()", "String string = String.trim()"], "initializationStart": [114, 193], "initializationEnd": [129, 205], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.trim()"], "configurationStart": [193], "configurationEnd": [205], "guardCondition": "!(\"\".equals(string,)) && index<string.length() &&  !(string==null)", "guardType": "IF {", "guardExpressionStart": 135, "guardExpressionEnd": 153, "guardBlockStart": 135, "guardBlockEnd": 180, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 327, "focalAPIEnd": 342, "followUpCheck": "Character.isLetterOrDigit(value)", "checkType": "IF", "followUpCheckExpressionStart": 350, "followUpCheckExpressionEnd": 388, "followUpCheckBlockStart": 350, "followUpCheckBlockEnd": 460, "use": ["toUpperCase(value)", "string.charAt(int)"], "useStart": [421, 515], "useEnd": [450, 530], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victoryckl/android-demos/tree/master/TextReader/TextReader/src/org/geometerplus/fbreader/library/TitleTree.java", "rawCode": "  static String firstTitleLetter(Book book) {\n    if (book == null) {\n      return null;\n    }\n    String title = book.getTitle();\n    if (title == null) {\n      return null;\n    }\n    title = title.trim();\n    if (\"\".equals(title)) {\n      return null;\n    }\n    for (int i = 0; i < title.length(); ++i) {\n      char letter = title.charAt(i);\n      if (Character.isLetterOrDigit(letter)) {\n        return String.valueOf(Character.toUpperCase(letter));\n      }\n    }\n    return String.valueOf(Character.toUpperCase(title.charAt(0)));\n  }\n"}, {"dataset": "charAt", "exampleID": 8267, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 274, "focalAPIEnd": 290, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/json/src/main/java/org/json/JSONTokener.java", "rawCode": "  /**\n   * Returns the next available character, or the null character '\\0' if all input has been\n   * exhausted. The return value of this method is ambiguous for JSON strings that contain the\n   * character '\\0'.\n   */\n  public char next() {\n    return pos < in.length() ? in.charAt(pos++) : '\\0';\n  }\n"}, {"dataset": "charAt", "exampleID": 8268, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 83, "focalAPIEnd": 109, "followUpCheck": "value >= 0x80", "checkType": "IF", "followUpCheckExpressionStart": 117, "followUpCheckExpressionEnd": 132, "followUpCheckBlockStart": 117, "followUpCheckBlockEnd": 617, "use": ["string.charAt(int)"], "useStart": [675], "useEnd": [701], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jboss/xerces/tree/master/src/org/apache/xerces/impl/xpath/XPath.java", "rawCode": "    int scanNCName(String data, int endOffset, int currentOffset) {\n      int ch = data.charAt(currentOffset);\n      if (ch >= 0x80) {\n        if (!XMLChar.isNameStart(ch))\n        /**\n         * * // REVISIT: Make sure this is a negation. *** if\n         * ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_InitialNameCharFlag)\n         * == 0) /**\n         */\n        {\n          return currentOffset;\n        }\n      } else {\n        byte chartype = fASCIICharMap[ch];\n        if (chartype != CHARTYPE_LETTER && chartype != CHARTYPE_UNDERSCORE) {\n          return currentOffset;\n        }\n      }\n      while (++currentOffset < endOffset) {\n        ch = data.charAt(currentOffset);\n        if (ch >= 0x80) {\n          if (!XMLChar.isName(ch))\n          /**\n           * * // REVISIT: Make sure this is a negation. *** if\n           * ((XMLCharacterProperties.fgCharFlags[ch] & XMLCharacterProperties.E_NameCharFlag) == 0)\n           * /**\n           */\n          {\n            break;\n          }\n        } else {\n          byte chartype = fASCIICharMap[ch];\n          if (chartype != CHARTYPE_LETTER\n              && chartype != CHARTYPE_DIGIT\n              && chartype != CHARTYPE_PERIOD\n              && chartype != CHARTYPE_MINUS\n              && chartype != CHARTYPE_UNDERSCORE) {\n            break;\n          }\n        }\n      }\n      return currentOffset;\n    }\n"}, {"dataset": "charAt", "exampleID": 8269, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length() && !(string.indexOf(\"L\",)!=-1)", "guardType": "IF {", "guardExpressionStart": 61, "guardExpressionEnd": 88, "guardBlockStart": 61, "guardBlockEnd": 164, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 333, "focalAPIEnd": 346, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dgarth/foll_inf_uni-goettingen_ws1213/tree/master/MoteApp/MoteConsole/Pack.java", "rawCode": "  public static long[] unpack(short[] buf, String fmt) {\n    if (fmt.indexOf(\"L\") != -1) {\n      System.err.println(\"L is not supported!\");\n      return null;\n    }\n\n    long[] vals = new long[fmt.replaceAll(\"[^bBhHiIl]\", \"\").length()];\n\n    for (int i = 0, ibuf = 0, ivals = 0; i < fmt.length(); i++) {\n      int sz = 0;\n\n      if (fmt.charAt(i) == '_') {\n        ibuf += 1;\n        continue;\n      }\n\n      switch (fmt.charAt(i)) {\n        case 'b':\n          sz = 1;\n          vals[ivals] = ((byte) bufferGet(buf, ibuf, sz));\n          break;\n        case 'B':\n          sz = 1;\n          vals[ivals] = bufferGet(buf, ibuf, sz);\n          break;\n\n        case 'h':\n          sz = 2;\n          vals[ivals] = ((short) bufferGet(buf, ibuf, sz));\n          break;\n        case 'H':\n          sz = 2;\n          vals[ivals] = bufferGet(buf, ibuf, sz);\n          break;\n\n        case 'i':\n          sz = 4;\n          vals[ivals] = ((int) bufferGet(buf, ibuf, sz));\n          break;\n        case 'I':\n          sz = 4;\n          vals[ivals] = bufferGet(buf, ibuf, sz);\n          break;\n\n        case 'L':\n          sz = 8;\n          vals[ivals] = bufferGet(buf, ibuf, sz);\n          break;\n      }\n\n      ibuf += sz;\n      ivals += 1;\n    }\n\n    return vals;\n  }\n"}, {"dataset": "charAt", "exampleID": 8270, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "i<string.length()+3/4 &&  !(string.length()%4!=0)", "guardType": "IF {", "guardExpressionStart": 255, "guardExpressionEnd": 281, "guardBlockStart": 255, "guardBlockEnd": 308, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 606, "focalAPIEnd": 627, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.indexOf(value)"], "useStart": [591], "useEnd": [628], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-1-2-2/org/xbill/DNS/utils/base64.java", "rawCode": "  /**\n   * Convert a base64-encoded String to binary data\n   *\n   * @param b A String containing the encoded data\n   * @return An array containing the binary data, or null if the string is invalid\n   */\n  public static byte[] fromString(String str) {\n    if (str.length() % 4 != 0) {\n      return null;\n    }\n    ByteArrayOutputStream bs = new ByteArrayOutputStream();\n    DataOutputStream ds = new DataOutputStream(bs);\n\n    for (int i = 0; i < (str.length() + 3) / 4; i++) {\n      short[] s = new short[4];\n      short[] t = new short[3];\n\n      for (int j = 0; j < 4; j++) s[j] = (short) Base64.indexOf(str.charAt(i * 4 + j));\n\n      t[0] = (short) ((s[0] << 2) + (s[1] >> 4));\n      if (s[2] == 64) {\n        t[1] = t[2] = (short) (-1);\n        if ((s[1] & 0xF) != 0) return null;\n      } else if (s[3] == 64) {\n        t[1] = (short) (((s[1] << 4) + (s[2] >> 2)) & 0xFF);\n        t[2] = (short) (-1);\n        if ((s[2] & 0x3) != 0) return null;\n      } else {\n        t[1] = (short) (((s[1] << 4) + (s[2] >> 2)) & 0xFF);\n        t[2] = (short) (((s[2] << 6) + s[3]) & 0xFF);\n      }\n\n      try {\n        for (int j = 0; j < 3; j++) if (t[j] >= 0) ds.writeByte(t[j]);\n      } catch (IOException e) {\n      }\n    }\n    return bs.toByteArray();\n  }\n"}, {"dataset": "charAt", "exampleID": 8271, "initialization": ["String string = JMethod.getName()"], "initializationStart": [276], "initializationEnd": [292], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 363, "focalAPIEnd": 385, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.toLowerCase(value)"], "useStart": [341], "useEnd": [386], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/crux-framework/tree/master/branches/crux/3.3.0-GWT-2.2/Crux/src/br/com/sysmap/crux/core/rebind/context/ContextProxyCreator.java", "rawCode": "  /**\n   * Generates the method for context reading.\n   *\n   * @throws CruxGeneratorException\n   */\n  protected void generateProxyGetMethod(SourceWriter w, JMethod method, int propPrefixLength)\n      throws CruxGeneratorException {\n    w.println();\n\n    String propertyName = method.getName().substring(propPrefixLength);\n    propertyName = Character.toLowerCase(propertyName.charAt(0)) + propertyName.substring(1);\n\n    JType returnType = method.getReturnType().getErasedType();\n    NameFactory nameFactory = new NameFactory();\n    generateProxyMethodSignature(w, nameFactory, method);\n    w.println(\"{\");\n    w.indent();\n\n    w.println(\"try {\");\n    w.indent();\n\n    String retName = nameFactory.createName(\"ret\");\n    w.println(\n        \"String \"\n            + retName\n            + \"=\"\n            + ContextManager.class.getName()\n            + \".getContextHandler().read(\\\"\"\n            + propertyName\n            + \"\\\");\");\n    w.println(\"if (!\" + StringUtils.class.getCanonicalName() + \".isEmpty(\" + retName + \")){\");\n    w.indent();\n    w.print(\"return (\" + returnType.getQualifiedSourceName() + \") \");\n    w.println(\n        \"CrossDocumentReader.\"\n            + getReaderFor(returnType).name()\n            + \".read(createStreamReader(\"\n            + retName\n            + \"));\");\n    ;\n    w.outdent();\n    w.println(\"}\");\n    w.println(\"else{\");\n    w.indent();\n    w.println(\"return null;\");\n    w.outdent();\n    w.println(\"}\");\n\n    w.outdent();\n    generateSerializationCatchBlock(w, nameFactory);\n\n    w.outdent();\n    w.println(\"}\");\n  }\n"}, {"dataset": "charAt", "exampleID": 8272, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 133, "focalAPIEnd": 154, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.substring(int,int)"], "useStart": [333], "useEnd": [374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/earl/rhino-mirror/tree/master/src/org/mozilla/javascript/Decompiler.java", "rawCode": "  private static int printSourceString(\n      String source, int offset, boolean asQuotedString, StringBuffer sb) {\n    int length = source.charAt(offset);\n    ++offset;\n    if ((0x8000 & length) != 0) {\n      length = ((0x7FFF & length) << 16) | source.charAt(offset);\n      ++offset;\n    }\n    if (sb != null) {\n      String str = source.substring(offset, offset + length);\n      if (!asQuotedString) {\n        sb.append(str);\n      } else {\n        sb.append('\"');\n        sb.append(ScriptRuntime.escapeString(str));\n        sb.append('\"');\n      }\n    }\n    return offset + length;\n  }\n"}, {"dataset": "charAt", "exampleID": 8273, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<length", "guardType": "LOOP {", "guardExpressionStart": 324, "guardExpressionEnd": 356, "guardBlockStart": 324, "guardBlockEnd": 644, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 374, "focalAPIEnd": 388, "followUpCheck": "Character.isLetterOrDigit(value) || value == '.' || value == '_'", "checkType": "IF", "followUpCheckExpressionStart": 396, "followUpCheckExpressionEnd": 515, "followUpCheckBlockStart": 396, "followUpCheckBlockEnd": 638, "use": ["StringBuilder.append(value)"], "useStart": [546], "useEnd": [558], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/concord-consortium/geogebra/tree/master/geogebra/geogebra/util/Util.java", "rawCode": "  /**\n   * Removes all characters that are neither letters nor digits from the filename and changes the\n   * given file accordingly.\n   *\n   * @param file\n   */\n  public static String keepOnlyLettersAndDigits(String name) {\n    int length = name != null ? name.length() : 0;\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < length; i++) {\n      char c = name.charAt(i);\n      if (Character.isLetterOrDigit(c)\n          || c == '.'\n          || // Michael Borcherds 2007-11-23\n          c == '_') // underscore\n      {\n        sb.append(c);\n      } else {\n        sb.append('_'); // Michael Borcherds 2007-11-23\n      }\n    }\n\n    if (sb.length() == 0) {\n      sb.append(\"geogebra\");\n    }\n\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8274, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 1134, "focalAPIEnd": 1148, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/cadsr-sentinel/tree/master/software/src/java/gov/nih/nci/cadsr/sentinel/audits/caDSRConceptCleanupEVS.java", "rawCode": "  private String formatCeanupMsg(\n      ConceptItem rec_, ConceptItem evsConcept, ConceptItem updatedrec, String msg_) {\n    return rec_._preferredName\n        + AuditReport._ColSeparator\n        + \"Workflow Status: \"\n        + rec_._workflow_status\n        + \"<br>Long Name: \"\n        + rec_._longName\n        + \"<br>Definition Source: \"\n        + rec_._definitionSource\n        + \"<br>Preferred Definition: \"\n        + rec_._preferredDefinition\n        + AuditReport._ColSeparator\n        + \"Retirement Status: \"\n        + evsConcept._workflow_status\n        + \"<br>Preferred Name: \"\n        + evsConcept._longName\n        + \"<br>Definition Source: \"\n        + evsConcept._definitionSource\n        + \"<br>EVS Definition: \"\n        + evsConcept._preferredDefinition\n        + AuditReport._ColSeparator\n        + \"Workflow Status: \"\n        + updatedrec._workflow_status\n        + \"<br>Long Name: \"\n        + updatedrec._longName\n        + \"<br>Definition Source: \"\n        + updatedrec._definitionSource\n        + \"<br>Preferred Definition: \"\n        + updatedrec._preferredDefinition\n        + AuditReport._ColSeparator\n        + ((msg_.charAt(0) == '\\n') ? msg_.substring(1) : msg_);\n  }\n"}, {"dataset": "charAt", "exampleID": 8275, "initialization": ["String string = toString(*)"], "initializationStart": [261], "initializationEnd": [292], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [308], "configurationEnd": [318], "guardCondition": "!(index==len)", "guardType": "IF {", "guardExpressionStart": 413, "guardExpressionEnd": 430, "guardBlockStart": 413, "guardBlockEnd": 477, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 488, "focalAPIEnd": 503, "followUpCheck": "!ScriptRuntime.isStrWhiteSpaceChar(value)", "checkType": "IF", "followUpCheckExpressionStart": 511, "followUpCheckExpressionEnd": 553, "followUpCheckBlockStart": 511, "followUpCheckBlockEnd": 578, "use": ["string.charAt(int)", "string.charAt(int)", "string.substring(int,int)", "valueOf(string)"], "useStart": [740, 1291, 2318, 2364], "useEnd": [751, 1302, 2339, 2381], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dound/google-closure-compiler/tree/master/lib/rhino/src/org/mozilla/javascript/NativeGlobal.java", "rawCode": "  /**\n   * The global method parseFloat, as per ECMA-262 15.1.2.3.\n   *\n   * @param args the arguments to parseFloat, ignoring args[>=1]\n   */\n  private Object js_parseFloat(Object[] args) {\n    if (args.length < 1) return ScriptRuntime.NaNobj;\n\n    String s = ScriptRuntime.toString(args[0]);\n    int len = s.length();\n    int start = 0;\n    // Scan forward to skip whitespace\n    char c;\n    for (; ; ) {\n      if (start == len) {\n        return ScriptRuntime.NaNobj;\n      }\n      c = s.charAt(start);\n      if (!ScriptRuntime.isStrWhiteSpaceChar(c)) {\n        break;\n      }\n      ++start;\n    }\n\n    int i = start;\n    if (c == '+' || c == '-') {\n      ++i;\n      if (i == len) {\n        return ScriptRuntime.NaNobj;\n      }\n      c = s.charAt(i);\n    }\n\n    if (c == 'I') {\n      // check for \"Infinity\"\n      if (i + 8 <= len && s.regionMatches(i, \"Infinity\", 0, 8)) {\n        double d;\n        if (s.charAt(start) == '-') {\n          d = Double.NEGATIVE_INFINITY;\n        } else {\n          d = Double.POSITIVE_INFINITY;\n        }\n        return ScriptRuntime.wrapNumber(d);\n      }\n      return ScriptRuntime.NaNobj;\n    }\n\n    // Find the end of the legal bit\n    int decimal = -1;\n    int exponent = -1;\n    boolean exponentValid = false;\n    for (; i < len; i++) {\n      switch (s.charAt(i)) {\n        case '.':\n          if (decimal != -1) // Only allow a single decimal point.\n          break;\n          decimal = i;\n          continue;\n\n        case 'e':\n        case 'E':\n          if (exponent != -1) {\n            break;\n          } else if (i == len - 1) {\n            break;\n          }\n          exponent = i;\n          continue;\n\n        case '+':\n        case '-':\n          // Only allow '+' or '-' after 'e' or 'E'\n          if (exponent != i - 1) {\n            break;\n          } else if (i == len - 1) {\n            --i;\n            break;\n          }\n          continue;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (exponent != -1) {\n            exponentValid = true;\n          }\n          continue;\n\n        default:\n          break;\n      }\n      break;\n    }\n    if (exponent != -1 && !exponentValid) {\n      i = exponent;\n    }\n    s = s.substring(start, i);\n    try {\n      return Double.valueOf(s);\n    } catch (NumberFormatException ex) {\n      return ScriptRuntime.NaNobj;\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8276, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "OutOfMemoryError", "exceptionHandlingCall": ["new String(char[],int,int)"], "tryExpressionStart": 727, "tryExpressionEnd": 731, "tryBlockStart": 727, "tryBlockEnd": 2966, "catchExpressionStart": 3040, "catchExpressionEnd": 3067, "catchBlockStart": 3040, "catchBlockEnd": 3212, "exceptionHandlingCallStart": [3152], "exceptionHandlingCallEnd": [3181], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 1486, "focalAPIEnd": 1509, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.charAt(int)", "string.charAt(int)", "string.charAt(int)", "string.charAt(int)", "string.charAt(int)", "string.charAt(int)", "string.charAt(int)"], "useStart": [1569, 1685, 1766, 1923, 2004, 2777, 2862], "useEnd": [1592, 1708, 1789, 1946, 2027, 2800, 2885], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rawagner/eclipse-swt-recorder/tree/master/org.eclipse.swt.examples/src/org/eclipse/swt/examples/imageanalyzer/ImageAnalyzer.java", "rawCode": "  String dataHexDump(String lineDelimiter) {\n    final int MAX_DUMP = 1024 * 1024;\n    if (image == null) return \"\";\n    boolean truncated = false;\n    char[] dump = null;\n    byte[] alphas = imageData.alphaData;\n    try {\n      int length = imageData.height * (6 + 3 * imageData.bytesPerLine + lineDelimiter.length());\n      if (alphas != null && alphas.length > 0)\n        length +=\n            imageData.height * (6 + 3 * imageData.width + lineDelimiter.length())\n                + 6\n                + lineDelimiter.length();\n      dump = new char[length];\n    } catch (OutOfMemoryError e) {\n      /* Too much data to dump - truncate. */\n      dump = new char[MAX_DUMP];\n      truncated = true;\n    }\n    int index = 0;\n    try {\n      for (int i = 0; i < imageData.data.length; i++) {\n        if (i % imageData.bytesPerLine == 0) {\n          int line = i / imageData.bytesPerLine;\n          dump[index++] = Character.forDigit(line / 1000 % 10, 10);\n          dump[index++] = Character.forDigit(line / 100 % 10, 10);\n          dump[index++] = Character.forDigit(line / 10 % 10, 10);\n          dump[index++] = Character.forDigit(line % 10, 10);\n          dump[index++] = ':';\n          dump[index++] = ' ';\n        }\n        byte b = imageData.data[i];\n        dump[index++] = Character.forDigit((b & 0xF0) >> 4, 16);\n        dump[index++] = Character.forDigit(b & 0x0F, 16);\n        dump[index++] = ' ';\n        if ((i + 1) % imageData.bytesPerLine == 0) {\n          dump[index++] = lineDelimiter.charAt(0);\n          if (lineDelimiter.length() > 1) dump[index++] = lineDelimiter.charAt(1);\n        }\n      }\n      if (alphas != null && alphas.length > 0) {\n        dump[index++] = lineDelimiter.charAt(0);\n        if (lineDelimiter.length() > 1) dump[index++] = lineDelimiter.charAt(1);\n        System.arraycopy(new char[] {'A', 'l', 'p', 'h', 'a', ':'}, 0, dump, index, 6);\n        index += 6;\n        dump[index++] = lineDelimiter.charAt(0);\n        if (lineDelimiter.length() > 1) dump[index++] = lineDelimiter.charAt(1);\n        for (int i = 0; i < alphas.length; i++) {\n          if (i % imageData.width == 0) {\n            int line = i / imageData.width;\n            dump[index++] = Character.forDigit(line / 1000 % 10, 10);\n            dump[index++] = Character.forDigit(line / 100 % 10, 10);\n            dump[index++] = Character.forDigit(line / 10 % 10, 10);\n            dump[index++] = Character.forDigit(line % 10, 10);\n            dump[index++] = ':';\n            dump[index++] = ' ';\n          }\n          byte b = alphas[i];\n          dump[index++] = Character.forDigit((b & 0xF0) >> 4, 16);\n          dump[index++] = Character.forDigit(b & 0x0F, 16);\n          dump[index++] = ' ';\n          if ((i + 1) % imageData.width == 0) {\n            dump[index++] = lineDelimiter.charAt(0);\n            if (lineDelimiter.length() > 1) dump[index++] = lineDelimiter.charAt(1);\n          }\n        }\n      }\n    } catch (IndexOutOfBoundsException e) {\n    }\n    String result = \"\";\n    try {\n      result = new String(dump);\n    } catch (OutOfMemoryError e) {\n      /* Too much data to display in the text widget - truncate. */\n      result = new String(dump, 0, MAX_DUMP);\n      truncated = true;\n    }\n    if (truncated) result += \"\\n ...data dump truncated at \" + MAX_DUMP + \"bytes...\";\n    return result;\n  }\n"}, {"dataset": "charAt", "exampleID": 8277, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["writeException(String,*)"], "tryExpressionStart": 103, "tryExpressionEnd": 107, "tryBlockStart": 103, "tryBlockEnd": 962, "catchExpressionStart": 886, "catchExpressionEnd": 909, "catchBlockStart": 886, "catchBlockEnd": 962, "exceptionHandlingCallStart": [917], "exceptionHandlingCallEnd": [939], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 184, "guardExpressionEnd": 224, "guardBlockStart": 184, "guardBlockEnd": 646, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 244, "focalAPIEnd": 259, "followUpCheck": "value == ','", "checkType": "IF", "followUpCheckExpressionStart": 269, "followUpCheckExpressionEnd": 282, "followUpCheckBlockStart": 269, "followUpCheckBlockEnd": 638, "use": ["string.charAt(int)", "StringBuilder.append(value)", "StringBuilder.append(value)"], "useStart": [451, 545, 613], "useEnd": [468, 559, 627], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/Tema 2/h2/src/test/org/h2/test/db/TestScript.java", "rawCode": "  private int processPrepared(String sql, PreparedStatement prep, String param) throws Exception {\n    try {\n      StringBuilder buff = new StringBuilder();\n      int index = 0;\n      for (int i = 0; i < param.length(); i++) {\n        char c = param.charAt(i);\n        if (c == ',') {\n          setParameter(prep, ++index, buff.toString());\n          buff = new StringBuilder();\n        } else if (c == '\"') {\n          while (true) {\n            c = param.charAt(++i);\n            if (c == '\"') {\n              break;\n            }\n            buff.append(c);\n          }\n        } else if (c > ' ') {\n          buff.append(c);\n        }\n      }\n      if (buff.length() > 0) {\n        setParameter(prep, ++index, buff.toString());\n      }\n      if (prep.execute()) {\n        writeResultSet(sql, prep.getResultSet());\n        return 0;\n      }\n      return prep.getUpdateCount();\n    } catch (SQLException e) {\n      writeException(sql, e);\n      return 0;\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8278, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 442, "focalAPIEnd": 469, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setCharAt(int,value)", "string.charAt(int)", "string.charAt(int)"], "useStart": [420, 502, 568], "useEnd": [470, 535, 594], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CMU-CREATE-Lab/speck-gateway/tree/master/java/lib/log4j-extras/src/main/java/org/apache/log4j/pattern/CachedDateFormat.java", "rawCode": "  /**\n   * Formats a count of milliseconds (0-999) into a numeric representation.\n   *\n   * @param millis Millisecond coun between 0 and 999.\n   * @param buf String buffer, may not be null.\n   * @param offset Starting position in buffer, the length of the buffer must be at least offset +\n   *     3.\n   */\n  private static void millisecondFormat(\n      final int millis, final StringBuffer buf, final int offset) {\n    buf.setCharAt(offset, DIGITS.charAt(millis / 100));\n    buf.setCharAt(offset + 1, DIGITS.charAt((millis / 10) % 10));\n    buf.setCharAt(offset + 2, DIGITS.charAt(millis % 10));\n  }\n"}, {"dataset": "charAt", "exampleID": 8279, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [73], "configurationEnd": [85], "guardCondition": "index<len", "guardType": "LOOP {", "guardExpressionStart": 188, "guardExpressionEnd": 217, "guardBlockStart": 188, "guardBlockEnd": 630, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 235, "focalAPIEnd": 248, "followUpCheck": "value == '\\''", "checkType": "IF", "followUpCheckExpressionStart": 257, "followUpCheckExpressionEnd": 271, "followUpCheckBlockStart": 257, "followUpCheckBlockEnd": 548, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/azusa/dbviewer/tree/master/src/zigen/plugin/db/parser/util/CurrentSql.java", "rawCode": "  private static boolean isIntoQuot(String str, int pos) {\n    int len = str.length();\n\n    boolean intoQuotFlag = false;\n    int startQuot = Integer.MAX_VALUE;\n    int endQuot = -1;\n\n    for (int i = 0; i < len; i++) {\n      char c = str.charAt(i);\n\n      if (c == '\\'') {\n        if (intoQuotFlag && (i + 1) < len && '\\'' == str.charAt(i + 1)) {\n          continue;\n\n        } else {\n          intoQuotFlag ^= true;\n          if (intoQuotFlag) {\n            startQuot = i;\n          } else {\n            endQuot = i;\n          }\n        }\n      }\n\n      if (!intoQuotFlag && startQuot <= pos && pos < endQuot) return true;\n    }\n\n    return false;\n  }\n"}, {"dataset": "charAt", "exampleID": 8280, "initialization": ["String string = read(*,char)"], "initializationStart": [298], "initializationEnd": [328], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 344, "focalAPIEnd": 357, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["errorUnexpectedEntity(*,*,string)"], "useStart": [387], "useEnd": [463], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/software-eng-ua-edu/clones/tree/master/novel/test/JHotDraw7.6/Source/jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java", "rawCode": "  /**\n   * Processes a tag that starts with a bang (&lt;!...&gt;).\n   *\n   * @param allowCDATA true if CDATA sections are allowed at this point\n   * @throws java.lang.Exception if something went wrong\n   */\n  protected void processSpecialTag(boolean allowCDATA) throws Exception {\n    String str = XMLUtil.read(this.reader, '&');\n    char ch = str.charAt(0);\n\n    if (ch == '&') {\n      XMLUtil.errorUnexpectedEntity(reader.getSystemID(), reader.getLineNr(), str);\n    }\n\n    switch (ch) {\n      case '[':\n        if (allowCDATA) {\n          this.processCDATA();\n        } else {\n          XMLUtil.errorUnexpectedCDATA(reader.getSystemID(), reader.getLineNr());\n        }\n\n        return;\n\n      case 'D':\n        this.processDocType();\n        return;\n\n      case '-':\n        XMLUtil.skipComment(this.reader);\n        return;\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8281, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 90, "focalAPIEnd": 109, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jfinkels/tuxguitar/tree/master/src/main/java/org/herac/tuxguitar/gui/tools/browser/ftp/TGBrowserElementImpl.java", "rawCode": "  public boolean isSymLink() {\n    return (this.info != null && this.info.length() > 0 && this.info.charAt(0) == 'l');\n  }\n"}, {"dataset": "charAt", "exampleID": 8282, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 143, "guardExpressionEnd": 179, "guardBlockStart": 143, "guardBlockEnd": 407, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 202, "focalAPIEnd": 213, "followUpCheck": "letters.containsKey(value)", "checkType": "IF", "followUpCheckExpressionStart": 221, "followUpCheckExpressionEnd": 253, "followUpCheckBlockStart": 221, "followUpCheckBlockEnd": 401, "use": ["HashMap<Character, Integer>.get(value)", "HashMap<Character, Integer>.put(value,int)", "HashMap<Character, Integer>.put(value,int)"], "useStart": [274, 321, 370], "useEnd": [293, 345, 392], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mcdickenson/data-algs-java/tree/master/Assignments/2/compsci201_Jotto/src/JottoModel.java", "rawCode": "  public HashMap<Character, Integer> countLetters(String a) {\n    HashMap<Character, Integer> letters = new HashMap<Character, Integer>();\n    for (int i = 0; i < a.length(); i++) {\n      char letter = a.charAt(i);\n      if (letters.containsKey(letter)) {\n        int tmp = letters.get(letter);\n        tmp += 1;\n        letters.put(letter, tmp);\n      } else {\n        letters.put(letter, 1);\n      }\n    }\n    return letters;\n  }\n"}, {"dataset": "charAt", "exampleID": 8283, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [449], "configurationEnd": [464], "guardCondition": "index<len && !(string==null||string.length()==0)", "guardType": "IF {", "guardExpressionStart": 345, "guardExpressionEnd": 388, "guardBlockStart": 345, "guardBlockEnd": 417, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 585, "focalAPIEnd": 601, "followUpCheck": "value < ' '", "checkType": "IF", "followUpCheckExpressionStart": 1060, "followUpCheckExpressionEnd": 1072, "followUpCheckBlockStart": 1060, "followUpCheckBlockEnd": 1497, "use": ["StringBuilder.append(value)", "toHexString(value)", "StringBuilder.append(value)"], "useStart": [669, 1261, 1472], "useEnd": [694, 1283, 1484], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/stripesframework/tree/master/stripes/src/net/sourceforge/stripes/ajax/JavaScriptBuilder.java", "rawCode": "  /**\n   * Quotes the supplied String and escapes all characters that could be problematic when eval()'ing\n   * the String in JavaScript.\n   *\n   * @param string a String to be escaped and quoted\n   * @return the escaped and quoted String\n   * @since Stripes 1.2 (thanks to Sergey Pariev)\n   */\n  public static String quote(String string) {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n    }\n\n    char c = 0;\n    int len = string.length();\n    StringBuilder sb = new StringBuilder(len + 10);\n\n    sb.append('\"');\n    for (int i = 0; i < len; ++i) {\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\').append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ') {\n            // The following takes lower order chars and creates unicode style\n            // char literals for them (e.g. \\u00F3)\n            sb.append(\"\\\\u\");\n            String hex = Integer.toHexString(c);\n            int pad = 4 - hex.length();\n            for (int j = 0; j < pad; ++j) {\n              sb.append(\"0\");\n            }\n            sb.append(hex);\n          } else {\n            sb.append(c);\n          }\n      }\n    }\n\n    sb.append('\"');\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8284, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 260, "guardExpressionEnd": 298, "guardBlockStart": 260, "guardBlockEnd": 1243, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 315, "focalAPIEnd": 328, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aptana/Pydev/tree/master/plugins/org.python.pydev.jython/src_jython/org/python/parser/ParseException.java", "rawCode": "  /**\n   * Used to convert raw characters to their escaped version when these raw version cannot be used\n   * as part of an ASCII string literal.\n   */\n  protected String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n      switch (str.charAt(i)) {\n        case 0:\n          continue;\n        case '\\b':\n          retval.append(\"\\\\b\");\n          continue;\n        case '\\t':\n          retval.append(\"\\\\t\");\n          continue;\n        case '\\n':\n          retval.append(\"\\\\n\");\n          continue;\n        case '\\f':\n          retval.append(\"\\\\f\");\n          continue;\n        case '\\r':\n          retval.append(\"\\\\r\");\n          continue;\n        case '\\\"':\n          retval.append(\"\\\\\\\"\");\n          continue;\n        case '\\'':\n          retval.append(\"\\\\\\'\");\n          continue;\n        case '\\\\':\n          retval.append(\"\\\\\\\\\");\n          continue;\n        default:\n          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n            String s = \"0000\" + Integer.toString(ch, 16);\n            retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n          } else {\n            retval.append(ch);\n          }\n          continue;\n      }\n    }\n    return retval.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8285, "initialization": ["int index = String.length()"], "initializationStart": [219], "initializationEnd": [233], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [219], "configurationEnd": [233], "guardCondition": "index>=0", "guardType": "LOOP {", "guardExpressionStart": 206, "guardExpressionEnd": 251, "guardBlockStart": 206, "guardBlockEnd": 397, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 281, "focalAPIEnd": 296, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getChild(value)", "string.substring(int)"], "useStart": [267, 372], "useEnd": [297, 390], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/nutch/tree/master/src/java/org/apache/nutch/util/SuffixStringMatcher.java", "rawCode": "  /**\n   * Returns the shortest suffix of <code>input</code> that is matched, or <code>null</code> if no\n   * match exists.\n   */\n  public String shortestMatch(String input) {\n    TrieNode node = root;\n    for (int i = input.length() - 1; i >= 0; i--) {\n      node = node.getChild(input.charAt(i));\n      if (node == null) return null;\n      if (node.isTerminal()) return input.substring(i);\n    }\n    return null;\n  }\n"}, {"dataset": "charAt", "exampleID": 8286, "initialization": ["String string = String.substring(int,int)"], "initializationStart": [340], "initializationEnd": [364], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.substring(int,int)"], "configurationStart": [498], "configurationEnd": [534], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 692, "focalAPIEnd": 722, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ArrayList<Character>.add(value)"], "useStart": [730], "useEnd": [744], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mcdickenson/data-algs-java/tree/master/Assignments/3/compsci201_Markov/src/MapMarkovModel.java", "rawCode": "  /**\n   * Build the map for smart()\n   *\n   * @param k is the length of the n-grams\n   * @return a map of strings to character arrays\n   */\n  public HashMap<String, ArrayList<Character>> buildMap(int k) {\n    HashMap<String, ArrayList<Character>> map = new HashMap<String, ArrayList<Character>>();\n    String wrapAroundString = myString + myString.substring(0, k);\n    ArrayList<Character> list = new ArrayList<Character>();\n\n    for (int i = 0; i < myString.length(); i++) {\n      String kchar = wrapAroundString.substring(i, i + k);\n      if (map.containsKey(kchar)) {\n        list = map.get(kchar);\n      } else {\n        list = new ArrayList<Character>();\n      }\n      Character next = wrapAroundString.charAt(i + k);\n      list.add(next);\n      map.put(kchar, list);\n    }\n\n    return map;\n  }\n"}, {"dataset": "charAt", "exampleID": 8287, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [577], "configurationEnd": [594], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 640, "focalAPIEnd": 664, "followUpCheck": "(value == '\\\\') || (value == '/') || (value == ':')", "checkType": "IF", "followUpCheckExpressionStart": 672, "followUpCheckExpressionEnd": 716, "followUpCheckBlockStart": 672, "followUpCheckBlockEnd": 723, "use": ["StringBuilder.insert(int,value)"], "useStart": [730], "useEnd": [746], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta04/kernel-util/src/main/java/org/sakaiproject/util/Validator.java", "rawCode": "  /**\n   * Isolate and return just the file name part of a full drive and path file name.\n   *\n   * @param fullName The full file name from a local os file system (mac, unix, windoze)\n   * @return Just the name (and extension) of the file, without the drive or path.\n   */\n  public static String getFileName(String fullName) {\n    // examples: windows: c:\\this\\that\\me.doc\n    // unix: /usr/local/dev/test.txt\n    // mac:? one:two:three:four\n    // so... just take the last characters back till we see a \\ or / or :\n    StringBuilder buf = new StringBuilder();\n    int index = fullName.length() - 1;\n    while (index >= 0) {\n      char c = fullName.charAt(index--);\n      if ((c == '\\\\') || (c == '/') || (c == ':')) break;\n      buf.insert(0, c);\n    }\n\n    return buf.toString();\n  } // getFileName\n"}, {"dataset": "charAt", "exampleID": 8288, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null||string.length()==index)", "guardType": "IF {", "guardExpressionStart": 50, "guardExpressionEnd": 83, "guardBlockStart": 50, "guardBlockEnd": 107, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 141, "focalAPIEnd": 152, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.toUpperCase(value)"], "useStart": [119], "useEnd": [153], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/saschaiseli/opentrainingcenter/tree/master/mockito/org/mockito/cglib/core/TypeUtils.java", "rawCode": "  public static String upperFirst(String s) {\n    if (s == null || s.length() == 0) {\n      return s;\n    }\n    return Character.toUpperCase(s.charAt(0)) + s.substring(1);\n  }\n"}, {"dataset": "charAt", "exampleID": 8289, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 280, "guardExpressionEnd": 320, "guardBlockStart": 280, "guardBlockEnd": 475, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 334, "focalAPIEnd": 349, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["StringBuffer.append(value)"], "useStart": [447], "useEnd": [460], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.4.0/samples/samples/shared/Helper.java", "rawCode": "  /**\n   * Removes characters 'x' 'X' '*' from a string\n   *\n   * @param input The initial string\n   * @return The initial string with xX* characters removed\n   */\n  public static String removeMultSigns(String input) {\n    StringBuffer sb = new StringBuffer(64);\n    char ch;\n    for (int i = 0; i < input.length(); i++) {\n      ch = input.charAt(i);\n      if (input.charAt(i) != 'x' && input.charAt(i) != 'X' && input.charAt(i) != '*') {\n        sb.append(ch);\n      }\n    }\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8290, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length() && !(string==null||string.equals(\"\",))", "guardType": "IF {", "guardExpressionStart": 50, "guardExpressionEnd": 86, "guardBlockStart": 50, "guardBlockEnd": 111, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 492, "focalAPIEnd": 506, "followUpCheck": "index < string.length() && ((value >= 65 && value <= 90) || (value >= 97 && value <= 122))", "checkType": "LOOP {", "followUpCheckExpressionStart": 583, "followUpCheckExpressionEnd": 663, "followUpCheckBlockStart": 583, "followUpCheckBlockEnd": 785, "use": ["StringBuffer.append(value)", "string.charAt(int)", "replace(string,String,*)", "StringBuffer.append(string)"], "useStart": [674, 752, 997, 1192], "useEnd": [689, 766, 1074, 1208], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alessandro-aglietti/itis-leonardo-da-vinci/tree/master/swingset3/src/com/sun/swingset3/codeview/CodeStyler.java", "rawCode": "  private String keywordFilter(String line) {\n    if (line == null || line.equals(\"\")) {\n      return \"\";\n    }\n    StringBuffer buf = new StringBuffer();\n    Map<String, String> usedReservedWords =\n        new HashMap<String, String>(); // >= Java2 only (not thread-safe)\n    // Hashtable usedReservedWords = new Hashtable(); // < Java2 (thread-safe)\n    int i = 0;\n    char ch;\n    StringBuffer temp = new StringBuffer();\n    while (i < line.length()) {\n      temp.setLength(0);\n      ch = line.charAt(i);\n      // 65-90, uppercase letters\n      // 97-122, lowercase letters\n      while (i < line.length() && ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))) {\n        temp.append(ch);\n        i++;\n        if (i < line.length()) {\n          ch = line.charAt(i);\n        }\n      }\n      String tempString = temp.toString();\n      if (RESERVED_WORDS.containsKey(tempString) && !usedReservedWords.containsKey(tempString)) {\n        usedReservedWords.put(tempString, tempString);\n        line = replace(line, tempString, (reservedWordStart + tempString + reservedWordEnd));\n        i += (reservedWordStart.length() + reservedWordEnd.length());\n      } else {\n        i++;\n      }\n    }\n    buf.append(line);\n    return buf.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8291, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 63, "focalAPIEnd": 77, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olamedia/jagatoo/tree/master/src/org/jagatoo/loaders/models/tds/TDSFile.java", "rawCode": "  public final boolean hiddenObject(String name) {\n    return (name.charAt(0) == '$');\n  }\n"}, {"dataset": "charAt", "exampleID": 8292, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [603], "configurationEnd": [618], "guardCondition": "index<len && !(string==null||string.length()==0)", "guardType": "IF {", "guardExpressionStart": 459, "guardExpressionEnd": 502, "guardBlockStart": 459, "guardBlockEnd": 531, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 748, "focalAPIEnd": 764, "followUpCheck": "value < ' ' || (value >= '\\u0080' && value < '\\u00a0') || (value >= '\\u2000' && value < '\\u2100')", "checkType": "IF", "followUpCheckExpressionStart": 1363, "followUpCheckExpressionEnd": 1445, "followUpCheckBlockStart": 1363, "followUpCheckBlockEnd": 1621, "use": ["StringBuffer.append(value)", "StringBuffer.append(value)", "toHexString(value)", "StringBuffer.append(value)"], "useStart": [859, 985, 1475, 1596], "useEnd": [871, 997, 1497, 1608], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jogjayr/InTEL-Project/tree/master/AppletLoader/src/org/json/JSONObject.java", "rawCode": "  /**\n   * Produce a string in double quotes with backslash sequences in all the right places. A backslash\n   * will be inserted within </, producing <\\/, allowing JSON text to be delivered in HTML. In JSON\n   * text, a string cannot contain a control character or an unescaped quote or backslash.\n   *\n   * @param string A String\n   * @return A String correctly formatted for insertion in a JSON text.\n   */\n  public static String quote(String string) {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n    }\n\n    char b;\n    char c = 0;\n    String hhhh;\n    int i;\n    int len = string.length();\n    StringBuffer sb = new StringBuffer(len + 4);\n\n    sb.append('\"');\n    for (i = 0; i < len; i += 1) {\n      b = c;\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '/':\n          if (b == '<') {\n            sb.append('\\\\');\n          }\n          sb.append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ' || (c >= '\\u0080' && c < '\\u00a0') || (c >= '\\u2000' && c < '\\u2100')) {\n            hhhh = \"000\" + Integer.toHexString(c);\n            sb.append(\"\\\\u\" + hhhh.substring(hhhh.length() - 4));\n          } else {\n            sb.append(c);\n          }\n      }\n    }\n    sb.append('\"');\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8293, "initialization": ["String string = String.trim()"], "initializationStart": [738], "initializationEnd": [751], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [809], "configurationEnd": [819], "guardCondition": "index<len", "guardType": "LOOP {", "guardExpressionStart": 825, "guardExpressionEnd": 857, "guardBlockStart": 825, "guardBlockEnd": 1158, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 870, "focalAPIEnd": 881, "followUpCheck": "value < ' ' || value == '+' || value == '%' || value == '=' || value == ';'", "checkType": "IF", "followUpCheckExpressionStart": 889, "followUpCheckExpressionEnd": 949, "followUpCheckBlockStart": 889, "followUpCheckBlockEnd": 1152, "use": ["StringBuffer.append(value)"], "useStart": [1131], "useEnd": [1143], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Zeke-Y-Liu/StreetRanger/tree/master/Ranger/weibo4j/src/main/java/weibo4j/org/json/Cookie.java", "rawCode": "  /**\n   * Produce a copy of a string in which the characters '+', '%', '=', ';' and control characters\n   * are replaced with \"%hh\". This is a gentle form of URL encoding, attempting to cause as little\n   * distortion to the string as possible. The characters '=' and ';' are meta characters in\n   * cookies. By convention, they are escaped using the URL-encoding. This is only a convention, not\n   * a standard. Often, cookies are expected to have encoded values. We encode '=' and ';' because\n   * we must. We encode '%' and '+' because they are meta characters in URL encoding.\n   *\n   * @param string The source string.\n   * @return The escaped result.\n   */\n  public static String escape(String string) {\n    char c;\n    String s = string.trim();\n    StringBuffer sb = new StringBuffer();\n    int len = s.length();\n    for (int i = 0; i < len; i += 1) {\n      c = s.charAt(i);\n      if (c < ' ' || c == '+' || c == '%' || c == '=' || c == ';') {\n        sb.append('%');\n        sb.append(Character.forDigit((char) ((c >>> 4) & 0x0f), 16));\n        sb.append(Character.forDigit((char) (c & 0x0f), 16));\n      } else {\n        sb.append(c);\n      }\n    }\n    return sb.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8294, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null) && index<string.length()", "guardType": "IF {", "guardExpressionStart": 52, "guardExpressionEnd": 68, "guardBlockStart": 52, "guardBlockEnd": 274, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 464, "focalAPIEnd": 477, "followUpCheck": "node._char[ni] == value ||  node._ochar[ni] == value", "checkType": "IF", "followUpCheckExpressionStart": 812, "followUpCheckExpressionEnd": 875, "followUpCheckBlockStart": 812, "followUpCheckBlockEnd": 1003, "use": ["new Node(boolean,string,int)"], "useStart": [1432], "useEnd": [1461], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/webmetrics/browsermob-proxy/tree/master/src/main/java/org/browsermob/proxy/jetty/util/StringMap.java", "rawCode": "  public Object put(String key, Object value) {\n    if (key == null) {\n      Object oldValue = _nullValue;\n      _nullValue = value;\n      if (_nullEntry == null) {\n        _nullEntry = new NullEntry();\n        _entrySet.add(_nullEntry);\n      }\n      return oldValue;\n    }\n\n    Node node = _root;\n    int ni = -1;\n    Node prev = null;\n    Node parent = null;\n\n    // look for best match\n    charLoop:\n    for (int i = 0; i < key.length(); i++) {\n      char c = key.charAt(i);\n\n      // Advance node\n      if (ni == -1) {\n        parent = node;\n        prev = null;\n        ni = 0;\n        node = (node._children == null) ? null : node._children[c % _width];\n      }\n\n      // Loop through a node chain at the same level\n      while (node != null) {\n        // If it is a matching node, goto next char\n        if (node._char[ni] == c || _ignoreCase && node._ochar[ni] == c) {\n          prev = null;\n          ni++;\n          if (ni == node._char.length) ni = -1;\n          continue charLoop;\n        }\n\n        // no char match\n        // if the first char,\n        if (ni == 0) {\n          // look along the chain for a char match\n          prev = node;\n          node = node._next;\n        } else {\n          // Split the current node!\n          node.split(this, ni);\n          i--;\n          ni = -1;\n          continue charLoop;\n        }\n      }\n\n      // We have run out of nodes, so as this is a put, make one\n      node = new Node(_ignoreCase, key, i);\n\n      if (prev != null) // add to end of chain\n      prev._next = node;\n      else if (parent != null) // add new child\n      {\n        if (parent._children == null) parent._children = new Node[_width];\n        parent._children[c % _width] = node;\n        int oi = node._ochar[0] % _width;\n        if (node._ochar != null && node._char[0] % _width != oi) {\n          if (parent._children[oi] == null) parent._children[oi] = node;\n          else {\n            Node n = parent._children[oi];\n            while (n._next != null) n = n._next;\n            n._next = node;\n          }\n        }\n      } else // this is the root.\n      _root = node;\n      break;\n    }\n\n    // Do we have a node\n    if (node != null) {\n      // Split it if we are in the middle\n      if (ni > 0) node.split(this, ni);\n\n      Object old = node._value;\n      node._key = key;\n      node._value = value;\n      _entrySet.add(node);\n      return old;\n    }\n    return null;\n  }\n"}, {"dataset": "charAt", "exampleID": 8295, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 1100, "focalAPIEnd": 1124, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setCharNext(value)"], "useStart": [1083], "useEnd": [1125], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/test/java/ucar/nc2/TestWriteMiscProblems.java", "rawCode": "  @Test\n  public void testCharMultidim() throws IOException, InvalidRangeException {\n    /* dimension lengths */\n    final int Time_len = 0;\n    final int DateStrLen_len = 19;\n\n    /* enter define mode */\n    String filename = tempFolder.newFile(\"testCharMultidim.nc\").getAbsolutePath();\n    try (NetcdfFileWriteable ncfile = NetcdfFileWriteable.createNew(filename, true)) {\n      /* define dimensions */\n      Dimension Time_dim = ncfile.addUnlimitedDimension(\"Time\");\n      Dimension DateStrLen_dim = ncfile.addDimension(\"DateStrLen\", DateStrLen_len);\n\n      /* define variables */\n      List<Dimension> Times_dimlist = new ArrayList<Dimension>();\n      Times_dimlist.add(Time_dim);\n      Times_dimlist.add(DateStrLen_dim);\n      ncfile.addVariable(\"Times\", DataType.CHAR, Times_dimlist);\n      ncfile.create();\n\n      /* assign variable data */\n      String contents = \"2005-04-11_12:00:002005-04-11_13:00:00\";\n      ArrayChar data = new ArrayChar(new int[] {2, 19});\n      IndexIterator iter = data.getIndexIterator();\n      int count = 0;\n      while (iter.hasNext()) {\n        iter.setCharNext(contents.charAt(count++));\n      }\n\n      ncfile.write(\"Times\", data);\n    }\n\n    try (NetcdfFile nc = NetcdfFile.open(filename, null)) {\n      Variable v = nc.findVariable(\"Times\");\n      Array dataRead = v.read();\n      assert dataRead instanceof ArrayChar;\n      ArrayChar dataC = (ArrayChar) dataRead;\n\n      assert dataC.getString(0).equals(\"2005-04-11_12:00:00\");\n      assert dataC.getString(1).equals(\"2005-04-11_13:00:00\");\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8296, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [477], "configurationEnd": [496], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 457, "guardExpressionEnd": 502, "guardBlockStart": 457, "guardBlockEnd": 792, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 521, "focalAPIEnd": 541, "followUpCheck": "Character.isJavaIdentifierPart(value) && value != '_'", "checkType": "IF", "followUpCheckExpressionStart": 549, "followUpCheckExpressionEnd": 601, "followUpCheckBlockStart": 549, "followUpCheckBlockEnd": 786, "use": ["StringBuffer.append(value)", "mangleChar(value)"], "useStart": [612, 762], "useEnd": [641, 776], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mdaniel/svn-caucho-com-resin/tree/master/artifacts/netbeans/src/com/caucho/netbeans/util/JspNameUtil.java", "rawCode": "  /**\n   * Converts the given identifier to a legal Java identifier\n   *\n   * @param identifier Identifier to convert\n   * @return Legal Java identifier corresponding to the given identifier\n   */\n  public static final String makeJavaIdentifier(String identifier) {\n    StringBuffer modifiedIdentifier = new StringBuffer(identifier.length());\n    if (!Character.isJavaIdentifierStart(identifier.charAt(0))) {\n      modifiedIdentifier.append('_');\n    }\n    for (int i = 0; i < identifier.length(); i++) {\n      char ch = identifier.charAt(i);\n      if (Character.isJavaIdentifierPart(ch) && ch != '_') {\n        modifiedIdentifier.append(ch);\n      } else if (ch == '.') {\n        modifiedIdentifier.append('_');\n      } else {\n        modifiedIdentifier.append(mangleChar(ch));\n      }\n    }\n    if (isJavaKeyword(modifiedIdentifier.toString())) {\n      modifiedIdentifier.append('_');\n    }\n    return modifiedIdentifier.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8297, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["error(*)"], "tryExpressionStart": 181, "tryExpressionEnd": 185, "tryBlockStart": 181, "tryBlockEnd": 321, "catchExpressionStart": 276, "catchExpressionEnd": 298, "catchBlockStart": 276, "catchBlockEnd": 321, "exceptionHandlingCallStart": [306], "exceptionHandlingCallEnd": [314], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length()", "guardType": "LOOP {", "guardExpressionStart": 193, "guardExpressionEnd": 229, "guardBlockStart": 193, "guardBlockEnd": 269, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 248, "focalAPIEnd": 259, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["write(value)"], "useStart": [240], "useEnd": [260], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pchaigno/Yaka/tree/master/src/compilateur/Writer.java", "rawCode": "  /**\n   * Write a string in the file.\n   *\n   * @param f The file stream.\n   * @param s The string to write.\n   */\n  public static void writeString(OutputStream f, String s) {\n    try {\n      for (int i = 0; i < s.length(); i++) {\n        f.write(s.charAt(i));\n      }\n    } catch (IOException e) {\n      error(e);\n    }\n  }\n"}, {"dataset": "charAt", "exampleID": 8298, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<string.length() && !(string==null)", "guardType": "IF {", "guardExpressionStart": 224, "guardExpressionEnd": 247, "guardBlockStart": 224, "guardBlockEnd": 284, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 351, "focalAPIEnd": 371, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.charAt(int)", "String.append(value)"], "useStart": [1790, 1779], "useEnd": [1810, 1811], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Silverpeas/taglibs/tree/master/src/main/java/com/silverpeas/tags/highlight/HighlightTag.java", "rawCode": "  /**\n   * Transform special chars in its html code\n   *\n   * @param javastring\n   * @return String with code html\n   */\n  public String encodeSpecialChar(String javastring) {\n    StringBuffer res = new StringBuffer();\n\n    if (javastring == null) {\n      return res.toString();\n    }\n    for (int i = 0; i < javastring.length(); i++) {\n      switch (javastring.charAt(i)) {\n        case '':\n          res.append(\"&aacute;\"); // aacute\n          break;\n        case '\\u010C':\n          res.append(\"&#268;\"); // Ccaron\n          break;\n        case '\\u010D':\n          res.append(\"&#269;\"); // ccaron\n          break;\n        case '':\n          res.append(\"&eacute;\"); // eacute\n          break;\n        case '\\u011A':\n          res.append(\"&#282;\"); // Ecaron\n          break;\n        case '\\u011B':\n          res.append(\"&#283;\"); // ecaron\n          break;\n        case '':\n          res.append(\"&iacute;\"); // \n          break;\n        case '\\u0147':\n          res.append(\"&#327;\"); // Ncaron\n          break;\n        case '\\u0148':\n          res.append(\"&#328;\"); // ncaron\n          break;\n        case '\\u0158':\n          res.append(\"&#344;\"); // Rcaron\n          break;\n        case '\\u0159':\n          res.append(\"&#345;\"); // rcaron\n          break;\n        case '\\u0160':\n          res.append(\"&#352;\"); // Scaron\n          break;\n        case '\\u0161':\n          res.append(\"&#353;\"); // scaron\n          break;\n        case '':\n          res.append(\"&uacute;\"); // uacute\n          break;\n        case '\\u016F':\n          res.append(\"&#367;\"); // udegre\n          break;\n        case '\\u017D':\n          res.append(\"&#381;\"); // Zcaron\n          break;\n        case '\\u017E':\n          res.append(\"&#382;\"); // zcaron\n          break;\n        default:\n          res.append(javastring.charAt(i));\n      }\n    }\n    return res.toString();\n  }\n"}, {"dataset": "charAt", "exampleID": 8299, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null&&string.length()>index", "guardType": "IF {", "guardExpressionStart": 70, "guardExpressionEnd": 102, "guardBlockStart": 70, "guardBlockEnd": 309, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 121, "focalAPIEnd": 132, "followUpCheck": "value != lch", "checkType": "IF", "followUpCheckExpressionStart": 184, "followUpCheckExpressionEnd": 198, "followUpCheckBlockStart": 184, "followUpCheckBlockEnd": 303, "use": ["toLowerCase(value)", "string.toCharArray()"], "useStart": [151, 224], "useEnd": [176, 239], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/isr-uci-edu/ArchStudio5/tree/master/org.archstudio.utils.system/src/org/archstudio/sysutils/SystemUtils.java", "rawCode": "  public static @Nullable String uncapFirst(@Nullable String s) {\n    if (s != null && s.length() > 0) {\n      char ch = s.charAt(0);\n      char lch = Character.toLowerCase(ch);\n      if (ch != lch) {\n        char[] chars = s.toCharArray();\n        chars[0] = lch;\n        s = new String(chars);\n      }\n    }\n    return s;\n  }\n"}, {"dataset": "charAt", "exampleID": 8300, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.length()"], "configurationStart": [87], "configurationEnd": [97], "guardCondition": "index<len", "guardType": "LOOP {", "guardExpressionStart": 129, "guardExpressionEnd": 158, "guardBlockStart": 129, "guardBlockEnd": 261, "focalAPI": "value = string.charAt(index)", "focalAPIStart": 177, "focalAPIEnd": 188, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.charAt(int)"], "useStart": [329], "useEnd": [340], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fiji/imagej1/tree/master/ij/io/TiffEncoder.java", "rawCode": "  final void writeChars(OutputStream out, String s) throws IOException {\n    int len = s.length();\n    if (littleEndian) {\n      for (int i = 0; i < len; i++) {\n        int v = s.charAt(i);\n        out.write(v & 255);\n        out.write((v >>> 8) & 255);\n      }\n    } else {\n      for (int i = 0; i < len; i++) {\n        int v = s.charAt(i);\n        out.write((v >>> 8) & 255);\n        out.write(v & 255);\n      }\n    }\n  }\n"}]