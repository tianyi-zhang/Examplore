[{"dataset": "compile", "exampleID": 5901, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 107, "focalAPIEnd": 182, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/elk1n/Biblioteca/tree/master/src/sabga/modelo/Validacion.java", "rawCode": "  public boolean validarCorreoNull(String correoElectronico, int numeroCaracteres) {\n\n    Pattern patron = Pattern.compile(\"[\\\\w-\\\\.]{3,}@([\\\\w-]{2,}\\\\.)*([\\\\w-]{2,}\\\\.)[\\\\w-]{2,4}\");\n    Matcher matcher = patron.matcher(correoElectronico);\n\n    if (!correoElectronico.isEmpty()) {\n      if (correoElectronico.length() > numeroCaracteres) {\n        this.mensajeError = \"Máximo \" + numeroCaracteres + \" caracteres.\";\n        return false;\n      } else if (!matcher.matches()) {\n        this.mensajeError = \"No es un E-mail.\";\n        return false;\n      } else {\n        this.mensajeError = \"\";\n        return true;\n      }\n    } else {\n      this.mensajeError = \"\";\n      return true;\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5902, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 2102, "focalAPIEnd": 2139, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kabir/connectbot/tree/master/src/org/connectbot/TerminalView.java", "rawCode": "    @Override\n    protected Boolean doInBackground(Void... params) {\n      /*\n       * Presumably if the accessibility manager is not enabled, we don't\n       * need to send accessibility events.\n       */\n      final AccessibilityManager accessibility =\n          (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);\n      if (!accessibility.isEnabled()) {\n        return false;\n      }\n\n      /*\n       * Restrict the set of intents to only accessibility services that\n       * have the category FEEDBACK_SPOKEN (aka, screen readers).\n       */\n      final Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);\n      screenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);\n\n      final ContentResolver cr = context.getContentResolver();\n\n      final List<ResolveInfo> screenReaders =\n          context.getPackageManager().queryIntentServices(screenReaderIntent, 0);\n\n      boolean foundScreenReader = false;\n\n      final int N = screenReaders.size();\n      for (int i = 0; i < N; i++) {\n        final ResolveInfo screenReader = screenReaders.get(i);\n\n        /*\n         * All screen readers are expected to implement a content\n         * provider that responds to:\n         * content://<nameofpackage>.providers.StatusProvider\n         */\n        final Cursor cursor =\n            cr.query(\n                Uri.parse(\n                    \"content://\"\n                        + screenReader.serviceInfo.packageName\n                        + \".providers.StatusProvider\"),\n                null,\n                null,\n                null,\n                null);\n        if (cursor != null && cursor.moveToFirst()) {\n          /*\n           * These content providers use a special cursor that only has\n           * one element, an integer that is 1 if the screen reader is\n           * running.\n           */\n          final int status = cursor.getInt(0);\n\n          cursor.close();\n\n          if (status == 1) {\n            foundScreenReader = true;\n            break;\n          }\n        }\n      }\n\n      if (foundScreenReader) {\n        mControlCodes = Pattern.compile(CONTROL_CODE_PATTERN);\n      }\n\n      return foundScreenReader;\n    }\n"}, {"dataset": "compile", "exampleID": 5903, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["Editor.getMessage()", "toString()", "e(String,*)"], "tryExpressionStart": 661, "tryExpressionEnd": 665, "tryBlockStart": 661, "tryBlockEnd": 2000, "catchExpressionStart": 1923, "catchExpressionEnd": 1943, "catchBlockStart": 1923, "catchBlockEnd": 2000, "exceptionHandlingCallStart": [1967, 1967, 1951], "exceptionHandlingCallEnd": [1981, 1992, 1993], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 1393, "focalAPIEnd": 1415, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [1517], "useEnd": [1534], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yukkigogo/cyberhoodwatch/tree/master/src/com/sociam/android/message/MessageUpAsyncTask.java", "rawCode": "  @Override\n  protected Integer doInBackground(String... params) {\n\n    String user_id = params[0];\n    String user_id_code = params[1];\n    String lat = params[2];\n    String lon = params[3];\n    String date_time = params[4];\n    // Log.e(\"sociam\", \"result??\" + date_time);\n    String message = params[5];\n    String tags = params[6];\n\n    HttpClient client = new DefaultHttpClient();\n    HttpPost hpost = new HttpPost(\"http://sociamvm-yi1g09.ecs.soton.ac.uk/messageupandroid.php\");\n\n    ResponseHandler<String> responseHandler = new BasicResponseHandler();\n    MultipartEntity multipartEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n\n    try {\n      multipartEntity.addPart(\"user_id\", new StringBody(user_id));\n      multipartEntity.addPart(\"id_code\", new StringBody(user_id_code));\n      multipartEntity.addPart(\"lat\", new StringBody(lat));\n      multipartEntity.addPart(\"lon\", new StringBody(lon));\n      multipartEntity.addPart(\"date\", new StringBody(date_time));\n      multipartEntity.addPart(\"message\", new StringBody(message));\n      if (tags != \"\") multipartEntity.addPart(\"tags\", new StringBody(tags));\n\n      hpost.setEntity(multipartEntity);\n      String response = client.execute(hpost, responseHandler);\n      Log.v(\"sociam\", \"message response \" + response);\n\n      String[] str = response.split(\"\\n\");\n\n      String match = \"message_id\";\n\n      Pattern p = Pattern.compile(match);\n      for (int i = 0; i < str.length; i++) {\n        // Log.e(\"sociam\",str[i]);\n        Matcher m = p.matcher(str[i]);\n        if (m.find()) {\n          String[] str2 = str[i].split(\",\");\n\n          if (str2[1].equals(\"false\")) {\n            postSuccess = false;\n\n          } else {\n\n            String past_msg = sp.getString(\"message_id\", \"\");\n            Editor e = sp.edit();\n            e.putString(\"message_id\", past_msg + \",\" + str2[1]);\n            e.commit();\n          }\n        }\n      }\n\n    } catch (Exception e) {\n      Log.e(\"sociam\", e.getMessage().toString());\n    }\n\n    return 0;\n  }\n"}, {"dataset": "compile", "exampleID": 5904, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "regex!=null", "guardType": "IF {", "guardExpressionStart": 139, "guardExpressionEnd": 181, "guardBlockStart": 139, "guardBlockEnd": 337, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 202, "focalAPIEnd": 251, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [271], "useEnd": [288], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/EsupPortail/esup-filemanager/tree/master/src/main/java/org/esupportail/portlet/filemanager/services/uri/RegUriManipulateService.java", "rawCode": "  public String manipulate(String uri) {\n    String outUri = \"\";\n    outUri = uri;\n    // we check if the path is a regular expression\n    if (regexp != null && replacement != null) {\n      Pattern p = Pattern.compile(regexp, Pattern.CASE_INSENSITIVE);\n      Matcher m = p.matcher(outUri);\n      outUri = m.replaceAll(replacement);\n    }\n    if (log.isDebugEnabled())\n      log.debug(\"RegUriManipulateService:: input uri :\" + uri + \" -- output uri : \" + outUri);\n\n    return outUri;\n  }\n"}, {"dataset": "compile", "exampleID": 5905, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 319, "focalAPIEnd": 386, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)", "pattern.compile(String)"], "useStart": [530, 757], "useEnd": [573, 793], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/epabst/sonar-plugins/tree/master/dotnet/tools/dotnet-tools-commons/src/main/java/org/sonar/dotnet/tools/commons/visualstudio/ModelFactory.java", "rawCode": "  private static List<String> getBuildConfigurations(String solutionContent) {\n    // A pattern to extract the build configurations from a visual studio solution\n    String confExtractExp =\n        \"(\\tGlobalSection\\\\(SolutionConfigurationPlatforms\\\\).*?^\\tEndGlobalSection$)\";\n    Pattern confExtractPattern =\n        Pattern.compile(confExtractExp, Pattern.MULTILINE + Pattern.DOTALL);\n    List<String> buildConfigurations = new ArrayList<String>();\n    // Extracts all the projects from the solution\n    Matcher blockMatcher = confExtractPattern.matcher(solutionContent);\n    if (blockMatcher.find()) {\n      String buildConfigurationBlock = blockMatcher.group(1);\n      String buildConfExtractExp = \" = (.*)\\\\|\";\n      Pattern buildConfExtractPattern = Pattern.compile(buildConfExtractExp);\n      Matcher buildConfMatcher = buildConfExtractPattern.matcher(buildConfigurationBlock);\n      while (buildConfMatcher.find()) {\n        String buildConfiguration = buildConfMatcher.group(1);\n        buildConfigurations.add(buildConfiguration);\n      }\n    }\n    return buildConfigurations;\n  }\n"}, {"dataset": "compile", "exampleID": 5906, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 135, "focalAPIEnd": 157, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["LRUCache<String, Pattern>.put(String,pattern)"], "useStart": [165], "useEnd": [190], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-7.0.1/libphonenumber/src/com/google/i18n/phonenumbers/RegexCache.java", "rawCode": "  public Pattern getPatternForRegex(String regex) {\n    Pattern pattern = cache.get(regex);\n    if (pattern == null) {\n      pattern = Pattern.compile(regex);\n      cache.put(regex, pattern);\n    }\n    return pattern;\n  }\n"}, {"dataset": "compile", "exampleID": 5907, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 82, "focalAPIEnd": 110, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [128], "useEnd": [147], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/weissjeffm/webui-framework/tree/master/src/com/redhat/qe/auto/selenium/CombinedLocatorTemplate.java", "rawCode": "  protected static String increment(int count, String template) {\n    Pattern p = Pattern.compile(\"\\\\$(\\\\d+)\");\n    Matcher m = p.matcher(template);\n    while (m.find()) {\n      int num = Integer.parseInt(m.group(1));\n      int newNum = num + count;\n      template = template.replaceAll(\"\\\\$\" + num, \"\\\\$\" + newNum);\n      // System.out.println(template);\n    }\n    return template;\n  }\n"}, {"dataset": "compile", "exampleID": 5908, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 839, "focalAPIEnd": 874, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czarneckid/blojsom-sourceforge/tree/master/branches/blojsom-2_07-final/blojsom-2.0/plugins/src/org/blojsom/plugin/highlight/GoogleHighlightPlugin.java", "rawCode": "  /**\n   * Process the blog entries\n   *\n   * @param httpServletRequest Request\n   * @param httpServletResponse Response\n   * @param user {@link BlogUser} instance\n   * @param context Context\n   * @param entries Blog entries retrieved for the particular request\n   * @return Modified set of blog entries\n   * @throws BlojsomPluginException If there is an error processing the blog entries\n   */\n  public BlogEntry[] process(\n      HttpServletRequest httpServletRequest,\n      HttpServletResponse httpServletResponse,\n      BlogUser user,\n      Map context,\n      BlogEntry[] entries)\n      throws BlojsomPluginException {\n    String referer = httpServletRequest.getHeader(HEADER_REFERER);\n\n    if (referer != null && referer.matches(EXPRESSSION_GOOGLE)) {\n      String[] searchwords = extractQueryTokens(referer);\n\n      Pattern hasTags = Pattern.compile(EXPRESSION_HASTAGS);\n\n      for (int x = 0; x < entries.length; x++) {\n        BlogEntry entry = entries[x];\n        Matcher matcher = hasTags.matcher(entry.getDescription());\n        boolean isHtml = matcher.find();\n        for (int y = 0; y < searchwords.length; y++) {\n          String word = searchwords[y];\n          if (!isHtml) {\n            entry.setDescription(\n                entry\n                    .getDescription()\n                    .replaceAll(START_BOUNDRY + word + END_BOUNDRY, HIGHLIGHT_PLAINTEXT));\n          } else {\n            entry.setDescription(\n                entry\n                    .getDescription()\n                    .replaceAll(\n                        EXPRESSION_HTMLPREFIX + START_BOUNDRY + word + END_BOUNDRY,\n                        HIGHLIGHT_HTML));\n          }\n        }\n      }\n    }\n\n    return entries;\n  }\n"}, {"dataset": "compile", "exampleID": 5909, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 188, "focalAPIEnd": 220, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/us8885/pim/src/main/java-se/com/funambol/common/pim/model/converter/VCalendarConverter.java", "rawCode": "  private void replaceInDateTime(\n      com.funambol.common.pim.model.model.Property p, TimeZone timeZoneIn, TimeZone timeZoneOut)\n      throws ConverterException {\n\n    Pattern pattern = Pattern.compile(DATE_TIME_REGEX);\n    Matcher matcher = pattern.matcher(p.getValue());\n    StringBuffer buffer = new StringBuffer();\n    while (matcher.find()) {\n      boolean lookForUTC = (timeZoneIn == null);\n      boolean foundUTC = matcher.group().endsWith(\"Z\");\n      if (lookForUTC == foundUTC) {\n        String replacement;\n        if (lookForUTC && (timeZoneOut != null)) { // UTC -> local\n          replacement = handleConversionToLocalDate(matcher.group(), timeZoneOut);\n\n        } else if (!lookForUTC && (timeZoneOut == null)) { // local -> UTC\n          replacement = handleConversionToUTCDate(matcher.group(), timeZoneIn);\n\n        } else if (!lookForUTC && (timeZoneOut != null)) { // local -> local\n          replacement = handleConversionAcrossTimeZones(matcher.group(), timeZoneIn, timeZoneOut);\n\n        } else { // UTC -> floating\n          replacement = matcher.group().replaceFirst(\"Z\", \"\");\n        }\n\n        matcher.appendReplacement(buffer, replacement);\n      }\n    }\n    matcher.appendTail(buffer);\n    p.setValue(buffer.toString());\n  }\n"}, {"dataset": "compile", "exampleID": 5910, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 439, "focalAPIEnd": 469, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [480], "useEnd": [498], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Jelb/First-Year-Project-Group-5/tree/master/src/addressParser_2/AdresParser.java", "rawCode": "  /**\n   * Is used to search for building letters. If a building letter is found, it will be stored in the\n   * result array and then errased from the INPUT string. <br>\n   * After checking for the building letter the INPUT string is spiltted and each part is placed in\n   * the corresponding array index.\n   */\n  private void buildingLetter() {\n    sub[0] = sub[0].replaceAll(SAL, \"\");\n    sub[0] = sub[0].replaceAll(ETAGE, \"\");\n    p1 = Pattern.compile(\"[a-lA-L]{1}\");\n    m1 = p1.matcher(sub[0]);\n    if (m1.find()) { // CHECK 22\n      result[2] = sub[0].substring(m1.start(), m1.end());\n      sub[0] = sub[0].replaceFirst(result[2], \"\").trim();\n    }\n    sub = sub[0].trim().split(\" \");\n    if (sub.length == 1) { // CHECK 23\n      result[1] = sub[0];\n    } else if (sub.length == 2) { // CHECK 24\n      result[1] = sub[0];\n      result[3] = sub[1];\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5911, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 585, "focalAPIEnd": 629, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/galievruslan/mss-android/tree/master/mss/src/com/mss/application/services/SynchronizationAdapter.java", "rawCode": "  private void PostRoutes(\n      WebServer webServer,\n      OrmliteRouteRepository routeRepo,\n      OrmliteRoutePointRepository routePointRepo)\n      throws Throwable {\n    Iterable<Route> routes = routeRepo.findNotSynchronized();\n    for (Route route : routes) {\n      Iterable<RoutePoint> points = routePointRepo.findByRouteId(route.getId());\n      PostResult result =\n          webServer.post(\n              \"/synchronization/routes.json\",\n              ToPostParams(route, IterableHelpers.toArray(RoutePoint.class, points)));\n      result.getStatusCode();\n\n      Pattern pattern = Pattern.compile(\"\\\"code\\\":100|\\\"code\\\":101\");\n      Matcher matcher = pattern.matcher(result.getContent());\n      if (matcher.find()) {\n        for (RoutePoint routePoint : points) {\n          routePoint.setSynchronized();\n          routePointRepo.save(routePoint);\n        }\n      } else {\n        throw new Exception();\n      }\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5912, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 148, "focalAPIEnd": 254, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [272], "useEnd": [288], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thesmith/eventhorizon/tree/master/src/test/java/thesmith/eventhorizon/service/SocialGraphApiServiceImplTest.java", "rawCode": "  @Test\n  public void shouldReplaceLink() throws Exception {\n    String tweet = \"Panic Status Board: http://bit.ly/aTs0uZ\";\n    Pattern p =\n        Pattern.compile(\n            \"\\\\b(https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]\");\n    Matcher m = p.matcher(tweet);\n    assertTrue(m.find());\n    String url = m.group();\n    int start = tweet.indexOf(url);\n    String replacement = String.format(\"<a href='%s'>%s</a>\", url, url);\n    String beginning = tweet.substring(0, start);\n    String end = tweet.substring(start + url.length());\n    tweet = beginning + replacement + end;\n\n    System.err.println(tweet);\n    assertTrue(tweet.contains(\"<a href\"));\n  }\n"}, {"dataset": "compile", "exampleID": 5913, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 104, "tryExpressionEnd": 108, "tryBlockStart": 104, "tryBlockEnd": 2042, "catchExpressionStart": 1979, "catchExpressionEnd": 2001, "catchBlockStart": 1979, "catchBlockEnd": 2042, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 1529, "focalAPIEnd": 1557, "followUpCheck": "pattern.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 1659, "followUpCheckExpressionEnd": 1675, "followUpCheckBlockStart": 1659, "followUpCheckBlockEnd": 1863, "use": ["pattern.reset()", "pattern.appendReplacement(StringBuffer,*)", "pattern.appendTail(StringBuffer)"], "useStart": [1582, 1801, 1876], "useEnd": [1591, 1848, 1896], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tulskiy/musique/tree/master/musique-core/src/main/java/com/tulskiy/musique/gui/LyricsPanel.java", "rawCode": "    private void searchLyrics(String artist, String title, StringBuilder sb) throws IOException {\n      try {\n        // String search = \"http://lyrics.wikia.com/Special:Search?search=\";\n        // search += URLEncoder.encode(artist, \"utf-8\");\n        // search += \"+\";\n        // search += URLEncoder.encode(title, \"utf-8\");\n        //\n        // URL searchURL = new URL(search);\n        // Scanner scan = new Scanner(searchURL.openStream());\n        // StringBuilder content = new StringBuilder();\n        // while (scan.hasNextLine())\n        // content.append(scan.nextLine());\n        //\n        // Matcher matcher =\n        // Pattern.compile(\"http://lyrics.wikia.com/wiki/[^\\\"]*\").matcher(content);\n        // if (!matcher.find()) {\n        // return;\n        // }\n        String search = \"http://lyrics.wikia.com/\";\n        artist = Util.capitalize(artist, \"_\");\n        title = Util.capitalize(title, \"_\");\n        search += URLEncoder.encode(artist, \"utf-8\");\n        search += \":\";\n        search += URLEncoder.encode(title, \"utf-8\");\n\n        URL url = new URL(search);\n        InputStream is = url.openStream();\n        Scanner fi = new Scanner(is);\n        while (fi.hasNextLine()) {\n          String s = fi.nextLine();\n          if (s.startsWith(\"<div class='lyricbox'\")) {\n            int index = s.lastIndexOf(\"</div>\");\n            if (index > 0 && s.length() > 6) s = s.substring(index);\n            s = s.replaceAll(\"<br />\", \"\\n\");\n            s = s.replaceAll(\"(<!--)|(<.*?>)\", \"\");\n            Matcher m = Pattern.compile(\"&#(\\\\d+);\").matcher(s);\n            m.reset();\n            StringBuffer buffer = new StringBuffer();\n            while (m.find()) {\n              String group = m.group(1);\n              char ch = (char) Integer.valueOf(group).shortValue();\n              m.appendReplacement(buffer, String.valueOf(ch));\n            }\n            m.appendTail(buffer);\n            sb.append(buffer);\n          }\n        }\n        fi.close();\n      } catch (IOException e) {\n        // e.printStackTrace();\n      }\n    }\n"}, {"dataset": "compile", "exampleID": 5914, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 121, "focalAPIEnd": 144, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [162], "useEnd": [178], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/repox2/repoxCore/branches/repoxCore_1.0/src/main/java/pt/utl/ist/marc/util/RemovePontuationFromAuthorityVisitor.java", "rawCode": "  protected static void removePontuation(Subfield sf, String regExp) {\n    String value = sf.getValue();\n    Pattern p = Pattern.compile(regExp);\n    Matcher m = p.matcher(value);\n    String newValue = m.replaceAll(\"\");\n    sf.setValue(newValue);\n  }\n"}, {"dataset": "compile", "exampleID": 5915, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 158, "focalAPIEnd": 182, "followUpCheck": "pattern.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 255, "followUpCheckExpressionEnd": 271, "followUpCheckBlockStart": 255, "followUpCheckBlockEnd": 443, "use": ["pattern.groupCount()"], "useStart": [288], "useEnd": [302], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xiaoxiang88888888/xiaoxiang88888888/tree/master/ticket/src/main/java/com/xiaoxiang/ticket/util/StringUtil.java", "rawCode": "  /**\n   * 正则匹配\n   *\n   * @param s\n   * @param pattern\n   * @return\n   */\n  public static List<String[]> matchAll(String s, String pattern) {\n    Matcher m = Pattern.compile(pattern).matcher(s);\n    List<String[]> result = new ArrayList<String[]>();\n\n    while (m.find()) {\n      int n = m.groupCount();\n      String[] ss = new String[n + 1];\n      for (int i = 0; i <= n; i++) {\n        ss[i] = m.group(i);\n      }\n      result.add(ss);\n    }\n    return result;\n  }\n"}, {"dataset": "compile", "exampleID": 5916, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 586, "focalAPIEnd": 652, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [723], "useEnd": [748], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/moravianlibrary/xcncip2toolkit/tree/master/connectors/voyager/7.2/tags/1.1/src/main/java/org/extensiblecatalog/ncip/v2/voyager/util/RegexUtils.java", "rawCode": "  /**\n   * Given a String, returns a String identical to the provided String except that all regex special\n   * characters will be escaped for use in regular expressions.\n   *\n   * <p>For example, this method will return \"\\(hi\\)\" on input \"(hi)\"\n   *\n   * @param escapeMe The string to escape\n   * @return The escaped string\n   */\n  public String escapeRegexSpecialChars(String escapeMe) {\n    if (log.isDebugEnabled())\n      log.debug(\"Entering escapeRegexSpecialChars for the String: \" + escapeMe);\n\n    // Returns a pattern which matches all special characters\n    Pattern escaper = Pattern.compile(\"([\\\\(\\\\)\\\\.\\\\$\\\\^\\\\{\\\\}\\\\[\\\\]\\\\|\\\\*\\\\+\\\\?\\\\\\\\])\");\n\n    // Escape the special characters and return\n    String result = escaper.matcher(escapeMe).replaceAll(\"\\\\\\\\$1\");\n\n    if (log.isDebugEnabled()) log.debug(\"The escaped String is: \" + result);\n\n    return result;\n  }\n"}, {"dataset": "compile", "exampleID": 5917, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 222, "focalAPIEnd": 266, "followUpCheck": "pattern.matcher(r.toString()).find()", "checkType": "IF", "followUpCheckExpressionStart": 365, "followUpCheckExpressionEnd": 400, "followUpCheckBlockStart": 365, "followUpCheckBlockEnd": 1525, "use": ["pattern.compile(String)"], "useStart": [298], "useEnd": [328], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ru/casanova/tree/master/source/is/ru/ggp/singleagent/heuristic/RelaxationHeuristic.java", "rawCode": "  private void findGoalState(Match match) {\n    this.goalStatePredicates = new LinkedList<String>();\n    Game g = (Game) match.getGame();\n    KIFSeq<RuleGoal> ff = g.getKB().getGameAST().getRawRuleGoal();\n\n    Pattern p = Pattern.compile(\".*goal [a-zA-Z0-9]+ 100.*\");\n    Pattern functionPattern = Pattern.compile(\"^[a-zA-Z]*$\");\n    for (RuleGoal r : ff) {\n\n      if (p.matcher(r.toString()).find()) {\n        System.out.println(\"Generating goal state\");\n\n        String[] split = r.toString().split(\"\\n\");\n\n        for (int i = 1; i < split.length; i++) {\n          String s = split[i].replace(\"\\t\", \"\");\n          if (functionPattern.matcher(s).find()) {\n            String[] pr = g.getKB().get(s).getImplicationHead().toString().split(\"\\n\");\n            for (int j = 1; j < pr.length; j++) {\n              s = pr[j].replace(\"\\t\", \"\");\n              s = s.replace(\"(true \", \"\");\n              s = s.substring(0, s.length() - 1);\n              if (s.endsWith(\"))\")) s = s.substring(0, s.length() - 2);\n              this.goalStatePredicates.add(s);\n            }\n\n          } else {\n            if (s.startsWith(\"(true \")) {\n              s = s.replace(\"(true \", \"\");\n              s = s.substring(0, s.length() - 1);\n\n              if (s.endsWith(\"))\")) s = s.substring(0, s.length() - 1);\n              this.goalStatePredicates.add(s);\n            } else {\n              System.out.println(\"Error, we must consider the predicate \" + s);\n              this.useGoalState = false;\n            }\n          }\n        }\n      }\n    }\n\n    for (String s : this.goalStatePredicates) {\n      // GDL Checks\n      if (s.contains(\"?\")) {\n        System.out.println(s);\n        this.useGoalState = false;\n        System.out.println(\"Found grounded GOAL, canceling heuristics.\");\n        return;\n      }\n      if (s.toString().toLowerCase().contains(\"distinct\")\n          || s.toString().toLowerCase().contains(\"not\")) {\n        System.out.println(\n            \"Found NOT or DISTINCT in GOAL. EVERYONE SCREAM! Canceling the heuristics..\");\n        this.useGoalState = false;\n        return;\n      }\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5918, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 74, "focalAPIEnd": 94, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.split(String)", "pattern.split(String)", "pattern.compile(String)", "pattern.split(String)", "pattern.split(String)"], "useStart": [104, 169, 225, 254, 308], "useEnd": [128, 182, 244, 267, 330], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testSplitCharSequence() {\n    String s[];\n    Pattern pat = Pattern.compile(\"b\");\n    s = pat.split(\"abccbadfebb\");\n    assertEquals(s.length, 3);\n    s = pat.split(\"\");\n    assertEquals(s.length, 1);\n    pat = Pattern.compile(\"\");\n    s = pat.split(\"\");\n    assertEquals(s.length, 1);\n    s = pat.split(\"abccbadfe\");\n    assertEquals(s.length, 10);\n    // bug6544\n    String s1 = \"\";\n    String[] arr = s1.split(\":\");\n    assertEquals(arr.length, 1);\n    // bug6544\n  }\n"}, {"dataset": "compile", "exampleID": 5919, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 173, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [242], "useEnd": [258], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CS340Group/hit/tree/master/src/common/util/QueryParser.java", "rawCode": "  /**\n   * Helper method to parse out the required fields in the query. Expects the query to look like:\n   * obj.attr = value\n   */\n  private void Parse() {\n    Pattern p = Pattern.compile(\"((\\\\w*)\\\\.)?(\\\\w*)\\\\s(.*)\\\\s(.*)\");\n    Matcher m = p.matcher(query);\n    OperatorFactory c = new OperatorFactory();\n    boolean matchFound = m.find();\n    if (matchFound) {\n      objectName = m.group(2);\n      objectAttr = m.group(3);\n      operator = m.group(4);\n      value = m.group(5);\n    } else {\n      // If match isn't found then the query is in the wrong form.\n      assert (matchFound == true);\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5920, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 244, "focalAPIEnd": 277, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Map<String, Pattern>.put(String,pattern)"], "useStart": [285], "useEnd": [325], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wubs/485-Project/tree/master/pa6/hadoop/src/tools/org/apache/hadoop/tools/rumen/HadoopLogsAnalyzer.java", "rawCode": "  private Pattern counterPattern(String counterName) {\n    Pattern result = counterPatterns.get(counterName);\n\n    if (result == null) {\n      String namePatternRegex = \"\\\\[\\\\(\" + counterName + \"\\\\)\\\\([^)]+\\\\)\\\\(([0-9]+)\\\\)\\\\]\";\n      result = Pattern.compile(namePatternRegex);\n      counterPatterns.put(counterName, result);\n    }\n\n    return result;\n  }\n"}, {"dataset": "compile", "exampleID": 5921, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 202, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["DBObject.put(String,pattern)"], "useStart": [286], "useEnd": [316], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lightningdb/chililog-server/tree/master/src/test/java/org/chililog/server/workbench/UsersTest.java", "rawCode": "  @AfterClass\n  public static void classTeardown() {\n    // Clean up old test data if any exists\n    DBCollection coll = _db.getCollection(UserController.MONGODB_COLLECTION_NAME);\n    Pattern pattern = Pattern.compile(\"^UsersTest[\\\\w]*$\");\n    DBObject query = new BasicDBObject();\n    query.put(\"username\", pattern);\n    coll.remove(query);\n\n    WorkbenchService.getInstance().stop();\n  }\n"}, {"dataset": "compile", "exampleID": 5922, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 94, "focalAPIEnd": 118, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gephi/gephi/tree/master/modules/FiltersPlugin/src/main/java/org/gephi/filters/plugin/attribute/AttributeEqualBuilder.java", "rawCode": "    public void setPattern(String pattern) {\n      this.pattern = pattern;\n      this.regex = Pattern.compile(pattern);\n    }\n"}, {"dataset": "compile", "exampleID": 5923, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 321, "focalAPIEnd": 381, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [399], "useEnd": [422], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1_9_1/trunk-archive/src/util/xml/XML.java", "rawCode": "  private static void replaceNodeTokens(Text t, String sBorder, Map mReplace) {\n    // Get value and look for tokens. If there aren't any, bail now.\n    String sValue = t.getData();\n    if (mReplace == null || sValue.indexOf(sBorder) == -1) return;\n\n    StringBuffer sbBefore = new StringBuffer();\n\n    Pattern pTokens = Pattern.compile(sBorder + \"(.*?)\" + sBorder, Pattern.DOTALL);\n    Matcher m = pTokens.matcher(sValue);\n    while (m.find()) {\n      String sKey = m.group(1);\n      if (sKey.equals(\"\")) m.appendReplacement(sbBefore, sBorder);\n      else {\n        Node nMatch = (Node) mReplace.get(sKey);\n        if (nMatch == null) m.appendReplacement(sbBefore, sBorder + sKey + sBorder);\n        else {\n          // OK, found a token. Get everything before it into the buffer...\n          m.appendReplacement(sbBefore, \"\");\n          // ...create a new text node with the 'before' text...\n          Text tBefore = t.getOwnerDocument().createTextNode(sbBefore.toString());\n          t.getParentNode().insertBefore(tBefore, t);\n          sbBefore.setLength(0);\n          // ...add the new node...\n          t.getParentNode().insertBefore(t.getOwnerDocument().importNode(nMatch, true), t);\n        }\n      }\n    }\n    m.appendTail(sbBefore);\n    t.setData(sbBefore.toString());\n  }\n"}, {"dataset": "compile", "exampleID": 5924, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 123, "focalAPIEnd": 156, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["filter(String,pattern)", "pattern.compile(String)"], "useStart": [185, 344], "useEnd": [267, 367], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/morphia/tree/master/morphia/src/test/java/com/google/code/morphia/TestQuery.java", "rawCode": "  @Test\n  public void testRegexInsensitiveQuery() throws Exception {\n    ds.save(new PhotoWithKeywords());\n    Pattern p = Pattern.compile(\"(?i)caLifornia\");\n    assertNotNull(\n        ds.find(PhotoWithKeywords.class).disableValidation().filter(\"keywords.keyword\", p).get());\n    assertNull(ds.find(PhotoWithKeywords.class, \"keywords.keyword\", Pattern.compile(\"blah\")).get());\n  }\n"}, {"dataset": "compile", "exampleID": 5925, "initialization": ["String regex = getRegex()"], "initializationStart": [392], "initializationEnd": [402], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 536, "focalAPIEnd": 563, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ErkiDerLoony/xpeter/tree/master/src/erki/xpeter/parsers/Action.java", "rawCode": "  @Override\n  public void inform(T message) {\n    String text = message.getText();\n    String nick = message.getBotNick();\n\n    if (this.mustAddress && !BotApi.addresses(text, nick)) {\n      Log.debug(getClass().getSimpleName() + \": The bot is not addressed as required.\");\n      return;\n    }\n\n    if (BotApi.addresses(text, nick)) {\n      text = BotApi.trimNick(text, nick);\n    }\n\n    if (getRegex() == null) {\n      Log.warning(getClass().getSimpleName() + \": This action is defective!\");\n      return;\n    }\n\n    Pattern pattern = Pattern.compile(getRegex());\n    Matcher matcher = pattern.matcher(text);\n\n    if (matcher.matches()) {\n      String[] groups = new String[matcher.groupCount()];\n\n      for (int i = 0; i < groups.length; i++) {\n        groups[i] = matcher.group(i + 1);\n      }\n\n      execute(groups, message);\n    } else {\n      Log.debug(getClass().getSimpleName() + \": This action does not match.\");\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5926, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(regex==null||true)", "guardType": "IF {", "guardExpressionStart": 1282, "guardExpressionEnd": 1327, "guardBlockStart": 1282, "guardBlockEnd": 1375, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 1405, "focalAPIEnd": 1431, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.find()", "pattern.appendReplacement(StringBuffer,String)", "pattern.find()", "pattern.appendTail(StringBuffer)"], "useStart": [1518, 2266, 5841, 5873], "useEnd": [1538, 2318, 5861, 5905], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/acceleo/tree/master/plugins/org.eclipse.acceleo.traceability/src/org/eclipse/acceleo/internal/traceability/engine/AcceleoTraceabilityOperationVisitor.java", "rawCode": "  /**\n   * Handles the \"substitute\" and \"replace\" standard operations directly from the traceability\n   * visitor so as to record accurate traceability information.\n   *\n   * @param source String within which we need to replace substrings.\n   * @param substring The substring that is to be substituted.\n   * @param replacement The String which will be inserted in <em>source</em> where\n   *     <em>substring</em> was.\n   * @param substitutionTrace Traceability information of the replacement.\n   * @param substituteAll Indicates wheter we should substitute all occurences of the substring or\n   *     only the first.\n   * @param useInvocationTrace If <code>true</code>, {@link #invocationTraces} will be altered in\n   *     place of the last {@link AcceleoTraceabilityVisitor#recordedTraces}. Should only be <code>\n   *     true</code> when altering indentation.\n   * @return <em>source</em> with the first occurence of <em>substring</em> replaced by\n   *     <em>replacement</em> or <em>source</em> unchanged if it did not contain <em>substring</em>.\n   */\n  public String visitReplaceOperation(\n      String source,\n      String substring,\n      String replacement,\n      ExpressionTrace<C> substitutionTrace,\n      boolean substituteAll,\n      boolean useInvocationTrace) {\n    if (substring == null || replacement == null) {\n      throw new NullPointerException();\n    }\n\n    Matcher sourceMatcher = Pattern.compile(substring).matcher(source);\n    StringBuffer result = new StringBuffer();\n    boolean hasMatch = sourceMatcher.find();\n    // Note : despite its name, this could be negative\n    int addedLength = 0;\n\n    // protected area indentation markers must be ignored\n    final boolean hasProtectedMarker =\n        source.contains(AcceleoEvaluationVisitor.PROTECTED_AREA_MARKER);\n\n    // FIXME This loop does _not_ take group references into account except \"$0 at the start\"\n    final boolean startsWithZeroGroupRef = replacement.startsWith(\"$0\"); // $NON-NLS-1$\n    while (hasMatch) {\n      // If we've already changed the String size, take it into account\n      int startIndex = sourceMatcher.start() + addedLength;\n      int endIndex = sourceMatcher.end() + addedLength;\n      if (startsWithZeroGroupRef) {\n        startIndex = endIndex;\n      }\n      sourceMatcher.appendReplacement(result, replacement);\n      int replacementLength = result.length() - startIndex;\n      // We now remove from the replacementLength the length of the replaced substring\n      replacementLength -= endIndex - startIndex;\n      addedLength += replacementLength;\n\n      // Note that we could be out of a file block's scope\n      if (useInvocationTrace && visitor.getCurrentFiles().size() > 0) {\n        // We need the starting index of these traces\n        int offsetGap = -1;\n        for (ExpressionTrace<C> trace : visitor.getInvocationTraces()) {\n          for (Map.Entry<InputElement, Set<GeneratedText>> entry : trace.getTraces().entrySet()) {\n            for (GeneratedText text : entry.getValue()) {\n              if (offsetGap == -1 || text.getStartOffset() < offsetGap) {\n                offsetGap = text.getStartOffset();\n              }\n            }\n          }\n        }\n        startIndex += offsetGap;\n        endIndex += offsetGap;\n\n        if (hasProtectedMarker) {\n          int additionalGap = computeAdditionalGap(source, sourceMatcher.start());\n          startIndex += additionalGap;\n          endIndex += additionalGap;\n        }\n\n        for (ExpressionTrace<C> trace : visitor.getInvocationTraces()) {\n          changeTraceabilityIndicesOfReplaceOperation(\n              trace, startIndex, endIndex, replacementLength);\n        }\n        GeneratedFile generatedFile = visitor.getCurrentFiles().getLast();\n        final int fileLength = generatedFile.getLength();\n        for (Map.Entry<InputElement, Set<GeneratedText>> entry :\n            substitutionTrace.getTraces().entrySet()) {\n          for (GeneratedText text : entry.getValue()) {\n            // 3.4 compatibility : EcoreUtil.copy() wasn't generic. The cast is necessary\n            @SuppressWarnings(\"cast\")\n            GeneratedText copy = (GeneratedText) EcoreUtil.copy(text);\n            copy.setStartOffset(copy.getStartOffset() + startIndex);\n            copy.setEndOffset(copy.getEndOffset() + startIndex);\n            generatedFile.getGeneratedRegions().add(copy);\n            Iterator<ExpressionTrace<C>> traceIterator = visitor.getInvocationTraces().iterator();\n            boolean inserted = false;\n            while (traceIterator.hasNext() && !inserted) {\n              inserted = insertTextInTrace(traceIterator.next(), copy);\n            }\n          }\n        }\n        generatedFile.setLength(fileLength + replacementLength);\n      } else {\n        AbstractTrace trace = visitor.getLastExpressionTrace();\n        changeTraceabilityIndicesOfReplaceOperation(trace, startIndex, endIndex, replacementLength);\n        for (Map.Entry<InputElement, Set<GeneratedText>> entry :\n            substitutionTrace.getTraces().entrySet()) {\n          Set<GeneratedText> existingTraces = trace.getTraces().get(entry.getKey());\n          if (existingTraces == null) {\n            existingTraces = new CompactLinkedHashSet<GeneratedText>();\n            trace.getTraces().put(entry.getKey(), existingTraces);\n          }\n          for (GeneratedText text : entry.getValue()) {\n            // 3.4 compatibility : EcoreUtil.copy() wasn't generic. The cast is necessary\n            @SuppressWarnings(\"cast\")\n            GeneratedText copy = (GeneratedText) EcoreUtil.copy(text);\n            copy.setStartOffset(copy.getStartOffset() + startIndex);\n            copy.setEndOffset(copy.getEndOffset() + startIndex);\n            existingTraces.add(copy);\n          }\n        }\n      }\n\n      if (!substituteAll) {\n        // Do once\n        break;\n      }\n      hasMatch = sourceMatcher.find();\n    }\n    sourceMatcher.appendTail(result);\n    return result.toString();\n  }\n"}, {"dataset": "compile", "exampleID": 5927, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 128, "focalAPIEnd": 149, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.compile(String,int)", "pattern.compile(String,int)", "pattern.compile(String,int)"], "useStart": [381, 677, 853], "useEnd": [410, 706, 882], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rwl/j2objc/tree/master/jre_emul/apache_harmony/classlib/modules/regex/src/test/java/org/apache/harmony/tests/java/util/regex/PatternErrorTest.java", "rawCode": "  public void testCompileErrors() throws Exception {\n    // null regex string - should get NullPointerException\n    try {\n      Pattern.compile(null);\n      fail(\"NullPointerException expected\");\n    } catch (NullPointerException e) {\n    }\n\n    // note: invalid regex syntax checked in PatternSyntaxExceptionTest\n\n    // flags = 0 should raise no exception\n    int flags = 0;\n    Pattern.compile(\"foo\", flags);\n\n    // check that all valid flags accepted without exception\n    flags |= Pattern.UNIX_LINES;\n    flags |= Pattern.CASE_INSENSITIVE;\n    flags |= Pattern.MULTILINE;\n    flags |= Pattern.COMMENTS;\n    flags |= Pattern.DOTALL;\n    flags |= Pattern.UNICODE_CASE;\n    Pattern.compile(\"foo\", flags);\n\n    // add invalid flags - should get IllegalArgumentException\n    // regression test for HARMONY-4248\n    flags |= 0xFFFFFFFF;\n    try {\n      Pattern.compile(\"foo\", flags);\n      fail(\"Expected IllegalArgumentException to be thrown\");\n    } catch (IllegalArgumentException e) {\n      // This is the expected exception\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5928, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 151, "focalAPIEnd": 179, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [199], "useEnd": [222], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/libcore/java/util/regex/OldMatcherTest.java", "rawCode": "  public void test_toMatchResult() {\n    String testPattern = \"(((abb)a)(bb))\";\n    String testString = \"babbabbcccabbabbabbabbabb\";\n    Pattern pat = Pattern.compile(testPattern);\n    Matcher mat = pat.matcher(testString);\n\n    mat.region(1, 7);\n    assertTrue(\"matcher should find pattern in given region\", mat.matches());\n    assertEquals(\"matched section should start from 1 position\", 1, mat.toMatchResult().start());\n    assertEquals(\n        \"matched section for 2 group should start from 1 position\",\n        1,\n        mat.toMatchResult().start(2));\n    assertEquals(\n        \"matched section for whole pattern should end on 7 position\", 7, mat.toMatchResult().end());\n    assertEquals(\n        \"matched section for 3 group should end at 4 position\", 4, mat.toMatchResult().end(3));\n    assertEquals(\"group not matched\", \"abbabb\", mat.toMatchResult().group());\n    assertEquals(\"3 group not matched\", \"abb\", mat.toMatchResult().group(3));\n    assertEquals(\n        \"Total number of groups does not matched with given pattern\",\n        4,\n        mat.toMatchResult().groupCount());\n  }\n"}, {"dataset": "compile", "exampleID": 5929, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 152, "focalAPIEnd": 172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["on(pattern)"], "useStart": [140], "useEnd": [173], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/npvincent/guava/tree/master/guava-tests/test/com/google/common/base/SplitterTest.java", "rawCode": "  @GwtIncompatible(\"java.util.regex.Pattern\")\n  public void testSplitterIterableIsUnmodifiable_pattern() {\n    assertIteratorIsUnmodifiable(Splitter.on(Pattern.compile(\",\")).split(\"a,b\").iterator());\n  }\n"}, {"dataset": "compile", "exampleID": 5930, "initialization": ["String regex = quote(String)"], "initializationStart": [882], "initializationEnd": [902], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 932, "focalAPIEnd": 980, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)", "pattern.compile(String,*)", "pattern.matcher(String)"], "useStart": [990, 1341, 1399], "useEnd": [1008, 1389, 1417], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/TranslationText/src/java/org/olanto/TranslationText/server/TranslateServiceImpl.java", "rawCode": "  @Override\n  public int[][] getHitPosNearCR(\n      String content,\n      ArrayList<String> Query,\n      int queryLn,\n      float reFactor,\n      int sepNumber,\n      int avgTokenLn) {\n    int refLength = (int) (reFactor * (queryLn + sepNumber * avgTokenLn));\n    int startp, lastp;\n    // System.out.println(\"Searching for near on a window of: \" + refLength);\n    ArrayList<Integer> Pos = new ArrayList<>();\n    ArrayList<Integer> PosLn = new ArrayList<>();\n    ArrayList<Integer> startPos = new ArrayList<>();\n    ArrayList<Integer> lastPos = new ArrayList<>();\n    String first, last, regex;\n    Pattern p;\n    Matcher m;\n    startPos.clear();\n    lastPos.clear();\n\n    first = removeBorders(Query.get(0));\n    last = removeBorders(Query.get(Query.size() - 1));\n    System.out.println(\"First: \" + first);\n    System.out.println(\"Last: \" + last);\n    regex = REGEX_BEFORE_TOKEN + Pattern.quote(first) + REGEX_AFTER_TOKEN;\n    p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);\n    m = p.matcher(content);\n    if (m.find()) {\n      // System.out.println(\"start found at : \" + m.start());\n      startPos.add(m.start());\n      while (m.find()) {\n        startPos.add(m.start());\n        // System.out.println(\"Start found at : \" + m.start());\n      }\n    }\n    regex = REGEX_BEFORE_TOKEN + Pattern.quote(last) + REGEX_AFTER_TOKEN;\n    p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);\n    m = p.matcher(content);\n    if (m.find()) {\n      // System.out.println(\"last found at : \" + m.start());\n      lastPos.add(m.start());\n      while (m.find()) {\n        lastPos.add(m.start());\n        // System.out.println(\"last found at : \" + m.start());\n      }\n    }\n    for (int i = 0; i < startPos.size(); i++) {\n      startp = startPos.get(i);\n      for (int k = 0; k < lastPos.size(); k++) {\n        lastp = lastPos.get(k);\n        if ((Math.abs(lastp - startp) >= (queryLn - 6))\n            && (Math.abs(lastp - startp) <= refLength)) {\n          if (lastp > startp) {\n            if (getAllWords(content.substring(startp, lastp + last.length() + 1), Query)) {\n              Pos.add(startp);\n              PosLn.add(lastp + last.length() - startp);\n            }\n          } else {\n            if (getAllWords(content.substring(lastp, startp + first.length() + 1), Query)) {\n              Pos.add(lastp);\n              PosLn.add(startp + first.length() - lastp);\n            }\n          }\n        }\n      }\n    }\n    // for (int i = 0; i < Pos.size(); i++) {\n    // System.out.println(\"Positions found in Line: \" + Pos.get(i));\n    // }\n    return getClosePositions(Pos, PosLn);\n  }\n"}, {"dataset": "compile", "exampleID": 5931, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 133, "focalAPIEnd": 156, "followUpCheck": "pattern.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 196, "followUpCheckExpressionEnd": 218, "followUpCheckBlockStart": 196, "followUpCheckBlockEnd": 260, "use": ["pattern.group()"], "useStart": [237], "useEnd": [252], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/eclipse-integration-gradle/tree/master/org.springsource.ide.eclipse.gradle.core/src/org/springsource/ide/eclipse/gradle/core/launch/GradleLaunchConfigurationDelegate.java", "rawCode": "  private static List<String> parseTasks(String tasksText) {\n    List<String> tasks = new ArrayList<String>();\n    Matcher matcher = Pattern.compile(\"\\\\S+\").matcher(tasksText); // $NON-NLS-1$\n    while (matcher.find()) {\n      tasks.add(matcher.group());\n    }\n    return tasks;\n  }\n"}, {"dataset": "compile", "exampleID": 5932, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 57, "focalAPIEnd": 89, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/doits/Sparse-RSS/tree/master/src/de/shandschuh/sparserss/handler/PictureFilenameFilter.java", "rawCode": "  public void setEntryId(String entryId) {\n    pattern = Pattern.compile(entryId + REGEX);\n  }\n"}, {"dataset": "compile", "exampleID": 5933, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 56, "focalAPIEnd": 78, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [96], "useEnd": [115], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Top-Q/jsystem/tree/master/jsystem-core-projects/jsystemCommon/src/main/java/jsystem/extensions/analyzers/text/GetParameterValue.java", "rawCode": "  public void analyze() {\n    Pattern p = null;\n    p = Pattern.compile(regEx);\n    Matcher m = p.matcher(testText);\n    message = testText;\n    if (!m.find()) {\n      status = false;\n      title = \"GetParameterValue is not found: \" + toFind;\n      return;\n    }\n    counter = m.group(1);\n\n    title = \"Get parameter value: \" + counter;\n    status = true;\n  }\n"}, {"dataset": "compile", "exampleID": 5934, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 188, "focalAPIEnd": 212, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [188], "useEnd": [226], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/n8han/Databinder-for-Wicket/tree/master/databinder-components/src/main/java/jtextile/JTextile.java", "rawCode": "  private static boolean preg_match(String pattern, String text) throws Exception {\n    // gnu.regexp.RE r = new gnu.regexp.RE(pattern);\n    // return r.getMatch(text) != null;\n    return Pattern.compile(pattern).matcher(text).find();\n  }\n"}, {"dataset": "compile", "exampleID": 5935, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 82, "focalAPIEnd": 106, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PatternPredicate(pattern,int,int)"], "useStart": [195], "useEnd": [252], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tmyroadctfig/swingx/tree/master/swingx-core/src/test/java/org/jdesktop/swingx/decorator/HighlightPredicateTest.java", "rawCode": "  @Test\n  public void testPattern() {\n    // start with \"t\"\n    Pattern pattern = Pattern.compile(\"^t\", 0);\n    int testColumn = 0;\n    int decorateColumn = 0;\n    HighlightPredicate predicate = new PatternPredicate(pattern, testColumn, decorateColumn);\n    ComponentAdapter adapter = createComponentAdapter(allColored, true);\n    assertEquals(\n        \"predicate must have same result as matcher\",\n        pattern.matcher(allColored.getText()).find(),\n        predicate.isHighlighted(allColored, adapter));\n  }\n"}, {"dataset": "compile", "exampleID": 5936, "initialization": ["String regex = String.trim()"], "initializationStart": [102], "initializationEnd": [116], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["regex.trim()"], "configurationStart": [102], "configurationEnd": [116], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 203, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.compile(String,int)", "createInclude(pattern)"], "useStart": [275, 353], "useEnd": [302, 380], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mdaniel/svn-caucho-com-resin/tree/master/modules/resin/src/com/caucho/server/dispatch/FilterMapping.java", "rawCode": "    /** Adds an include regexp. */\n    public void addIncludeRegexp(String pattern) {\n      pattern = pattern.trim();\n\n      Pattern regexp;\n\n      if (CauchoSystem.isCaseInsensitive())\n        regexp = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);\n      else regexp = Pattern.compile(pattern, 0);\n\n      _hasInclude = true;\n\n      _matchList.add(Match.createInclude(regexp));\n    }\n"}, {"dataset": "compile", "exampleID": 5937, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 502, "focalAPIEnd": 635, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.compile(*)", "new LogParserOptions(pattern,BiMap<String, Integer>,Pattern,String,String,boolean)"], "useStart": [666, 1012], "useEnd": [722, 1083], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/davidmoten/log-analysis/tree/master/log-analysis-core/src/test/java/org/moten/david/log/core/LogParserTest.java", "rawCode": "  /** Tests the multiline use case. */\n  @Test\n  public void testParseUtilLoggingLines() {\n    String line1 = \"23/12/2012 6:58:04 AM org.moten.david.log.core.Database persistDummyRecords\";\n    String line2 = \"INFO: persisted random values=1000 from the last hour to table Dummy\";\n    String line3 = \"some junk\";\n    String line4 =\n        \"23/12/2012 7:00:08 AM org.moten.david.log.core.DatabaseThing persistDummyRecordsAgain\";\n    String line5 = \"DEBUG: something=123\";\n\n    Pattern pattern =\n        Pattern.compile(\n            \"^(\\\\d\\\\d/\\\\d\\\\d/\\\\d\\\\d\\\\d\\\\d \\\\d\\\\d?:\\\\d\\\\d:\\\\d\\\\d (?:(?:AM)|(?:PM))) +(\\\\S+) +(\\\\S+)ZZZ(\\\\S+): (.*)$\");\n    Pattern messagePattern = Pattern.compile(MessageSplitter.MESSAGE_PATTERN_DEFAULT);\n    String format = \"dd/MM/yyyy hh:mm:ss a\";\n    BiMap<String, Integer> map = HashBiMap.create(5);\n    map.put(Field.TIMESTAMP, 1);\n    map.put(Field.LOGGER, 2);\n    map.put(Field.METHOD, 3);\n    map.put(Field.LEVEL, 4);\n    map.put(Field.MSG, 5);\n\n    LogParserOptions options =\n        new LogParserOptions(pattern, map, messagePattern, format, \"UTC\", true);\n    LogParser p = new LogParser(options);\n    assertNull(p.parse(\"test\", line1));\n    {\n      LogEntry entry = p.parse(\"test\", line2);\n      assertNotNull(entry);\n      assertEquals(1356245884000L, entry.getTime());\n      assertEquals(\"INFO\", entry.getProperties().get(Field.LEVEL));\n      assertEquals(\"org.moten.david.log.core.Database\", entry.getProperties().get(Field.LOGGER));\n      assertEquals(\"persistDummyRecords\", entry.getProperties().get(Field.METHOD));\n      assertEquals(\n          \"persisted random values=1000 from the last hour to table Dummy\",\n          entry.getProperties().get(Field.MSG));\n    }\n    assertNull(p.parse(\"test\", line3));\n    assertNull(p.parse(\"test\", line4));\n    {\n      LogEntry entry = p.parse(\"test\", line5);\n      assertNotNull(entry);\n      assertEquals(1356246008000L, entry.getTime());\n      assertEquals(\"DEBUG\", entry.getProperties().get(Field.LEVEL));\n      assertEquals(\n          \"org.moten.david.log.core.DatabaseThing\", entry.getProperties().get(Field.LOGGER));\n      assertEquals(\"persistDummyRecordsAgain\", entry.getProperties().get(Field.METHOD));\n      assertEquals(\"something=123\", entry.getProperties().get(Field.MSG));\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5938, "initialization": ["String regex = String.replace(String,String)"], "initializationStart": [371], "initializationEnd": [410], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 572, "focalAPIEnd": 599, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/0xdata/h2o/tree/master/src/main/java/water/api/Parse.java", "rawCode": "    private Pattern makePattern(String input) {\n      // Reg-Ex pattern match all keys, like file-globbing.\n      // File-globbing: '?' allows an optional single character, regex needs '.?'\n      // File-globbing: '*' allows any characters, regex needs '*?'\n      // File-globbing: '\\' is normal character in windows, regex needs '\\\\'\n      String patternStr =\n          input\n              .replace(\"?\", \".?\")\n              .replace(\"*\", \".*?\")\n              .replace(\"\\\\\", \"\\\\\\\\\")\n              .replace(\"(\", \"\\\\(\")\n              .replace(\")\", \"\\\\)\");\n      Pattern p = Pattern.compile(patternStr);\n      return p;\n    }\n"}, {"dataset": "compile", "exampleID": 5939, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 498, "focalAPIEnd": 558, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [576], "useEnd": [597], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seasarorg/mayaa/tree/master/src-impl/org/seasar/mayaa/impl/engine/processor/WriteProcessor.java", "rawCode": "  protected boolean isExistsBodyTextInScript(String scriptText) {\n    String pattern =\n        \".*(\"\n            + \"\\\\$\\\\{\"\n            + BODY_VARIABLE_NAME\n            + \"\\\\}|\"\n            + \"\\\\$\\\\{\"\n            + BODY_VARIABLE_NAME\n            + \"[^a-zA-Z_$].*\\\\}|\"\n            + \"\\\\$\\\\{.*[^a-zA-Z_$]\"\n            + BODY_VARIABLE_NAME\n            + \"\\\\}|\"\n            + \"\\\\$\\\\{.*[^a-zA-Z_$]\"\n            + BODY_VARIABLE_NAME\n            + \"[^a-zA-Z_$].*\\\\}\"\n            + \")+.*\";\n    Pattern p = Pattern.compile(pattern, Pattern.DOTALL | Pattern.MULTILINE);\n    Matcher m = p.matcher(scriptText);\n    return m.matches();\n  }\n"}, {"dataset": "compile", "exampleID": 5940, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 519, "focalAPIEnd": 548, "followUpCheck": "(!pattern.matcher(temp).matches()) && (true)", "checkType": "IF", "followUpCheckExpressionStart": 556, "followUpCheckExpressionEnd": 624, "followUpCheckBlockStart": 556, "followUpCheckBlockEnd": 709, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pashamur/abcplayer/tree/master/src/player/Main.java", "rawCode": "  public static Header readFile(String file, List<String> result) throws IOException {\n    FileReader fileReader;\n    List<String> headerStr = new ArrayList<String>();\n    try {\n      fileReader = new FileReader(file);\n    } catch (FileNotFoundException e) {\n      throw new IOException(\"Cannot find the file\");\n    }\n    BufferedReader reader = new BufferedReader(fileReader);\n    String temp;\n    int head = 0;\n    Header header = null;\n    while ((temp = reader.readLine()) != null) {\n      Pattern commentPattern = Pattern.compile(\"%[\\\\w\\\\s]*\");\n      if ((!commentPattern.matcher(temp).matches()) && (!temp.equals(\"\"))) {\n        if (head == 1) result.add(temp);\n        else headerStr.add(temp);\n      }\n      if ((!(temp.equals(\"\"))) && (temp.substring(0, 1).equals(\"K\")) && (head == 0)) {\n        head = 1;\n        header = new Header(headerStr);\n      }\n    }\n    return header;\n  }\n"}, {"dataset": "compile", "exampleID": 5941, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 115, "focalAPIEnd": 192, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mkovatsc/SmartAppContiki/tree/master/tools/cooja/java/se/sics/cooja/plugins/ScriptParser.java", "rawCode": "  private String replaceYieldThenWaitUntils(String code) throws ScriptSyntaxErrorException {\n    Pattern pattern = Pattern.compile(\"YIELD_THEN_WAIT_UNTIL\\\\(\" + \"(.*)\" /* expression */ + \"\\\\)\");\n    Matcher matcher = pattern.matcher(code);\n\n    while (matcher.find()) {\n      code = matcher.replaceFirst(\"YIELD(); WAIT_UNTIL(\" + matcher.group(1) + \")\");\n      matcher.reset(code);\n    }\n\n    return code;\n  }\n"}, {"dataset": "compile", "exampleID": 5942, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 100, "focalAPIEnd": 149, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/laiweiwei/eweb4j-framework/tree/master/src/main/java/org/eweb4j/util/CommonUtil.java", "rawCode": "  public static String parseSinglePropVarable(String source, String propId) {\n    Pattern pattern = Pattern.compile(RegexList.property_single_regexp);\n    Matcher matcher = pattern.matcher(source);\n    if (!matcher.find()) return source;\n\n    String g = matcher.group();\n    String suffix = source.replace(g, \"\");\n    String key = g.replace(\"${\", \"\").replace(\"}\", \"\");\n    String prefix = null;\n    if (\"global\".equals(propId)) {\n      prefix = Props.get(key);\n    } else {\n      prefix = Props.getMap(propId).get(key);\n    }\n\n    if (prefix != null) source = prefix + suffix;\n\n    return source;\n  }\n"}, {"dataset": "compile", "exampleID": 5943, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 82, "focalAPIEnd": 135, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)"], "useStart": [153, 874, 947], "useEnd": [187, 937, 981], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chrizmo/SeljeIRC/tree/master/src/jerklib/parsers/AwayParser.java", "rawCode": "  public IRCEvent createEvent(EventToken token, IRCEvent event) {\n    Pattern p = Pattern.compile(\"^:\\\\S+\\\\s\\\\d{3}\\\\s+(\\\\S+)\\\\s:(.*)$\");\n    Matcher m = p.matcher(event.getRawEventData());\n    Session session = event.getSession();\n    if (m.matches()) {\n      switch (Integer.parseInt(token.command())) {\n        case 305:\n          return new AwayEventImpl(\n              session,\n              EventType.RETURNED_FROM_AWAY,\n              false,\n              true,\n              session.getNick(),\n              event.getRawEventData());\n        case 306:\n          {\n            return new AwayEventImpl(\n                session,\n                EventType.WENT_AWAY,\n                true,\n                true,\n                session.getNick(),\n                event.getRawEventData());\n          }\n      }\n    }\n\n    // :card.freenode.net 301 r0bby_ r0bby :foo\n    p = Pattern.compile(\"^:\\\\S+\\\\s+\\\\d{3}\\\\s+\\\\S+\\\\s+(\\\\S+)\\\\s+:(.*)$\");\n    m = p.matcher(event.getRawEventData());\n    m.matches();\n    return new AwayEventImpl(\n        m.group(2),\n        AwayEvent.EventType.USER_IS_AWAY,\n        true,\n        false,\n        m.group(1),\n        event.getRawEventData(),\n        session);\n  }\n"}, {"dataset": "compile", "exampleID": 5944, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 614, "focalAPIEnd": 636, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinedelson/felix/tree/master/sigil/common/core/src/org/apache/felix/sigil/config/BldConverter.java", "rawCode": "  /**\n   * @param id\n   * @param info\n   * @param bundle\n   */\n  private void setLibraries(String id, IBundleModelElement info, ISigilBundle bundle) {\n    // libs\n    Map<String, Map<String, String>> libs = new TreeMap<String, Map<String, String>>();\n    List<String> sources = new ArrayList<String>();\n\n    // classpathEntries map to -libs or -sources\n    for (String entry : bundle.getClasspathEntrys()) {\n      // <classpathentry kind=\"lib\" path=\"lib/dependee.jar\"/>\n      // <classpathentry kind=\"src\" path=\"src\"/>\n      final String regex = \".* kind=\\\"([^\\\"]+)\\\" path=\\\"([^\\\"]+)\\\".*\";\n      Pattern pattern = Pattern.compile(regex);\n      Matcher matcher = pattern.matcher(entry);\n      if (matcher.matches()) {\n        String kind = matcher.group(1);\n        String path = matcher.group(2);\n        if (kind.equals(\"lib\")) {\n          Map<String, String> map2 = new TreeMap<String, String>();\n          map2.put(BldAttr.KIND_ATTRIBUTE, \"classpath\");\n          libs.put(path, map2);\n        } else if (kind.equals(\"src\")) {\n          sources.add(path);\n        } else {\n          BldCore.error(\"unknown classpathentry kind=\" + kind);\n        }\n      } else {\n        BldCore.error(\"can't match classpathEntry in: \" + entry);\n      }\n    }\n\n    if (!libs.isEmpty() || !config.getMap(id, BldConfig.M_LIBS).isEmpty()) {\n      config.setMap(id, BldConfig.M_LIBS, libs);\n    }\n\n    if (!sources.isEmpty() || !config.getList(id, BldConfig.L_SRC_CONTENTS).isEmpty()) {\n      config.setList(id, BldConfig.L_SRC_CONTENTS, sources);\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5945, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 557, "focalAPIEnd": 588, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)"], "useStart": [619, 684, 746, 806, 867, 932], "useEnd": [654, 718, 778, 838, 900, 968], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testURIPatterns() {\n    String URI_REGEXP_STR = \"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\";\n    String SCHEME_REGEXP_STR = \"^[a-zA-Z]{1}[\\\\w+-.]+$\";\n    String REL_URI_REGEXP_STR = \"^(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\";\n    String IPV6_REGEXP_STR = \"^[0-9a-fA-F\\\\:\\\\.]+(\\\\%\\\\w+)?$\";\n    String IPV6_REGEXP_STR2 = \"^\\\\[[0-9a-fA-F\\\\:\\\\.]+(\\\\%\\\\w+)?\\\\]$\";\n    String IPV4_REGEXP_STR = \"^[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}$\";\n    String HOSTNAME_REGEXP_STR = \"\\\\w+[\\\\w\\\\-\\\\.]*\";\n\n    Pattern URI_REGEXP = Pattern.compile(URI_REGEXP_STR);\n    Pattern REL_URI_REGEXP = Pattern.compile(REL_URI_REGEXP_STR);\n    Pattern SCHEME_REGEXP = Pattern.compile(SCHEME_REGEXP_STR);\n    Pattern IPV4_REGEXP = Pattern.compile(IPV4_REGEXP_STR);\n    Pattern IPV6_REGEXP = Pattern.compile(IPV6_REGEXP_STR);\n    Pattern IPV6_REGEXP2 = Pattern.compile(IPV6_REGEXP_STR2);\n    Pattern HOSTNAME_REGEXP = Pattern.compile(HOSTNAME_REGEXP_STR);\n  }\n"}, {"dataset": "compile", "exampleID": 5946, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 171, "focalAPIEnd": 211, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/researchstudio-sat/ldspider4won/tree/master/src/com/ontologycentral/ldspider/tld/TldManager.java", "rawCode": "  private void readList(InputStream is) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(is));\n    String line;\n    Pattern newTldP = Pattern.compile(\"// ([a-z][a-z]+) : .*\");\n    Matcher newTldM;\n    Tld current = null;\n    String tld = \"\";\n\n    while ((line = in.readLine()) != null) {\n      if (line.trim().isEmpty()) {\n        continue;\n      }\n\n      // if we come to a new section for a new tld\n      // e.g. \"//ie : http://en.wikipedia.org/wiki/.ie\"\n      if ((newTldM = newTldP.matcher(line)).matches()) {\n        tld = newTldM.group(1);\n        current = new Tld(tld);\n        TLDs.put(tld, current);\n      } else if (current != null) {\n        // if line is stating that suffix can be one-level\n        // e.g. \"ie\"\n        if (line.equals(tld)) {\n          current.setHasOneLvlSffxes();\n        }\n        // if line is stating that any two-level suffix can be a suffix\n        // e.g. \"*.au\"\n        else if (line.equals(\"*.\" + tld)) {\n          current.setHasTwoLvlSffxes();\n        }\n        // if line is stating additional two-level suffix\n        // e.g. \"com.fr\"\n        else if (line.matches(\"[a-z0-9-]+\\\\.\" + tld)) {\n          current.addAddlTwoLvlSffx(line);\n        }\n        // if line is stating additional three-level suffix\n        // e.g. \"nsw.edu.au\"\n        else if (line.matches(\"[a-z0-9-]+\\\\.[a-z0-9-]+\\\\.\" + tld)) {\n          current.addAddlThreeLvlSffx(line);\n        }\n        // if line is stating exceptional two-level domain\n        // e.g. \"!bl.uk\"\n        else if (line.matches(\"![a-z0-9-]+\\\\.\" + tld)) {\n          current.addExcptnlTwoLvlDomain(line.substring(1, line.length()));\n        }\n        // if line is stating that for some two-levels any three-level can be a suffix\n        // e.g. \"*.sch.uk\"\n        else if (line.matches(\"\\\\*\\\\.[a-z0-9-]+\\\\.\" + tld)) {\n          current.addAddlWildcardThreeLvlSffx(line.substring(2, line.length()));\n        }\n        // if line is stating exceptional three-level domain\n        // e.g. \"!metro.tokyo.jp\"\n        else if (line.matches(\"![a-z0-9-]+\\\\.[a-z0-9-]+\\\\.\" + tld)) {\n          current.addExcptnlThreeLvlDomain(line.substring(1, line.length()));\n        }\n      }\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5947, "initialization": ["String regex = List.get(int)"], "initializationStart": [204], "initializationEnd": [230], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 268, "focalAPIEnd": 322, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["List.add(pattern)"], "useStart": [331], "useEnd": [374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/LeifWarner/openid4java/tree/master/src/org/openid4java/server/RealmVerifier.java", "rawCode": "  private void compileDeniedRealms() {\n    _deniedRealmRegExps = new ArrayList(_deniedRealmDomains.size());\n\n    for (int i = 0; i < _deniedRealmDomains.size(); i++) {\n      String deniedRealm = (String) _deniedRealmDomains.get(i);\n\n      Pattern deniedRealmPattern = Pattern.compile(deniedRealm, Pattern.CASE_INSENSITIVE);\n\n      _deniedRealmRegExps.add(deniedRealmPattern);\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5948, "initialization": ["String regex = StringBuilder.toString()"], "initializationStart": [324], "initializationEnd": [336], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["regex.length()", "regex.charAt(*)"], "configurationStart": [141, 216], "configurationEnd": [155, 233], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 356, "focalAPIEnd": 378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codehaus/griffon-git/tree/master/src/main/cli/org/codehaus/griffon/compiler/GriffonCompilerContext.java", "rawCode": "  private static Pattern normalizePattern(String regex) {\n    if (isWindows) {\n      StringBuilder b = new StringBuilder();\n      int size = regex.length();\n      int i = 0;\n      while (i < size) {\n        char c = regex.charAt(i++);\n        if (c == '\\\\') b.append(\"\\\\\\\\\");\n        else b.append(c);\n      }\n      regex = b.toString();\n    }\n\n    return Pattern.compile(regex);\n  }\n"}, {"dataset": "compile", "exampleID": 5949, "initialization": ["int flags = getCompilerOptions(int)"], "initializationStart": [272], "initializationEnd": [299], "hasTryCatch": 1, "exceptionType": "PatternSyntaxException", "exceptionHandlingCall": ["new BuildException(*)"], "tryExpressionStart": 305, "tryExpressionEnd": 309, "tryBlockStart": 305, "tryBlockEnd": 467, "catchExpressionStart": 392, "catchExpressionEnd": 425, "catchBlockStart": 392, "catchBlockEnd": 467, "exceptionHandlingCallStart": [439], "exceptionHandlingCallEnd": [460], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 329, "focalAPIEnd": 368, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Starlink/starjava/tree/master/ant/src/main/org/apache/tools/ant/util/regexp/Jdk14RegexpMatcher.java", "rawCode": "  /**\n   * Get a compiled representation of the regexp pattern\n   *\n   * @param options the options\n   * @return the compiled pattern\n   * @throws BuildException on error\n   */\n  protected Pattern getCompiledPattern(int options) throws BuildException {\n    int cOptions = getCompilerOptions(options);\n    try {\n      Pattern p = Pattern.compile(this.pattern, cOptions);\n      return p;\n    } catch (PatternSyntaxException e) {\n      throw new BuildException(e);\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5950, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 222, "focalAPIEnd": 296, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [314], "useEnd": [328], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/LuckyStars/nbc/tree/master/function-cardmanage/src/main/com/nbcedu/function/cardmanage/core/dao/impl/BaseDaoImpl.java", "rawCode": "  /**\n   * 去除hql的orderby 子句，用于pagedQuery.\n   *\n   * @see #pagedQuery(String,int,int,Object[])\n   */\n  @SuppressWarnings(\"unused\")\n  private static String removeOrders(String hql) {\n    Assert.hasText(hql);\n    Pattern p = Pattern.compile(\"order\\\\s*by[\\\\w|\\\\W|\\\\s|\\\\S]*\", Pattern.CASE_INSENSITIVE);\n    Matcher m = p.matcher(hql);\n    StringBuffer sb = new StringBuffer();\n    while (m.find()) {\n      m.appendReplacement(sb, \"\");\n    }\n    m.appendTail(sb);\n    return sb.toString();\n  }\n"}, {"dataset": "compile", "exampleID": 5951, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 602, "focalAPIEnd": 652, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gpc/grails-searchable/tree/master/src/java/grails/plugin/searchable/internal/compass/search/DefaultSuggestQueryMethod.java", "rawCode": "    public Object doInCompass(CompassSession session) throws CompassException {\n      Map options = SearchableMethodUtils.getOptionsArgument(args, defaultOptions);\n      options.put(\"analyzer\", \"searchableplugin_simple\");\n      CompassQuery original =\n          compassQueryBuilder.buildQuery(grailsApplication, session, options, args);\n      String queryString = original.getSuggestedQuery().toString();\n      String suggestedString = queryString;\n      if (options.containsKey(\"class\")) {\n        // Strip the additional junk from around the query - +(what test) +(alias:B)\n        Pattern pattern = Pattern.compile(\"\\\\+\\\\((.+)\\\\) \\\\+\\\\(alias:.+\\\\)\");\n        Matcher matcher = pattern.matcher(queryString);\n        if (!matcher.matches()) {\n          return queryString;\n        }\n        suggestedString = matcher.group(1);\n      }\n      String originalString = (String) SearchableMethodUtils.getQueryArgument(args);\n      try {\n        return new SuggestedQueryStringBuilder(originalString, suggestedString)\n            .userFriendly(userFriendly)\n            .emulateCapitalisation(emulateCapitalisation)\n            .escape(escape)\n            .allowSame(allowSame)\n            .toSuggestedQueryString();\n      } catch (ParseException ex) {\n        throw new SearchEngineQueryParseException(\n            \"Failed to parse one of the queries: orignal [\"\n                + originalString\n                + \"], suggested: [\"\n                + suggestedString\n                + \"]\",\n            ex);\n      }\n    }\n"}, {"dataset": "compile", "exampleID": 5952, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 117, "focalAPIEnd": 168, "followUpCheck": "!pattern.matches()", "checkType": "IF", "followUpCheckExpressionStart": 216, "followUpCheckExpressionEnd": 233, "followUpCheckBlockStart": 216, "followUpCheckBlockEnd": 247, "use": ["pattern.group(int)", "pattern.group(int)", "pattern.group(int)"], "useStart": [308, 495, 695], "useEnd": [318, 505, 705], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/h4ck3rm1k3/josm-older/tree/master/src/org/openstreetmap/josm/gui/bbox/TileSelectionBBoxChooser.java", "rawCode": "    @Override\n    public boolean isValid() {\n      String value = getComponent().getText().trim();\n      Matcher m = Pattern.compile(\"(\\\\d+)[^\\\\d]+(\\\\d+)[^\\\\d]+(\\\\d+)\").matcher(value);\n      tileBounds = null;\n      if (!m.matches()) return false;\n      int zoom;\n      try {\n        zoom = Integer.parseInt(m.group(1));\n      } catch (NumberFormatException e) {\n        return false;\n      }\n      if (zoom < 0 || zoom > 18) return false;\n\n      int x;\n      try {\n        x = Integer.parseInt(m.group(2));\n      } catch (NumberFormatException e) {\n        return false;\n      }\n      if (x < 0 || x >= Math.pow(2, zoom - 1)) return false;\n      int y;\n      try {\n        y = Integer.parseInt(m.group(3));\n      } catch (NumberFormatException e) {\n        return false;\n      }\n      if (y < 0 || y >= Math.pow(2, zoom - 1)) return false;\n\n      tileBounds = new TileBounds(new Point(x, y), new Point(x, y), zoom);\n      return true;\n    }\n"}, {"dataset": "compile", "exampleID": 5953, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 262, "focalAPIEnd": 285, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/grozeille/sonar-plugin-dotnet/tree/master/tools/dotnet-tools-commons/src/main/java/org/sonar/dotnet/tools/commons/visualstudio/ModelFactory.java", "rawCode": "  /**\n   * Reads a property from a project\n   *\n   * @param string\n   * @param definition\n   * @return\n   */\n  public static String extractSolutionProperty(String name, String definition) {\n    String regexp = name + \"\\\\s*=\\\\s*\\\"([^\\\"]*)\";\n    Pattern pattern = Pattern.compile(regexp);\n    Matcher matcher = pattern.matcher(definition);\n    if (matcher.find()) {\n      return matcher.group(1);\n    }\n    return null;\n  }\n"}, {"dataset": "compile", "exampleID": 5954, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 189, "focalAPIEnd": 219, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["IRtti.getMethods(pattern)", "IRtti.getFields(pattern)"], "useStart": [259, 901], "useEnd": [283, 924], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seasarorg/kijimuna/tree/master/org.seasar.kijimuna.ui/src/org/seasar/kijimuna/ui/internal/editor/dicon/contentassist/DiconElementAssistant.java", "rawCode": "  private List getMemberProposals(\n      IRtti rtti, String fixed, String member, boolean isStatic, String prefix, int offset) {\n    List proposals = new ArrayList();\n    Pattern pattern = Pattern.compile(member + \".*\");\n    IRttiMethodDesctiptor[] methods = rtti.getMethods(pattern);\n    for (int i = 0; i < methods.length; i++) {\n      if (!isStatic || methods[i].isStatic()) {\n        String methodName = ModelUtils.getMethodDisplay(methods[i], false);\n        String replaceStr = fixed + methods[i].getMethodName() + \"()\";\n        int posDeferencial = (methods[i].getArgs().length == 0) ? 0 : 1;\n        proposals.add(\n            createProposal(\n                replaceStr,\n                methodName,\n                prefix,\n                offset,\n                replaceStr.length() - posDeferencial,\n                IMAGE_ICON_JAVA_METHOD));\n      }\n    }\n    IRttiFieldDescriptor[] fields = rtti.getFields(pattern);\n    for (int i = 0; i < fields.length; i++) {\n      if (!isStatic || fields[i].isStatic() || fields[i].isEnum()) {\n        String fieldName = fields[i].getName();\n        String replaceStr = fixed + fieldName;\n        proposals.add(\n            createProposal(\n                replaceStr, fieldName, prefix, offset, replaceStr.length(), IMAGE_ICON_JAVA_FIELD));\n      }\n    }\n    Collections.sort(proposals, new ProposalComparator());\n    return proposals;\n  }\n"}, {"dataset": "compile", "exampleID": 5955, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 864, "focalAPIEnd": 905, "followUpCheck": "pattern.matches()", "checkType": "IF", "followUpCheckExpressionStart": 927, "followUpCheckExpressionEnd": 943, "followUpCheckBlockStart": 927, "followUpCheckBlockEnd": 1022, "use": ["pattern.group(int)", "pattern.group(int)"], "useStart": [977, 1005], "useEnd": [987, 1015], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1_9_1/trunk-archive/src/om/graph/World.java", "rawCode": "  /**\n   * Obtains a Font object from the given string value in the format: [bold/italic] [7px] [Verdana].\n   * Leaving out any part of the string results in the defaults being used.\n   *\n   * @param sValue Input string\n   * @return Font object\n   */\n  private Font convertFont(String sValue) throws GraphFormatException {\n    // Bold/italic\n    boolean bBold = false, bItalic = false;\n    while (true) {\n      if (sValue.startsWith(\"bold\")) {\n        bBold = true;\n        sValue = sValue.substring(\"bold\".length());\n        while (sValue.startsWith(\" \")) sValue = sValue.substring(1);\n      } else if (sValue.startsWith(\"italic\")) {\n        bItalic = true;\n        sValue = sValue.substring(\"italic\".length());\n        while (sValue.startsWith(\" \")) sValue = sValue.substring(1);\n      } else break;\n    }\n\n    // Size\n    int iSize = iFontSize;\n    Matcher m = Pattern.compile(\"^([0-9]+)px(\\\\ )?(.*)$\").matcher(sValue);\n    if (m.matches()) {\n      iSize = Integer.parseInt(m.group(1));\n      sValue = m.group(3);\n    }\n\n    // Family\n    String sFamily = sFontFamily;\n    if (sValue.length() > 0) {\n      sFamily = sValue;\n    }\n\n    return new Font(sFamily, (bItalic ? Font.ITALIC : 0) | (bBold ? Font.BOLD : 0), iSize);\n  }\n"}, {"dataset": "compile", "exampleID": 5956, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 122, "focalAPIEnd": 149, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)"], "useStart": [169, 296, 335, 465, 504, 641, 680, 813, 852], "useEnd": [192, 323, 358, 492, 527, 668, 703, 840, 875], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testEmbeddedFlags() {\n    String baseString = \"(?i)((?s)a)\";\n    String testString = \"A\";\n    Pattern pat = Pattern.compile(baseString);\n    Matcher mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"(?x)(?i)(?s)(?d)a\";\n    testString = \"A\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"(?x)(?i)(?s)(?d)a.\";\n    testString = \"a\\n\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"abc(?x:(?i)(?s)(?d)a.)\";\n    testString = \"abcA\\n\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"abc((?x)d)(?i)(?s)a\";\n    testString = \"abcdA\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n  }\n"}, {"dataset": "compile", "exampleID": 5957, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 81, "focalAPIEnd": 130, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [154], "useEnd": [166], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7177/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  private static String getValue(String s, String param) {\n    final Pattern p = Pattern.compile(\"(?i)\" + param + \"=\\\"([^\\\"]+)\\\"\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(1);\n  }\n"}, {"dataset": "compile", "exampleID": 5958, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 81, "focalAPIEnd": 118, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/tests/libcore/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testUnicodeCategoryWithSurrogatesSupplementary() {\n    Pattern p = Pattern.compile(\"\\\\p{javaLowerCase}\");\n    Matcher matcher = p.matcher(\"\\uD801\\uDC28\");\n    assertTrue(matcher.find());\n  }\n"}, {"dataset": "compile", "exampleID": 5959, "initialization": ["String regex = asString(Syntax)"], "initializationStart": [226], "initializationEnd": [247], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 316, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [353], "useEnd": [369], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ICGog/MapReduce-Thorn/tree/master/lib/fisher/src/fisher/runtime/StringTh.java", "rawCode": "  private Thing CmatchRE(\n      String methodName, Thing[] args, Evaller evaller, Framelike frame, Syntax src)\n      throws FisherException {\n    checkNumberOfArgs(1, 1, methodName, args, evaller, frame, src);\n    String re = args[0].asString(src);\n    // TODO -- if Pattern doesn't cache, we could.\n    Pattern p = Pattern.compile(re);\n    Matcher m = p.matcher(value);\n    if (m.matches()) {\n      return thornifyMatcher(src, m);\n    } else {\n      return null;\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5960, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 415, "focalAPIEnd": 436, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.split(String)", "pattern.split(String)"], "useStart": [1310, 2926], "useEnd": [1326, 2942], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/gwas/NAMgwas/Utilities.java", "rawCode": "  public static void countTermsByAnnotation() {\n\n    class PositionInfo {\n      ArrayList<String> annotations = new ArrayList<String>();\n      int count = 0;\n\n      @Override\n      public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(count);\n        for (String anno : annotations) sb.append(\"\\t\").append(anno);\n        return sb.toString();\n      }\n    }\n\n    Pattern tab = Pattern.compile(\"\\t\");\n    ArrayList<HashMap<Integer, PositionInfo>> chromosomeMaps =\n        new ArrayList<HashMap<Integer, PositionInfo>>();\n    // Object[] is count (Integer), ArrayList<String> to hold annotations\n    String trait = \"angle\";\n\n    System.out.println(\"Reading step terms...\");\n    for (int chr = 1; chr <= 10; chr++) {\n      String filename =\n          \"C:/Projects/NAM/hapmap/results/minor/\"\n              + trait\n              + \"/\"\n              + trait\n              + \".bootstrap.random.steps.chr\"\n              + chr\n              + \".v4.txt\";\n      HashMap<Integer, PositionInfo> thisMap = new HashMap<Integer, PositionInfo>();\n      chromosomeMaps.add(thisMap);\n      try {\n        BufferedReader br = new BufferedReader(new FileReader(filename));\n        br.readLine();\n        String input;\n        while ((input = br.readLine()) != null) {\n          String[] data = tab.split(input);\n          Integer pos = Integer.decode(data[1]);\n          PositionInfo posInfo = thisMap.get(pos);\n          if (posInfo == null) {\n            posInfo = new PositionInfo();\n            thisMap.put(pos, posInfo);\n          }\n          posInfo.count++;\n        }\n        br.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n        System.exit(-1);\n      }\n    }\n\n    // output counts here\n    try {\n      String filename = \"C:/Projects/NAM/hapmap/results/minor/RFR_term_counts.txt\";\n      BufferedWriter bw = new BufferedWriter(new FileWriter(filename));\n      bw.write(\"chromosome\\tpos\\tcount\");\n      bw.newLine();\n      for (int c = 0; c < 10; c++) {\n        String chr = Integer.toString(c + 1);\n        HashMap<Integer, PositionInfo> thisMap = chromosomeMaps.get(c);\n        TreeSet<Integer> posSet = new TreeSet<Integer>(thisMap.keySet());\n        for (Integer pos : posSet) {\n          PositionInfo pi = thisMap.get(pos);\n          bw.write(chr + \"\\t\" + pos + \"\\t\" + pi.count);\n          bw.newLine();\n        }\n      }\n      bw.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    String filename = \"C:/Projects/NAM/hapmap/snpinfo/BGI-CSHLALL-UNION.HP1.snp_effects.txt\";\n    int curr_chr = 0;\n    String input = \"beginning\";\n    HashMap<String, Integer> annotationCount = new HashMap<String, Integer>();\n    // record annotations for model terms\n    try {\n      BufferedReader br = new BufferedReader(new FileReader(filename));\n      int count = -1;\n      while ((input = br.readLine()) != null) {\n        String[] data = tab.split(input);\n        Integer pos = Integer.decode(data[1]);\n        int chr = Integer.parseInt(data[0].substring(3));\n        if (chr != curr_chr) {\n          TreeSet<String> names = new TreeSet(annotationCount.keySet());\n          for (String anno : names) {\n            System.out.println(\"chr\" + curr_chr + \"\\t\" + anno + \"\\t\" + annotationCount.get(anno));\n          }\n          curr_chr = chr;\n          annotationCount.clear();\n        }\n        Integer cnt = annotationCount.get(data[6]);\n        if (cnt == null) cnt = annotationCount.put(data[6], new Integer(1));\n        else annotationCount.put(data[6], ++cnt);\n        HashMap<Integer, PositionInfo> thisMap = chromosomeMaps.get(chr - 1);\n        PositionInfo posInfo = thisMap.get(pos);\n        if (posInfo != null) {\n          posInfo.annotations.add(data[6]);\n        }\n      }\n      TreeSet<String> names = new TreeSet<String>(annotationCount.keySet());\n      for (String anno : names) {\n        System.out.println(\"chr\" + curr_chr + \"\\t\" + anno + \"\\t\" + annotationCount.get(anno));\n      }\n\n      br.close();\n    } catch (IOException e) {\n      System.err.println(\"failed at: \" + input);\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    System.out.println(\"Printing annotation summary...\");\n\n    // get set of annotations\n    TreeSet<String> annotationSet = new TreeSet<String>();\n    for (HashMap<Integer, PositionInfo> map : chromosomeMaps) {\n      for (PositionInfo pi : map.values()) {\n        annotationSet.addAll(pi.annotations);\n      }\n    }\n\n    // count annotations by chromosome\n    int nAnno = annotationSet.size();\n    ArrayList<String> annotationList = new ArrayList<String>(annotationSet);\n    int[][] counts = new int[nAnno][10];\n    for (int chr = 0; chr < 10; chr++) {\n      for (PositionInfo pi : chromosomeMaps.get(chr).values()) {\n        for (String anno : pi.annotations) {\n          int n = annotationList.indexOf(anno);\n          counts[n][chr]++;\n        }\n      }\n    }\n\n    try {\n      BufferedWriter bw =\n          new BufferedWriter(\n              new FileWriter(\"C:/Projects/NAM/hapmap/snpinfo/hp2_annotation_summary.txt\"));\n      bw.write(\"annotation\\tchr1\\tchr2\\tchr3\\tchr4\\tchr5\\tchr6\\tchr7\\tchr8\\tchr9\\tchr10\");\n      bw.newLine();\n      for (int i = 0; i < nAnno; i++) {\n        bw.write(annotationList.get(i));\n        for (int j = 0; j < 10; j++) {\n          bw.write(\"\\t\");\n          bw.write(Integer.toString(counts[i][j]));\n        }\n        bw.newLine();\n      }\n\n      bw.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    // also output annotations for each term\n    try {\n      BufferedWriter bw =\n          new BufferedWriter(\n              new FileWriter(\"C:/Projects/NAM/hapmap/snpinfo/hp2_model_annotations.txt\"));\n      bw.write(\"chr\\tposition\\tcount\\tannotations\");\n      bw.newLine();\n\n      for (int c = 0; c < 10; c++) {\n        String chr = Integer.toString(c + 1);\n        HashMap<Integer, PositionInfo> thisMap = chromosomeMaps.get(c);\n        TreeSet<Integer> positions = new TreeSet<Integer>(thisMap.keySet());\n        for (Integer pos : positions) {\n          PositionInfo pi = thisMap.get(pos);\n          bw.write(chr + \"\\t\" + pos + \"\\t\" + pi);\n          bw.newLine();\n        }\n      }\n      bw.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    System.out.println(\"Finished\");\n  }\n"}, {"dataset": "compile", "exampleID": 5961, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "PatternSyntaxException", "exceptionHandlingCall": ["getMessage()", "new CompileException(int,int,String)"], "tryExpressionStart": 258, "tryExpressionEnd": 262, "tryBlockStart": 258, "tryBlockEnd": 464, "catchExpressionStart": 338, "catchExpressionEnd": 372, "catchBlockStart": 338, "catchBlockEnd": 464, "exceptionHandlingCallStart": [441, 386], "exceptionHandlingCallEnd": [456, 457], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 270, "focalAPIEnd": 330, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mth/yeti/tree/master/c/YetiBuiltins.java", "rawCode": "  Code apply2nd(final Code arg2, final YType t, final int line) {\n    if (line == 0) {\n      throw new NullPointerException();\n    }\n    final Code matcher = new SimpleCode(this, arg2, t, line);\n    if (!(arg2 instanceof StringConstant)) return matcher;\n    try {\n      Pattern.compile(((StringConstant) arg2).str, Pattern.DOTALL);\n    } catch (PatternSyntaxException ex) {\n      throw new CompileException(line, 0, \"Bad pattern syntax: \" + ex.getMessage());\n    }\n    return new Code() {\n      {\n        type = t;\n      }\n\n      void gen(Ctx ctx) {\n        ctx.constant(\n            (yes ? \"MATCH-FUN:\" : \"MATCH!FUN:\").concat(((StringConstant) arg2).str), matcher);\n      }\n    };\n  }\n"}, {"dataset": "compile", "exampleID": 5962, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 132, "focalAPIEnd": 248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stlanger/Docear/tree/master/freeplane/src/org/freeplane/features/text/mindmapmode/MTextController.java", "rawCode": "  public boolean containsFormatting(final String text) {\n    if (FORMATTING_PATTERN == null) {\n      FORMATTING_PATTERN =\n          Pattern.compile(\n              \"<(?!/|html>|head|body|p/?>|!--|style type=\\\"text/css\\\">)\", Pattern.CASE_INSENSITIVE);\n    }\n    final Matcher matcher = FORMATTING_PATTERN.matcher(text);\n    return matcher.find();\n  }\n"}, {"dataset": "compile", "exampleID": 5963, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 536, "focalAPIEnd": 560, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.split(String)"], "useStart": [668], "useEnd": [703], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/societies/SOCIETIES-Platform/tree/master/context-management/UserContextRefinement/src/main/java/org/societies/context/user/refinement/impl/tools/NetworkConverter.java", "rawCode": "  /**\n   * <br>\n   * Changes from {@link String} of numbers, separated by a pattern, to an array of {@link double}\n   * <br>\n   * <br>\n   * original object: \"1 0 0.7 0.3 ...\"<br>\n   * example pattern: \" \"<br>\n   * final object: {1, 0, 0.7, 0.3 ...}<br>\n   *\n   * @param nodeStringProb {@link String} of numbers separated by a pattern\n   * @return numbers in an array of {@link double}\n   */\n  private static double[] stringNumberToDouble(String nodeStringProb, String pattern) {\n    double[] result = null;\n\n    Pattern stringPattern = Pattern.compile(pattern); // I define the\n    // pattern to\n    // recognize between\n    // to numbers\n    String[] nodeProbArray = stringPattern.split(nodeStringProb);\n    result = new double[nodeProbArray.length];\n    for (int k = 0; k < nodeProbArray.length; k++) {\n      result[k] = Double.parseDouble(nodeProbArray[k]);\n    }\n\n    return result;\n  }\n"}, {"dataset": "compile", "exampleID": 5964, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 517, "focalAPIEnd": 584, "followUpCheck": "(ResourcesUtil.findDir(project.getProject(),new Path(\"META-INF\"),pattern,handler) ) || (ResourcesUtil.findDir(project.getProject(),resourcePath,pattern,handler) ) || (ResourcesUtil.findDir(project.getProject(),resourcePath.removeLastSegments(1).append(nc.getEntityPackageName()),pattern,handler) )", "checkType": "IF", "followUpCheckExpressionStart": 673, "followUpCheckExpressionEnd": 1188, "followUpCheckBlockStart": 673, "followUpCheckBlockEnd": 1219, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seasarorg/chura/tree/master/dolteng/org.seasar.dolteng.eclipse.plugin/src/main/java/org/seasar/dolteng/eclipse/operation/KuinaDaoErrorReportJob.java", "rawCode": "    private boolean checkOrmXml(\n        String methodName, NamingConvention nc, String pkg, IPath resourcePath)\n        throws JavaModelException, CoreException {\n      String entityName = \"\";\n      String en = primary.getElementName();\n      if (nc.isTargetClassName(primary.getFullyQualifiedName(), nc.getDaoSuffix())) {\n        entityName = en.substring(0, en.length() - 3);\n      } else {\n        if (pkg.endsWith(nc.getEntityPackageName())) {\n          entityName = en;\n        }\n      }\n      Pattern ormXml = Pattern.compile(entityName + \"Orm\\\\.xml\", Pattern.CASE_INSENSITIVE);\n      XmlFindingHandler handler = new XmlFindingHandler(entityName, methodName);\n      if ((ResourcesUtil.findDir(project.getProject(), new Path(\"META-INF\"), ormXml, handler)\n              && handler.hasNamedQuery)\n          || (ResourcesUtil.findDir(project.getProject(), resourcePath, ormXml, handler)\n              && handler.hasNamedQuery)\n          || (ResourcesUtil.findDir(\n                  project.getProject(),\n                  resourcePath.removeLastSegments(1).append(nc.getEntityPackageName()),\n                  ormXml,\n                  handler)\n              && handler.hasNamedQuery)) {\n        return true;\n      }\n      return false;\n    }\n"}, {"dataset": "compile", "exampleID": 5965, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 787, "focalAPIEnd": 822, "followUpCheck": "!pattern.matches()", "checkType": "IF", "followUpCheckExpressionStart": 854, "followUpCheckExpressionEnd": 871, "followUpCheckBlockStart": 854, "followUpCheckBlockEnd": 1153, "use": ["pattern.group(int)", "pattern.group(int)", "pattern.group(int)", "pattern.group(int)"], "useStart": [1165, 1228, 1263, 1321], "useEnd": [1175, 1238, 1273, 1331], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/PerfectButter/platform_packages_apps_Settings/tree/master/src/com/android/settings/DeviceInfoSettings.java", "rawCode": "  public static String formatKernelVersion(String rawKernelVersion) {\n    // Example (see tests for more):\n    // Linux version 3.0.31-g6fb96c9 (android-build@xxx.xxx.xxx.xxx.com) \\\n    // (gcc version 4.6.x-xxx 20120106 (prerelease) (GCC) ) #1 SMP PREEMPT \\\n    // Thu Jun 28 11:02:39 PDT 2012\n\n    final String PROC_VERSION_REGEX =\n        \"Linux version (\\\\S+) \"\n            + /* group 1: \"3.0.31-g6fb96c9\" */ \"\\\\((\\\\S+?)\\\\) \"\n            + /* group 2: \"x@y.com\" (kernel builder) */ \"(?:\\\\(gcc.+? \\\\)) \"\n            + /* ignore: GCC version information */ \"(#\\\\d+) \"\n            + /* group 3: \"#1\" */ \"(?:.*?)?\"\n            + /* ignore: optional SMP, PREEMPT, and any CONFIG_FLAGS */ \"((Sun|Mon|Tue|Wed|Thu|Fri|Sat).+)\"; /* group 4: \"Thu Jun 28 11:02:39 PDT 2012\" */\n\n    Matcher m = Pattern.compile(PROC_VERSION_REGEX).matcher(rawKernelVersion);\n    if (!m.matches()) {\n      Log.e(LOG_TAG, \"Regex did not match on /proc/version: \" + rawKernelVersion);\n      return \"Unavailable\";\n    } else if (m.groupCount() < 4) {\n      Log.e(LOG_TAG, \"Regex match on /proc/version only returned \" + m.groupCount() + \" groups\");\n      return \"Unavailable\";\n    }\n    return m.group(1)\n        + \"\\n\"\n        + // 3.0.31-g6fb96c9\n        m.group(2)\n        + \" \"\n        + m.group(3)\n        + \"\\n\"\n        + // x@y.com #1\n        m.group(4); // Thu Jun 28 11:02:39 PDT 2012\n  }\n"}, {"dataset": "compile", "exampleID": 5966, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 187, "focalAPIEnd": 212, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OperatingSystemPattern(int,pattern,int)", "pattern.compile(String)"], "useStart": [157, 266], "useEnd": [216, 290], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/before/uadetector/tree/master/modules/uadetector-core/src/test/java/net/sf/uadetector/internal/data/domain/OperatingSystemBuilderTest.java", "rawCode": "  @Test\n  public void construct_copy_successful() {\n    final Set<OperatingSystemPattern> patterns = new HashSet<OperatingSystemPattern>();\n    patterns.add(new OperatingSystemPattern(2, Pattern.compile(\"[0-9]+\"), 2));\n    patterns.add(new OperatingSystemPattern(1, Pattern.compile(\"[0-9]\"), 1));\n\n    final OperatingSystem.Builder original = new OperatingSystem.Builder();\n    original.setFamily(\"f1\");\n    original.setIcon(\"i1\");\n    original.setId(1);\n    original.setInfoUrl(\"iu1\");\n    original.setName(\"n1\");\n    original.addPatterns(patterns);\n    original.setProducer(\"p1\");\n    original.setProducerUrl(\"pu1\");\n    original.setUrl(\"u1\");\n\n    final OperatingSystem.Builder copy1 = new OperatingSystem.Builder(original);\n    assertThat(copy1.getFamily()).isEqualTo(\"f1\");\n    assertThat(copy1.getIcon()).isEqualTo(\"i1\");\n    assertThat(copy1.getId()).isEqualTo(1);\n    assertThat(copy1.getInfoUrl()).isEqualTo(\"iu1\");\n    assertThat(copy1.getName()).isEqualTo(\"n1\");\n    assertThat(copy1.getPatterns()).hasSize(2);\n    assertThat(copy1.getPatterns()).isEqualTo(patterns);\n    assertThat(copy1.getProducer()).isEqualTo(\"p1\");\n    assertThat(copy1.getProducerUrl()).isEqualTo(\"pu1\");\n    assertThat(copy1.getUrl()).isEqualTo(\"u1\");\n\n    final OperatingSystem.Builder copy2 = original.copy();\n    assertThat(copy2.getFamily()).isEqualTo(\"f1\");\n    assertThat(copy2.getIcon()).isEqualTo(\"i1\");\n    assertThat(copy2.getId()).isEqualTo(1);\n    assertThat(copy2.getInfoUrl()).isEqualTo(\"iu1\");\n    assertThat(copy2.getName()).isEqualTo(\"n1\");\n    assertThat(copy2.getPatterns()).hasSize(2);\n    assertThat(copy2.getPatterns()).isEqualTo(patterns);\n    assertThat(copy2.getProducer()).isEqualTo(\"p1\");\n    assertThat(copy2.getProducerUrl()).isEqualTo(\"pu1\");\n    assertThat(copy2.getUrl()).isEqualTo(\"u1\");\n\n    final OperatingSystem.Builder copy3 = new OperatingSystem.Builder(original.build());\n    assertThat(copy3.getFamily()).isEqualTo(\"f1\");\n    assertThat(copy3.getIcon()).isEqualTo(\"i1\");\n    assertThat(copy3.getId()).isEqualTo(1);\n    assertThat(copy3.getInfoUrl()).isEqualTo(\"iu1\");\n    assertThat(copy3.getName()).isEqualTo(\"n1\");\n    assertThat(copy3.getPatterns()).hasSize(2);\n    assertThat(copy3.getPatterns()).isEqualTo(patterns);\n    assertThat(copy3.getProducer()).isEqualTo(\"p1\");\n    assertThat(copy3.getProducerUrl()).isEqualTo(\"pu1\");\n    assertThat(copy3.getUrl()).isEqualTo(\"u1\");\n  }\n"}, {"dataset": "compile", "exampleID": 5967, "initialization": ["String regex = String.replaceAll(String,String)"], "initializationStart": [189], "initializationEnd": [218], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["regex.replaceAll(String,String)"], "configurationStart": [189], "configurationEnd": [218], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 413, "focalAPIEnd": 435, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/mySelfQDAlgo/src/org/olanto/mysqd/util/WildCharExpander.java", "rawCode": "  public boolean Contains(String regex) {\n    // System.out.println(\"---------- target size :\" + target.length());\n    // System.out.println(\"---------- look 0 for :\" + regex);\n    regex = regex.replaceAll(\"\\\\*\", \".*\");\n    // System.out.println(\"---------- look 1 for :\" + regex);\n\n    regex = ITEM_START + regex + ITEM_STOP;\n    //// System.out.println(\"---------- look 2 for :\" + regex);\n    Pattern pattern = Pattern.compile(regex);\n    // Get a Matcher based on the target string.\n    Matcher matcher = pattern.matcher(target);\n    return matcher.find();\n  }\n"}, {"dataset": "compile", "exampleID": 5968, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 269, "focalAPIEnd": 313, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [1050], "useEnd": [1071], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seweissman/wikiduper/tree/master/src/main/wikiduper/dist/EditDistance.java", "rawCode": "  public static void main(String args[]) {\n\n    if (args.length != 1) {\n      System.out.println(\"Usage: EditDistance <filein>\\n\");\n      System.exit(-1);\n    }\n    // Pattern linepat = Pattern.compile(\"(\\\\[[-0-9, ]+\\\\])\\t\\\\((.*), \\\\d+:\\\\d+\\\\)\");\n    Pattern linepat = Pattern.compile(\"([-0-9]+)\\t([^\\t]+)\\t(.*)\");\n    // ArrayList<ArrayList<String>> clusterlist = new ArrayList<ArrayList<String>>();\n    HashMap<String, HashSet<String>> matchmap = new HashMap<String, HashSet<String>>();\n    HashMap<String, HashSet<String>> nomatchmap = new HashMap<String, HashSet<String>>();\n\n    FileInputStream fin;\n    int clusterct = 0;\n    int uniquematchct = 0;\n    int uniquefalseposct = 0;\n    int nonuniquematchct = 0;\n    int nonuniquefalseposct = 0;\n    try {\n      fin = new FileInputStream(args[0]);\n      BufferedReader bin = new BufferedReader(new InputStreamReader(fin));\n      String line;\n      ArrayList<String> cluster = new ArrayList<String>();\n      String sigcurr = null;\n      while ((line = bin.readLine()) != null) {\n        Matcher m = linepat.matcher(line);\n        String sig = \"\";\n        String sentence = \"\";\n        String article = \"\";\n        if (m.matches()) {\n          sig = m.group(1);\n          article = m.group(2);\n          sentence = m.group(3);\n          System.out.println(\n              \"sig = \" + sig + \", article = \" + article + \", sentence = \" + sentence);\n        } else {\n          System.out.println(\"Bad line: \" + line);\n          System.exit(-1);\n        }\n\n        if (sigcurr == null) {\n          sigcurr = sig;\n        }\n        if (!sigcurr.equals(sig)) {\n          clusterct++;\n          if (clusterct % 1000 == 0) System.out.println(\"clusterct = \" + clusterct);\n          for (int i = 0; i < cluster.size(); i++) {\n            String m1 = cluster.get(i);\n            for (int j = i + 1; j < cluster.size(); j++) {\n              String m2 = cluster.get(j);\n              long dl = Math.max(m1.length(), m2.length()) - Math.min(m1.length(), m2.length());\n              long d = dist(m1, m2);\n              long score =\n                  Math.round(100 * (d - dl + 1) * 1.0 / Math.max(m1.length(), m2.length()));\n\n              if (score > 25) {\n                nonuniquefalseposct++;\n                // System.out.println(m1 + \">>>>>>\" + m2 + \">>>>>> \" + score);\n                if (!nomatchmap.containsKey(m1)) {\n                  nomatchmap.put(m1, new HashSet<String>());\n                }\n\n                if (!nomatchmap.containsKey(m2)) {\n                  nomatchmap.put(m2, new HashSet<String>());\n                }\n                if (!(nomatchmap.get(m2).contains(m1) || nomatchmap.get(m1).contains(m2))) {\n                  // System.out.println(m1 + \"\\t\" + m2);\n                  uniquefalseposct++;\n                }\n\n                nomatchmap.get(m2).add(m1);\n                nomatchmap.get(m1).add(m2);\n              } else {\n                nonuniquematchct++;\n\n                if (!matchmap.containsKey(m1)) {\n                  matchmap.put(m1, new HashSet<String>());\n                }\n\n                if (!matchmap.containsKey(m2)) {\n                  matchmap.put(m2, new HashSet<String>());\n                }\n                if (!(matchmap.get(m2).contains(m1) || matchmap.get(m1).contains(m2))) {\n                  uniquematchct++;\n                }\n                matchmap.get(m2).add(m1);\n                matchmap.get(m1).add(m2);\n              }\n            }\n          }\n          // clusterlist.add(cluster);\n          // cluster = new ArrayList<String>();\n          cluster.clear();\n        }\n        sigcurr = sig;\n\n        sentence =\n            sentence\n                .replace(\"External Links\", \"\")\n                .replace(\"External links\", \"\")\n                .replace(\"References\", \"\")\n                .replace(\"Official site\", \"\")\n                .replace(\"official site\", \"\");\n        if (sentence.length() > 100) {\n          cluster.add(sentence);\n        }\n\n        // System.out.println(\"entity = \" + entity);\n      }\n      bin.close();\n      fin.close();\n\n    } catch (FileNotFoundException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    } catch (IOException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n\n    System.out.println(\"Cluster count:\" + clusterct);\n    System.out.println(\"N unique input matchess: \" + uniquematchct);\n    System.out.println(\"N unique input false positives: \" + uniquefalseposct);\n    System.out.println(\"N non-unique input matchess: \" + nonuniquematchct);\n    System.out.println(\"N non-unique input false positives: \" + nonuniquefalseposct);\n    // System.exit(-1);\n    int componentct = 0;\n    HashMap<Long, Long> histogram = new HashMap<Long, Long>();\n    long matchct = 0;\n    long badct = 0;\n    while (!matchmap.isEmpty()) {\n      String[] matchentities = matchmap.keySet().toArray(new String[0]);\n      String entity = matchentities[0];\n      HashSet<String> comp = getConnectedComponent(entity, matchmap);\n      // System.out.println(\"entity = \" + entity);\n      String cluster[] = comp.toArray(new String[0]);\n      componentct++;\n      System.out.println(\"componentct = \" + componentct + \" \" + comp.size());\n\n      int clustdisplayct = 0;\n      for (String m : cluster) {\n        if (clustdisplayct > 20) break;\n        System.out.println(\"item = \" + m);\n        clustdisplayct++;\n      }\n\n      for (int i = 0; i < cluster.length; i++) {\n        String entity1 = cluster[i];\n        for (int j = i + 1; j < cluster.length; j++) {\n          matchct++;\n          String entity2 = cluster[j];\n          long dl =\n              Math.max(entity1.length(), entity2.length())\n                  - Math.min(entity1.length(), entity2.length());\n          long d = dist(entity1, entity2);\n          long score =\n              Math.round(100 * (d - dl + 1) * 1.0 / Math.max(entity1.length(), entity2.length()));\n          // System.out.println(entity1 + \", \" + entity2 + \", \" + d + \", \" + dl + \", \" + Math.ceil(\n          // 100*score));\n          if (score > 0) {\n            if (!histogram.containsKey(score)) {\n              histogram.put(score, 0l);\n            }\n            histogram.put(score, histogram.get(score) + 1);\n          }\n          // if(dl > d){\n          // System.out.println(\"Weird lines:\");\n          // System.out.println(entity1 + \", \" + entity2 + \", \" + d + \", \" + dl + \", \" + Math.ceil(\n          // 100*score));\n          // }\n\n          if (score > 5) {\n            badct++;\n          }\n        }\n      }\n      System.out.println(\"matchct = \" + matchct + \" ,'badct = \" + badct);\n    }\n    for (long i = 0; i <= 100; i++) {\n      if (histogram.containsKey(i)) {\n        System.out.println(i + \",\" + histogram.get(i));\n      } else {\n        System.out.println(i + \",\" + 0);\n      }\n    }\n    System.out.println(\"N input buckets: \" + clusterct);\n    System.out.println(\"Total pairs: \" + matchct);\n    System.out.println(\"Bad pairs: \" + badct);\n    System.out.println(\"N components: \" + componentct);\n\n    System.out.println(\"FP rate: \" + badct * 1.0 / matchct);\n    // String s1 = \"abcedfgh\";\n    // String s2 = \"bcdefg\";\n    // System.out.println(\"distance: \" + EditDistance.dist(s1, s2));\n  }\n"}, {"dataset": "compile", "exampleID": 5969, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 321, "focalAPIEnd": 381, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [399], "useEnd": [422], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.10.2/src/util/xml/XML.java", "rawCode": "  private static void replaceNodeTokens(Text t, String sBorder, Map mReplace) {\n    // Get value and look for tokens. If there aren't any, bail now.\n    String sValue = t.getData();\n    if (mReplace == null || sValue.indexOf(sBorder) == -1) return;\n\n    StringBuffer sbBefore = new StringBuffer();\n\n    Pattern pTokens = Pattern.compile(sBorder + \"(.*?)\" + sBorder, Pattern.DOTALL);\n    Matcher m = pTokens.matcher(sValue);\n    while (m.find()) {\n      String sKey = m.group(1);\n      if (sKey.equals(\"\")) m.appendReplacement(sbBefore, sBorder);\n      else {\n        Node nMatch = (Node) mReplace.get(sKey);\n        if (nMatch == null) m.appendReplacement(sbBefore, sBorder + sKey + sBorder);\n        else {\n          // OK, found a token. Get everything before it into the buffer...\n          m.appendReplacement(sbBefore, \"\");\n          // ...create a new text node with the 'before' text...\n          Text tBefore = t.getOwnerDocument().createTextNode(sbBefore.toString());\n          t.getParentNode().insertBefore(tBefore, t);\n          sbBefore.setLength(0);\n          // ...add the new node...\n          t.getParentNode().insertBefore(t.getOwnerDocument().importNode(nMatch, true), t);\n        }\n      }\n    }\n    m.appendTail(sbBefore);\n    t.setData(sbBefore.toString());\n  }\n"}, {"dataset": "compile", "exampleID": 5970, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 211, "focalAPIEnd": 244, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.engine/tree/master/plugins/org.eclipse.birt.report.engine.emitter.postscript/src/org/eclipse/birt/report/engine/emitter/postscript/PostscriptWriter.java", "rawCode": "  /**\n   * Escape the characters \"(\", \")\", and \"\\\" in a postscript string by \"\\\".\n   *\n   * @param source\n   * @return\n   */\n  private static String escapeSpecialCharacter(String source) {\n    Pattern pattern = Pattern.compile(\"(\\\\\\\\|\\\\)|\\\\()\");\n    Matcher matcher = pattern.matcher(source);\n    StringBuffer buffer = new StringBuffer();\n    while (matcher.find()) {\n      matcher.appendReplacement(buffer, \"\\\\\\\\\\\\\" + matcher.group(1));\n    }\n    matcher.appendTail(buffer);\n    return buffer.toString();\n  }\n"}, {"dataset": "compile", "exampleID": 5971, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 192, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [242], "useEnd": [268], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pgroth/hbase-rdf/tree/master/src/main/java/nl/vu/datalayer/hbase/bulkload/AbstractPrefixMatchBulkLoad.java", "rawCode": "  protected int getChildJVMSize(Configuration conf) {\n    String childOptsString = conf.get(\"mapred.child.java.opts\");\n    System.out.println(\"ChildOpts: \" + childOptsString);\n    Pattern p = Pattern.compile(\"-Xmx([0-9]*)m\");\n    Matcher m = p.matcher(childOptsString);\n    int childJVMSize = 1024;\n    if (m.find()) {\n      childJVMSize = Integer.parseInt(m.group(1));\n    }\n    System.out.println(\"ChildJVM: \" + childJVMSize);\n    return childJVMSize;\n  }\n"}, {"dataset": "compile", "exampleID": 5972, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 380, "tryExpressionEnd": 384, "tryBlockStart": 380, "tryBlockEnd": 736, "catchExpressionStart": 678, "catchExpressionEnd": 698, "catchBlockStart": 678, "catchBlockEnd": 736, "exceptionHandlingCallStart": [708], "exceptionHandlingCallEnd": [727], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 406, "focalAPIEnd": 434, "followUpCheck": "pattern.matcher(s).matches()", "checkType": "IF", "followUpCheckExpressionStart": 549, "followUpCheckExpressionEnd": 616, "followUpCheckBlockStart": 549, "followUpCheckBlockEnd": 659, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tentejswi/PersonalityExtraction/tree/master/src/com/personalityextractor/entity/resolver/ExtractEntities.java", "rawCode": "  public HashSet<String> getEntitiesinTweet(String tweet) {\n    HashSet<String> entities = new HashSet<String>();\n    TwitterTokenizer tweetTokenizer = new TwitterTokenizer();\n    for (String token : tweetTokenizer.tokenize(tweet)) {\n      token = token.trim();\n      token =\n          token.replaceAll(\"( [^a-zA-Z0-9\\\\.]) | ( [^a-zA-Z0-9\\\\.] ) | ([^a-zA-Z0-9\\\\.] )\", \" \");\n      try {\n        Pattern p = Pattern.compile(\"^[A-Z]+.*\");\n        String[] split = token.split(\"\\\\s+\");\n        for (String s : split) {\n          s = s.trim();\n          if (p.matcher(s).matches() && !stopWords.contains(s.toLowerCase())) {\n            entities.add(s);\n          }\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n\n      for (String np : npe.extract(token)) {\n        if (!stopWords.contains(np.trim().toLowerCase())) {\n          entities.add(np.trim());\n        }\n      }\n    }\n    return entities;\n  }\n"}, {"dataset": "compile", "exampleID": 5973, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 743, "focalAPIEnd": 767, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["next(pattern)"], "useStart": [738], "useEnd": [768], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/main/java/java/util/Scanner.java", "rawCode": "  /**\n   * Returns the next token if it matches the specified pattern. The token will be both prefixed and\n   * postfixed by the delimiter that is currently being used (or a string that matches the delimiter\n   * pattern). This method will block if input is being read. Calling this method is equivalent to\n   * {@code next(Pattern.compile(pattern))}.\n   *\n   * @param pattern the string specifying the pattern to scan for.\n   * @return the next token.\n   * @throws IllegalStateException if this {@code Scanner} has been closed.\n   * @throws NoSuchElementException if input has been exhausted.\n   * @throws InputMismatchException if the next token does not match the pattern given.\n   */\n  public String next(String pattern) {\n    return next(Pattern.compile(pattern));\n  }\n"}, {"dataset": "compile", "exampleID": 5974, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 1257, "focalAPIEnd": 1284, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)"], "useStart": [1294, 1499, 1536, 1767, 1804, 2297, 2354], "useEnd": [1311, 1526, 1553, 1794, 1821, 2344, 2371], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta06/kernel-util/src/main/java/org/sakaiproject/util/PasswordCheck.java", "rawCode": "  /**\n   * Compute the strength of the given password and return it as one of the constant values.\n   *\n   * @param passwd - The password string to check\n   * @return strength indication of a password as per constants\n   */\n  public static int getPasswordStrength(String passwd) {\n    int upper = 0, lower = 0, numbers = 0, special = 0, length = 0, strength = 0;\n    Pattern p;\n    Matcher m;\n\n    // null/blank passwords\n    if (StringUtils.isBlank(passwd)) {\n      log.debug(\"Password null\");\n      return NONE;\n    }\n\n    // LENGTH\n    length = passwd.length();\n\n    // length 4 or less\n    if (length < 5) {\n      strength = (strength + 3);\n      log.debug(\"3 points for length (\" + length + \")\");\n    }\n    // length between 5 and 7\n    else if (length > 4 && passwd.length() < 8) {\n      strength = (strength + 6);\n      log.debug(\"6 points for length (\" + length + \")\");\n    }\n    // length between 8 and 15\n    else if (length > 7 && passwd.length() < 16) {\n      strength = (strength + 12);\n      log.debug(\"12 points for length (\" + length + \")\");\n    }\n    // length 16 or more\n    else if (length > 15) {\n      strength = (strength + 18);\n      log.debug(\"18 points for length (\" + length + \")\");\n    }\n\n    // LETTERS\n    // lower case\n    p = Pattern.compile(\".??[a-z]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      lower++;\n    }\n    if (lower > 0) {\n      strength = (strength + 1);\n      log.debug(\"1 point for a lower case character\");\n    }\n\n    // upper case\n    p = Pattern.compile(\".??[A-Z]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      upper++;\n    }\n    if (upper > 0) {\n      strength = (strength + 5);\n      log.debug(\"5 points for an upper case character\");\n    }\n\n    // NUMBERS\n    // at least one number\n    p = Pattern.compile(\".??[0-9]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      numbers += 1;\n    }\n    if (numbers > 0) {\n      strength = (strength + 5);\n      log.debug(\"5 points for a number\");\n      if (numbers > 1) {\n        strength = (strength + 2);\n        log.debug(\"2 points for at least two numbers\");\n\n        if (numbers > 2) {\n          strength = (strength + 3);\n          log.debug(\"3 points for at least three numbers\");\n        }\n      }\n    }\n\n    // SPECIAL CHAR\n    // at least one special char\n    p = Pattern.compile(\".??[:,!,@,#,$,%,^,&,*,?,_,~]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      special += 1;\n    }\n    if (special > 0) {\n      strength = (strength + 5);\n      log.debug(\"5 points for a special character\");\n      if (special > 1) {\n        strength += (strength + 5);\n        log.debug(\"5 points for at least two special characters\");\n      }\n    }\n\n    // COMBOS\n    // both upper and lower case\n    if (upper > 0 && lower > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for upper and lower letters\");\n    }\n    // both letters and numbers\n    if ((upper > 0 || lower > 0) && numbers > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for letters and numbers\");\n    }\n    // letters, numbers, and special characters\n    if ((upper > 0 || lower > 0) && numbers > 0 && special > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for letters, numbers and special chars\");\n    }\n    // upper, lower, numbers, and special characters\n    if (upper > 0 && lower > 0 && numbers > 0 && special > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for upper and lower case letters, numbers and special chars\");\n    }\n    if (strength < 16) {\n      log.debug(\"very weak\");\n      return VERY_WEAK;\n    } else if (strength > 15 && strength < 25) {\n      log.debug(\"weak\");\n      return WEAK;\n    } else if (strength > 24 && strength < 35) {\n      log.debug(\"mediocre\");\n      return MEDIOCRE;\n    } else if (strength > 34 && strength < 45) {\n      log.debug(\"strong\");\n      return STRONG;\n    } else {\n      log.debug(\"very strong\");\n      return VERY_STRONG;\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5975, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 2591, "focalAPIEnd": 2738, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0/kernel-util/src/main/java/org/sakaiproject/util/FormattedText.java", "rawCode": "  static void init() {\n    // DEFAULT values to allow for testing and in case the resource loader values do not exist\n    M_evilTags =\n        \"applet,base,body,bgsound,button,col,colgroup,comment, dfn,fieldset,form,frame,frameset,head,html,iframe,ilayer,inlineinput,isindex,input,keygen,label,layer,legend,link,listing,map,meta,multicol,nextid,noframes,nolayer,noscript,optgroup,option,plaintext,script,select,sound,spacer,spell,submit,textarea,title,wbr\"\n            .split(\",\");\n    M_goodTags =\n        \"a,abbr,acronym,address,b,big,blockquote,br,center,cite,code,dd,del,dir,div,dl,dt,em,font,hr,h1,h2,h3,h4,h5,h6,i,ins,kbd,li,marquee,menu,nobr,noembed,ol,p,pre,q,rt,ruby,rbc,rb,rtc,rp,s,samp,small,span,strike,strong,sub,sup,tt,u,ul,var,xmp,img,embed,object,table,tr,td,th,tbody,caption,thead,tfoot,colgroup,col,param\"\n            .split(\",\");\n    M_goodAttributes =\n        \"abbr,accept,accesskey,align,alink,alt,axis,background,bgcolor,border,cellpadding,cellspacing,char,charoff,charset,checked,cite,class,classid,clear,color,cols,colspan,compact,content,coords,datetime,dir,disabled,enctype,face,for,header,height,href,hreflang,hspace,id,ismap,label,lang,longdesc,maxlength,multiple,name,noshade,nowrap,profile,readonly,rel,rev,rows,rowspan,rules,scope,selected,shape,size,span,src,start,style,summary,tabindex,target,text,title,type,usemap,valign,value,vlink,vspace,width,pluginspage,play,loop,menu,codebase,data,pluginspace,wmode,allowscriptaccess,allowfullscreen\"\n            .split(\",\");\n    M_evilValues = \"javascript:,behavior:,vbscript:,mocha:,livescript:,expression\".split(\",\");\n\n    try {\n      ResourceLoader properties =\n          new ResourceLoader(\n              RESOURCE_BUNDLE, ComponentManager.get(RESOURCE_CLASS).getClass().getClassLoader());\n      M_evilTags = properties.getString(\"evilTags\").split(\",\");\n      M_goodTags = properties.getString(\"goodTags\").split(\",\");\n      M_goodAttributes = properties.getString(\"goodAttributes\").split(\",\");\n      M_evilValues = properties.getString(\"evilValues\").split(\",\");\n    } catch (Exception e) {\n      // this is a failure and cannot really be recovered from\n      M_log.error(\"Error collecting formattedtext.properties (using defaults)\", e);\n    }\n\n    M_evilTagsPatterns = new Pattern[M_evilTags.length];\n    for (int i = 0; i < M_evilTags.length; i++) {\n      // matches the start of the particular evil tag \"<\" followed by whitespace,\n      // followed by the tag name, followed by anything, followed by \">\", case insensitive,\n      // allowed to match over multiple lines.\n      M_evilTagsPatterns[i] =\n          Pattern.compile(\n              \".*<\\\\s*\" + M_evilTags[i] + \".*>.*\",\n              Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.DOTALL);\n    }\n\n    M_goodTagsPatterns = new Pattern[M_goodTags.length];\n    M_goodCloseTagsPatterns = new Pattern[M_goodTags.length];\n    for (int i = 0; i < M_goodTags.length; i++) {\n      // matches the start of the particular good tag \"<\" followed by whitespace,\n      // followed by the tag name, followed by anything, followed by \">\", case insensitive,\n      // allowed to match over multiple lines.\n      M_goodTagsPatterns[i] =\n          Pattern.compile(\n              \".*<\\\\s*\" + M_goodTags[i] + \"(\\\\s+.*>|>|/>).*\",\n              Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.DOTALL);\n      M_goodCloseTagsPatterns[i] =\n          Pattern.compile(\n              \"<\\\\s*/\\\\s*\" + M_goodTags[i] + \"(\\\\s.*>|>)\",\n              Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.DOTALL);\n    }\n\n    M_goodAttributePatterns = new Pattern[M_goodAttributes.length];\n    for (int i = 0; i < M_goodAttributes.length; i++) {\n      M_goodAttributePatterns[i] =\n          Pattern.compile(\n              \"\\\\s+\" + M_goodAttributes[i] + \"(\\\\s*=\\\\s*(?:\\\".*?\\\"|'.*?'|[^'\\\">\\\\s]+))\",\n              Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.DOTALL);\n    }\n\n    M_evilValuePatterns = new Pattern[M_evilValues.length];\n    String pads = \"(\\\\s)*?(?:/\\\\*.*\\\\*/|<!--.*-->|\\0|)*?(\\\\s)*?\";\n    for (int i = 0; i < M_evilValues.length; i++) {\n      StringBuilder complexPattern = new StringBuilder();\n      complexPattern.append(\"\\\\s*\");\n      String value = M_evilValues[i];\n      for (int j = 0; j < value.length(); j++) {\n        complexPattern.append(value.charAt(j));\n        complexPattern.append(pads);\n      }\n      M_evilValuePatterns[i] =\n          Pattern.compile(\n              complexPattern.toString(),\n              Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.DOTALL);\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5976, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 270, "focalAPIEnd": 291, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["regex(pattern)"], "useStart": [151], "useEnd": [292], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Gigaspaces/mongo-datasource/tree/master/src/test/java/com/gigaspaces/persistency/qa/utest/parser/SQL2MongoBaseVisitorTest.java", "rawCode": "  @Test\n  public void testSimpleAnd() {\n    DBObject actual = parse(\"number is NOT null AND name like ?\").getQuery();\n\n    DBObject expected =\n        QueryBuilder.start()\n            .and(\"number\")\n            .exists(false)\n            .and(\"name\")\n            .regex(Pattern.compile(LIKE))\n            .get();\n\n    assertEquals(expected, actual);\n  }\n"}, {"dataset": "compile", "exampleID": 5977, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 1430, "focalAPIEnd": 1455, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["useDelimiter(pattern)"], "useStart": [1394], "useEnd": [1456], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/marbiaz/WhatUsersWant/tree/master/wuw/pi/BT/BitTorrentStatistics.java", "rawCode": "  /**\n   * Decode a string Python representation of transactions into an array of {@code Transaction}\n   * objects\n   *\n   * @param value Set of transactions represented in a string\n   * @param size Number of transactions\n   * @param ip IP address of the BitTorrent peer related with these transactions\n   * @param port Port number of the BitTorrent peer related with these transactions\n   * @return Array of {@code Transaction} objects\n   */\n  Transaction[] decodeTransactions(String value, int size, String ip) {\n    String tranRegExpr =\n        \"\\\\[(\\\\((((\\\\d)*\\\\.(\\\\d)*|\\\\'[A-Z]*\\\\'|(\\\\d)*)\\\\,\\\\s)*((\\\\d)*\"\n            + \"\\\\.(\\\\d)*|\\\\'[A-Z]*\\\\'|(\\\\d)*)\\\\)\\\\,\\\\s)*\\\\((((\\\\d)*\\\\.(\\\\d)*|\\\\'[A-Z]*\\\\'\"\n            + \"|(\\\\d)*)\\\\,\\\\s)*((\\\\d)*\\\\.(\\\\d)*|\\\\'[A-Z]*\\\\'|(\\\\d)*)\\\\)\\\\]\";\n    if (!value.matches(tranRegExpr)) {\n      System.err.println(\"ERROR :: Set of transactions has not the right format\");\n      return new Transaction[0];\n    }\n    Transaction[] transactions = new Transaction[size];\n    int i = 0;\n    int j;\n    Scanner decoder = new Scanner(value).useDelimiter(\"\\\\[\\\\(|\\\\)\\\\,\\\\s\\\\(|\\\\)\\\\]\");\n    String str4tuple, item;\n    Scanner tupleDecoder;\n    String state = null;\n    String type = null;\n    String key;\n    int pieceNumber = -1;\n    // float kBprovided = -1.0f;\n    Transaction tran;\n    while (decoder.hasNext()) {\n      str4tuple = decoder.next();\n      tupleDecoder = new Scanner(str4tuple).useDelimiter(Pattern.compile(\"\\\\,\\\\s\"));\n      j = 0;\n      while (tupleDecoder.hasNext()) {\n        item = tupleDecoder.next();\n        switch (j) {\n          case 0:\n            state = item;\n            break;\n          case 1:\n            type = item;\n            break;\n          case 2:\n            pieceNumber = Integer.valueOf(item);\n            break;\n          case 3:\n            // kBprovided = Float.valueOf(item);\n            break;\n          default:\n            System.out.println(\"This tuple has a not expected value\");\n            System.exit(1);\n        }\n        j++;\n      }\n      tupleDecoder.close();\n      tran = new Transaction();\n      tran.setState(identifyTransactionState(state));\n      tran.setType(identifyTransactionType(type));\n      tran.setItem(pieceNumber);\n      key = ip;\n      tran.setRemote(new PeerID(ip, wuwPorts.get(key)));\n      // tran.setkBprovided(kBprovided);\n      transactions[i] = tran;\n      i++;\n    }\n    decoder.close();\n    return transactions;\n  }\n"}, {"dataset": "compile", "exampleID": 5978, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 515, "focalAPIEnd": 551, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/org/oryxeditor/server/ServiceComposerServlet.java", "rawCode": "  private String generateJsonForStencilSetExtension(\n      String extensionName, ArrayList<Service> services) {\n    ArrayList<String> colors = new ArrayList<String>();\n    colors.add(\"#eefecc\"); // green\n    colors.add(\"#cce5fe\"); // light blue\n    colors.add(\"#e5ccfe\"); // purple\n    colors.add(\"#ccccfe\"); // dark blue\n    // colors.add(\"#ffeecc\"); // red\n    // colors.add(\"#ffffcc\"); // original yellow of BPMN stencil set\n    ListIterator<String> colorIterator = colors.listIterator();\n\n    Pattern pattern = Pattern.compile(\"([a-z])([A-Z0-9])\");\n\n    StringBuffer stencilsForOperations = new StringBuffer();\n    ListIterator<Service> serviceIterator = services.listIterator();\n    while (serviceIterator.hasNext()) {\n      Service service = serviceIterator.next();\n      if (!colorIterator.hasNext()) {\n        colorIterator = colors.listIterator();\n      }\n\n      String color = colorIterator.next();\n\n      ListIterator<PortType> portTypeIterator = service.portTypes.listIterator();\n      while (portTypeIterator.hasNext()) {\n        PortType portType = portTypeIterator.next();\n        ListIterator<Operation> operationIterator = portType.operations.listIterator();\n\n        while (operationIterator.hasNext()) {\n          Operation operation = operationIterator.next();\n          Matcher matcher = pattern.matcher(operation.name);\n          String taskName = matcher.replaceAll(\"$1 $2\");\n          String xform = \"\";\n          if (!operation.uiUrls.isEmpty()) {\n            xform = operation.uiUrls.get(0);\n          }\n          stencilsForOperations.append(\n              \"{\"\n                  + \"\\\"type\\\": \\\"node\\\",\"\n                  + \"\\\"id\\\":\\\"\"\n                  + createJsonId(portType.name + \"-\" + operation.name)\n                  + \"\\\",\"\n                  + \"\\\"superId\\\":\\\"Task\\\",\"\n                  + \"\\\"title\\\":\\\"\"\n                  + taskName\n                  + \"\\\",\"\n                  + \"\\\"groups\\\":[\\\"Activities\\\"],\" // The group 'Service Operations' appears too far\n                                                   // on the bottom of the menu\n                  + \"\\\"description\\\":\\\"An invocation of operation '\"\n                  + operation.name\n                  + \"' of port type '\"\n                  + portType.name\n                  + \"' of the service described in '\"\n                  + service.wsdlUrl\n                  + \"'.\\\",\"\n                  + \"\\\"view\\\":\\\"activity/node.task.svg\\\",\"\n                  + \"\\\"icon\\\":\\\"new_task.png\\\",\"\n                  + \"\\\"roles\\\": [\\\"sequence_start\\\",\\\"sequence_end\\\",\\\"messageflow_start\\\", \\\"messageflow_end\\\",\\\"to_task_event\\\",\\\"from_task_event\\\",\\\"conditional_start\\\",\\\"default_start\\\", \\\"tc\\\", \\\"fromtoall\\\" ],\"\n                  + \"\\\"properties\\\": [ \"\n                  + \"{\\\"id\\\":\\\"name\\\",\\\"value\\\":\\\"\"\n                  + taskName\n                  + \"\\\" }, \"\n                  + \"{\\\"id\\\":\\\"xform\\\",\\\"value\\\":\\\"\"\n                  // TODO: list of values from which the user can choose\n                  + xform\n                  + \"\\\" }, \"\n                  + \"{\\\"id\\\":\\\"bgColor\\\",\\\"value\\\":\\\"\"\n                  + color\n                  + \"\\\"}\"\n                  + \" ]},\\n\");\n        }\n      }\n    }\n\n    return \"{\\\"title\\\":\\\"\"\n        + extensionName\n        + \"\\\",\"\n        + \"\\\"namespace\\\":\\\"\"\n        + getStencilSetExtensionNamespace(extensionName)\n        + \"\\\",\"\n        + \"\\\"description\\\":\\\"\"\n        + getStencilSetExtensionDescription(extensionName, services)\n        + \"\\\",\"\n        + \"\\\"extends\\\":\\\"\"\n        + BASE_STENCILSET\n        + \"\\\",\"\n        + \"\\\"stencils\\\":[\\n\"\n        + stencilsForOperations.toString()\n        + \"],\"\n        + \"\\\"properties\\\":[],\"\n        + \"\\\"rules\\\": {\\\"connectionRules\\\": [],\\\"cardinalityRules\\\": [],\\\"containmentRules\\\": []},\\\"removestencils\\\": [],\\\"removeproperties\\\": []}\";\n  }\n"}, {"dataset": "compile", "exampleID": 5979, "initialization": ["String regex = String.substring(int)"], "initializationStart": [664], "initializationEnd": [681], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["regex.substring(int,int)", "regex.substring(int)"], "configurationStart": [603, 664], "configurationEnd": [623, 681], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 699, "focalAPIEnd": 720, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(pattern)", "pattern.compile(String)", "add(pattern)"], "useStart": [691, 939, 931], "useEnd": [721, 960, 961], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.11/kernel-util/src/main/java/org/sakaiproject/util/BasicAuth.java", "rawCode": "  /**\n   * Initialise the patterns, since some of the spring stuf may not be up when the bean is created,\n   * this is here to make certain that init is performed when spring is ready\n   */\n  public void init() {\n    ArrayList pat = new ArrayList();\n    ArrayList mat = new ArrayList();\n    String[] morepatterns = null;\n    try {\n      morepatterns = ServerConfigurationService.getStrings(\"login.browser.user.agent\");\n    } catch (Exception ex) {\n\n    }\n    if (morepatterns != null) {\n      for (int i = 0; i < morepatterns.length; i++) {\n        String line = morepatterns[i];\n        String check = line.substring(0, 1);\n        mat.add(check);\n        line = line.substring(1);\n        pat.add(Pattern.compile(line));\n      }\n    }\n    for (int i = 0; i < matchPatterns.length; i++) {\n      String line = matchPatterns[i];\n      String check = line.substring(0, 1);\n      mat.add(check);\n      line = line.substring(1);\n      pat.add(Pattern.compile(line));\n    }\n\n    patterns = new Pattern[pat.size()];\n    patterns = (Pattern[]) pat.toArray(patterns);\n    match = new String[mat.size()];\n    match = (String[]) mat.toArray(match);\n  }\n"}, {"dataset": "compile", "exampleID": 5980, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 928, "focalAPIEnd": 950, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pgorla/usergrid/tree/master/core/src/main/java/org/usergrid/utils/Inflector.java", "rawCode": "  /**\n   * Utility method to replace all occurrences given by the specific backreference with its\n   * uppercased form, and remove all other backreferences.\n   *\n   * <p>The Java {@link Pattern regular expression processing} does not use the preprocessing\n   * directives <code>\\l</code>, <code>&#92;u</code>, <code>\\L</code>, and <code>\\U</code>. If so,\n   * such directives could be used in the replacement string to uppercase or lowercase the\n   * backreferences. For example, <code>\\L1</code> would lowercase the first backreference, and\n   * <code>&#92;u3</code> would uppercase the 3rd backreference.\n   *\n   * @param input\n   * @param regex\n   * @param groupNumberToUppercase\n   * @return the input string with the appropriate characters converted to upper-case\n   */\n  protected static String replaceAllWithUppercase(\n      String input, String regex, int groupNumberToUppercase) {\n    Pattern underscoreAndDotPattern = Pattern.compile(regex);\n    Matcher matcher = underscoreAndDotPattern.matcher(input);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) {\n      matcher.appendReplacement(sb, matcher.group(groupNumberToUppercase).toUpperCase());\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n  }\n"}, {"dataset": "compile", "exampleID": 5981, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 1011, "focalAPIEnd": 1042, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [1352], "useEnd": [1379], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/knutwalker/google-closure-compiler/tree/master/lib/rhino/src/org/mozilla/javascript/RhinoException.java", "rawCode": "  /**\n   * Get the script stack of this exception as an array of {@link ScriptStackElement}s. If\n   * optimization is enabled, this includes java stack elements whose source and method names\n   * suggest they have been generated by the Rhino script compiler.\n   *\n   * @return the script stack for this exception\n   * @since 1.7R3\n   */\n  public ScriptStackElement[] getScriptStack() {\n    List<ScriptStackElement> list = new ArrayList<ScriptStackElement>();\n    ScriptStackElement[][] interpreterStack = null;\n    if (interpreterStackInfo != null) {\n      Evaluator interpreter = Context.createInterpreter();\n      if (interpreter instanceof Interpreter)\n        interpreterStack = ((Interpreter) interpreter).getScriptStackElements(this);\n    }\n    int interpreterStackIndex = 0;\n    StackTraceElement[] stack = getStackTrace();\n    // Pattern to recover function name from java method name -\n    // see Codegen.getBodyMethodName()\n    // kudos to Marc Guillemot for coming up with this\n    Pattern pattern = Pattern.compile(\"_c_(.*)_\\\\d+\");\n    for (StackTraceElement e : stack) {\n      String fileName = e.getFileName();\n      if (e.getMethodName().startsWith(\"_c_\")\n          && e.getLineNumber() > -1\n          && fileName != null\n          && !fileName.endsWith(\".java\")) {\n        String methodName = e.getMethodName();\n        Matcher match = pattern.matcher(methodName);\n        // the method representing the main script is always \"_c_script_0\" -\n        // at least we hope so\n        methodName = !\"_c_script_0\".equals(methodName) && match.find() ? match.group(1) : null;\n        list.add(new ScriptStackElement(fileName, methodName, e.getLineNumber()));\n      } else if (\"org.mozilla.javascript.Interpreter\".equals(e.getClassName())\n          && \"interpretLoop\".equals(e.getMethodName())\n          && interpreterStack != null\n          && interpreterStack.length > interpreterStackIndex) {\n        for (ScriptStackElement elem : interpreterStack[interpreterStackIndex++]) {\n          list.add(elem);\n        }\n      }\n    }\n    return list.toArray(new ScriptStackElement[list.size()]);\n  }\n"}, {"dataset": "compile", "exampleID": 5982, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 581, "focalAPIEnd": 604, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)"], "useStart": [649, 838, 906, 1065, 1137, 1243, 1313, 1474, 1546], "useEnd": [804, 861, 1031, 1088, 1208, 1267, 1438, 1499, 1697], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/davidcox66/scriptbox/tree/master/panopticon/common/src/main/java/org/scriptbox/panopticon/top/TopPlugin.java", "rawCode": "  public void top(int delay) {\n    /*\n    Tasks: 72 total, 1 running, 71 sleeping, 0 stopped, 0 zombie\n    Cpu(s): 0.1%us, 0.0%sy, 0.0%ni, 99.8%id, 0.1%wa, 0.0%hi, 0.0%si, 0.0%st\n    Mem: 7652552k total, 4558156k used, 3094396k free, 83496k buffers\n    Swap: 0k total, 0k used, 0k free, 208860k cached\n    */\n\n    /*\n    us = user mode\n    sy = system mode\n    ni = low priority user mode (nice)\n    id = idle task\n    wa = I/O waiting\n    hi = servicing IRQs\n    si = servicing soft IRQs\n    st = steal (time given to other DomU instances)\n\n    */\n\n    final Pattern cpuPattern = Pattern.compile(\"^Cpu\");\n    final Pattern cpuLinePattern =\n        Pattern.compile(\n            \"^Cpu.*:\\\\s+(\\\\S+)%us,\\\\s+(\\\\S+)%sy,\\\\s+(\\\\S+)%ni,\\\\s+(\\\\S+)%id,\\\\s+(\\\\S+)%wa,\\\\s+(\\\\S+)%hi,\\\\s+(\\\\S+)%si,\\\\s+(\\\\S+)%st\\\\s*$\");\n\n    final Pattern memPattern = Pattern.compile(\"^Mem\");\n    final Pattern memLinePattern =\n        Pattern.compile(\n            \"^Mem:\\\\s+(\\\\d+)k\\\\s+total,\\\\s+(\\\\d+)k\\\\s+used,\\\\s+(\\\\d+)k\\\\s+free,\\\\s+(\\\\d+)k\\\\s+buffers\\\\s*$\");\n\n    final Pattern topPattern = Pattern.compile(\"^top\");\n    final Pattern loadAveragePattern =\n        Pattern.compile(\".*load average:\\\\s+(\\\\S+),\\\\s+(\\\\S+),\\\\s+(\\\\S+)\\\\s*$\");\n\n    final Pattern swapPattern = Pattern.compile(\"^Swap\");\n    final Pattern swapLinePattern =\n        Pattern.compile(\n            \"^Swap:\\\\s+(\\\\d+)k\\\\s+total,\\\\s+(\\\\d+)k\\\\s+used,\\\\s+(\\\\d+)k\\\\s+free,\\\\s+(\\\\d+)k\\\\s+cached\\\\s*$\");\n\n    final Pattern tasksPattern = Pattern.compile(\"^Tasks\");\n    final Pattern tasksLinePattern =\n        Pattern.compile(\n            \"^Tasks:\\\\s+(\\\\d+)\\\\s+total,\\\\s+(\\\\d+)\\\\s+running,\\\\s+(\\\\d+)\\\\s+sleeping,\\\\s+(\\\\d+)\\\\s+stopped,\\\\s+(\\\\d+)\\\\s+zombie\\\\s*$\");\n\n    List<String> args = new ArrayList<String>();\n    args.add(\"top\");\n    args.add(\"-b\");\n    args.add(\"-d\");\n    args.add(\"\" + delay);\n\n    BasicSystemExecRunnable runnable =\n        new BasicSystemExecRunnable(args) {\n          public boolean eachLine(String line, int lineNumber) throws Exception {\n\n            if (LOGGER.isTraceEnabled()) {\n              LOGGER.trace(\"parse: processing line: \" + line);\n            }\n            try {\n              if (cpuPattern.matcher(line).find()) {\n                /*\n                 * Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.8%id, 0.0%wa,\n                 * 0.0%hi, 0.0%si, 0.0%st\n                 */\n                if (LOGGER.isDebugEnabled()) {\n                  LOGGER.debug(\"parse: found cpu line: \" + line);\n                }\n                Matcher cpuLineMatcher = cpuLinePattern.matcher(line);\n                if (cpuLineMatcher.matches()) {\n                  int i = 1;\n                  store(\"cpu\", \"userMode\", cpuLineMatcher.group(i++));\n                  store(\"cpu\", \"systemMode\", cpuLineMatcher.group(i++));\n                  store(\"cpu\", \"lowPriorityUserMode\", cpuLineMatcher.group(i++));\n                  store(\"cpu\", \"idleTask\", cpuLineMatcher.group(i++));\n                  store(\"cpu\", \"ioWaiting\", cpuLineMatcher.group(i++));\n                  store(\"cpu\", \"serviceIrqs\", cpuLineMatcher.group(i++));\n                  store(\"cpu\", \"serviceSoftIrqs\", cpuLineMatcher.group(i++));\n                  store(\"cpu\", \"stealTime\", cpuLineMatcher.group(i++));\n                }\n              } else if (memPattern.matcher(line).find()) {\n                /*\n                 * Mem: 7652552k total, 5809296k used, 1843256k free,\n                 * 143452k buffers\n                 */\n                if (LOGGER.isDebugEnabled()) {\n                  LOGGER.debug(\"parse: found mem line: \" + line);\n                }\n                Matcher memLineMatcher = memLinePattern.matcher(line);\n                if (memLineMatcher.matches()) {\n                  int i = 1;\n                  store(\"memory\", \"total\", memLineMatcher.group(i++));\n                  store(\"memory\", \"used\", memLineMatcher.group(i++));\n                  store(\"memory\", \"free\", memLineMatcher.group(i++));\n                  store(\"memory\", \"buffers\", memLineMatcher.group(i++));\n                }\n              } else if (topPattern.matcher(line).find()) {\n                /*\n                 * top - 10:52:52 up 9 days, 22:00, 3 users, load\n                 * average: 0.08, 0.10, 0.07\n                 */\n                Matcher loadAverageMatcher = loadAveragePattern.matcher(line);\n                if (loadAverageMatcher.matches()) {\n                  int i = 1;\n                  store(\"load\", \"minutes1\", loadAverageMatcher.group(i++));\n                  store(\"load\", \"minutes5\", loadAverageMatcher.group(i++));\n                  store(\"load\", \"minutes15\", loadAverageMatcher.group(i++));\n                }\n              } else if (swapPattern.matcher(line).find()) {\n                /*\n                 * Swap: 0k total, 0k used, 0k free, 382504k cached\n                 */\n                Matcher swapLineMatcher = swapLinePattern.matcher(line);\n                if (swapLineMatcher.matches()) {\n                  int i = 1;\n                  store(\"swap\", \"total\", swapLineMatcher.group(i++));\n                  store(\"swap\", \"used\", swapLineMatcher.group(i++));\n                  store(\"swap\", \"free\", swapLineMatcher.group(i++));\n                  store(\"swap\", \"cached\", swapLineMatcher.group(i++));\n                }\n              } else if (tasksPattern.matcher(line).find()) {\n                /*\n                 * Tasks: 80 total, 1 running, 79 sleeping, 0 stopped, 0\n                 * zombie\n                 */\n                Matcher tasksLineMatcher = tasksLinePattern.matcher(line);\n                if (tasksLineMatcher.matches()) {\n                  int i = 1;\n                  store(\"tasks\", \"total\", tasksLineMatcher.group(i++));\n                  store(\"tasks\", \"running\", tasksLineMatcher.group(i++));\n                  store(\"tasks\", \"sleeping\", tasksLineMatcher.group(i++));\n                  store(\"tasks\", \"stopped\", tasksLineMatcher.group(i++));\n                  store(\"tasks\", \"zombie\", tasksLineMatcher.group(i++));\n                }\n              }\n            } finally {\n              store.flush();\n            }\n            LOGGER.debug(\"parse: finished reading output\");\n            return true;\n          }\n        };\n    ExecBlock<ExecRunnable> container = ExecContext.getEnclosing(ExecBlock.class);\n    container.add(runnable);\n\n    // Add this as a BoxServiceListener to get notification of stopping and\n    // shutdown\n    BoxContext.getCurrentContext().getBeans().put(runnable.toString(), runnable);\n  }\n"}, {"dataset": "compile", "exampleID": 5983, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 617, "focalAPIEnd": 677, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)"], "useStart": [766], "useEnd": [802], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SeekingFor/jfniki/tree/master/alien/src/name/fraser/neil/plaintext/diff_match_patch.java", "rawCode": "  /**\n   * Parse a textual representation of patches and return a List of Patch objects.\n   *\n   * @param textline Text representation of patches.\n   * @return List of Patch objects.\n   * @throws IllegalArgumentException If invalid input.\n   */\n  public List<Patch> patch_fromText(String textline) throws IllegalArgumentException {\n    List<Patch> patches = new LinkedList<Patch>();\n    if (textline.length() == 0) {\n      return patches;\n    }\n    List<String> textList = Arrays.asList(textline.split(\"\\n\"));\n    LinkedList<String> text = new LinkedList<String>(textList);\n    Patch patch;\n    Pattern patchHeader = Pattern.compile(\"^@@ -(\\\\d+),?(\\\\d*) \\\\+(\\\\d+),?(\\\\d*) @@$\");\n    Matcher m;\n    char sign;\n    String line;\n    while (!text.isEmpty()) {\n      m = patchHeader.matcher(text.getFirst());\n      if (!m.matches()) {\n        throw new IllegalArgumentException(\"Invalid patch string: \" + text.getFirst());\n      }\n      patch = new Patch();\n      patches.add(patch);\n      patch.start1 = Integer.parseInt(m.group(1));\n      if (m.group(2).length() == 0) {\n        patch.start1--;\n        patch.length1 = 1;\n      } else if (m.group(2).equals(\"0\")) {\n        patch.length1 = 0;\n      } else {\n        patch.start1--;\n        patch.length1 = Integer.parseInt(m.group(2));\n      }\n\n      patch.start2 = Integer.parseInt(m.group(3));\n      if (m.group(4).length() == 0) {\n        patch.start2--;\n        patch.length2 = 1;\n      } else if (m.group(4).equals(\"0\")) {\n        patch.length2 = 0;\n      } else {\n        patch.start2--;\n        patch.length2 = Integer.parseInt(m.group(4));\n      }\n      text.removeFirst();\n\n      while (!text.isEmpty()) {\n        try {\n          sign = text.getFirst().charAt(0);\n        } catch (IndexOutOfBoundsException e) {\n          // Blank line? Whatever.\n          text.removeFirst();\n          continue;\n        }\n        line = text.getFirst().substring(1);\n        line = line.replace(\"+\", \"%2B\"); // decode would change all \"+\" to \" \"\n        try {\n          line = URLDecoder.decode(line, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n          // Not likely on modern system.\n          throw new Error(\"This system does not support UTF-8.\", e);\n        } catch (IllegalArgumentException e) {\n          // Malformed URI sequence.\n          throw new IllegalArgumentException(\"Illegal escape in patch_fromText: \" + line, e);\n        }\n        if (sign == '-') {\n          // Deletion.\n          patch.diffs.add(new Diff(Operation.DELETE, line));\n        } else if (sign == '+') {\n          // Insertion.\n          patch.diffs.add(new Diff(Operation.INSERT, line));\n        } else if (sign == ' ') {\n          // Minor equality.\n          patch.diffs.add(new Diff(Operation.EQUAL, line));\n        } else if (sign == '@') {\n          // Start of next patch.\n          break;\n        } else {\n          // WTF?\n          throw new IllegalArgumentException(\"Invalid patch mode '\" + sign + \"' in: \" + line);\n        }\n        text.removeFirst();\n      }\n    }\n    return patches;\n  }\n"}, {"dataset": "compile", "exampleID": 5984, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 615, "focalAPIEnd": 636, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/and146/SPLAT-ARI/tree/master/ttools/src/main/uk/ac/starlink/ttools/votlint/VotLintContentHandler.java", "rawCode": "  /**\n   * Returns a pattern which matches a namespace-qualified XML name. It contains two groups, the\n   * first giving the prefix and the second giving the localName.\n   *\n   * @param XML name pattern\n   */\n  private static Pattern getNamespaceNamePattern() {\n    String charPat = \"\\\\p{Lu}\\\\p{Ll}_\";\n    String startCharPat = charPat + \"0-9\\\\-\\\\.\";\n    String pats =\n        \".*?\"\n            + \"([\"\n            + startCharPat\n            + \"]\"\n            + \"[\"\n            + charPat\n            + \"]*\"\n            + \"):(\"\n            + \"[\"\n            + charPat\n            + \"]+\"\n            + \")\";\n    return Pattern.compile(pats);\n  }\n"}, {"dataset": "compile", "exampleID": 5985, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 775, "focalAPIEnd": 801, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new FastaIndexer(RAF,BioStore,pattern,int)"], "useStart": [740], "useEnd": [805], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/biojava/biojava-legacy/tree/master/core/src/main/java/org/biojava/bio/program/unigene/FlatFileUnigeneFactory.java", "rawCode": "  private void indexUnique(File unigeneDir) throws BioException, IOException {\n    File uniqueIndex = new File(unigeneDir, UNIQUE_INDEX);\n    BioStoreFactory uniqueBSF = new BioStoreFactory();\n    uniqueBSF.setStoreLocation(uniqueIndex);\n    uniqueBSF.setPrimaryKey(\"ID\");\n    uniqueBSF.addKey(\"ID\", 10);\n    BioStore uniqueStore = uniqueBSF.createBioStore();\n    File[] uniqueFiles =\n        unigeneDir.listFiles(\n            new FileFilter() {\n              public boolean accept(File pathName) {\n                return pathName.getName().endsWith(\".seq.uniq\");\n              }\n            });\n    for (int i = 0; i < uniqueFiles.length; i++) {\n      File f = uniqueFiles[i];\n      RAF raf = new RAF(f, \"r\");\n      FastaIndexer indexer = new FastaIndexer(raf, uniqueStore, Pattern.compile(\"#(\\\\S+)\"), 1);\n      FastaFormat format = new FastaFormat();\n      SymbolTokenization tok = DNATools.getDNA().getTokenization(\"token\");\n      StreamReader sreader = new StreamReader(indexer.getReader(), format, tok, indexer);\n      while (sreader.hasNext()) {\n        sreader.nextSequence();\n      }\n    }\n    try {\n      uniqueStore.commit();\n    } catch (CommitFailure ne) {\n      throw new BioException(ne);\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5986, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 664, "focalAPIEnd": 705, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["replacePath(Html,pattern,String)"], "useStart": [758], "useEnd": [819], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nabedge/mixer2-sample/tree/master/mixer2-fruitshop-springboot/src/main/java/org/mixer2/sample/web/view/IndexView.java", "rawCode": "  @Override\n  protected Html renderHtml(\n      Html html,\n      Map<String, Object> model,\n      HttpServletRequest request,\n      HttpServletResponse response) {\n\n    // get data from model\n    @SuppressWarnings(\"unchecked\")\n    List<Category> categoryList = (List<Category>) model.get(\"categoryList\");\n    @SuppressWarnings(\"unchecked\")\n    List<Item> oneItemByOneCategory = (List<Item>) model.get(\"oneItemByOneCategory\");\n\n    // embed category list on side bar\n    SectionHelper.rewriteSideBar(html, categoryList);\n\n    // embed category Box on content\n    replaceCategoryBox(html, oneItemByOneCategory);\n\n    // replace static file path\n    Pattern pattern = Pattern.compile(\"^\\\\.+/.*m2static/(.*)$\");\n    String ctx = RequestUtil.getContextPath();\n    PathAdjuster.replacePath(html, pattern, ctx + \"/m2static/$1\");\n\n    // header,footer\n    SectionHelper.rewriteHeader(html);\n    SectionHelper.rewiteFooter(html);\n\n    return html;\n  }\n"}, {"dataset": "compile", "exampleID": 5987, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 566, "focalAPIEnd": 595, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NLeSC/vbrowser/tree/master/source/nl.esciencecenter.vlet.gui.vbrowser/src/nl/esciencecenter/vlet/gui/viewers/ImageViewer.java", "rawCode": "  /**\n   * // @Overide update&paint methods for speed: public void update(Graphics g) {\n   * //this.setSize(imagePane.getSize()); //this.setPreferredSize(imagePane.getSize());\n   * imagePane.paint(g); }\n   *\n   * <p>public void paint(Graphics g) { imagePane.paint(g); }\n   */\n  public Vector<ActionMenuMapping> getActionMappings() {\n    ActionMenuMapping mapping = new ActionMenuMapping(\"viewImage\", \"View Image\");\n    // '/' is not a RE character\n    Pattern patterns[] = new Pattern[mimeTypes.length];\n\n    for (int i = 0; i < mimeTypes.length; i++) patterns[i] = Pattern.compile(mimeTypes[i]);\n\n    mapping.addMimeTypeMapping(patterns);\n\n    Vector<ActionMenuMapping> mappings = new Vector<ActionMenuMapping>();\n    mappings.add(mapping);\n    return mappings;\n  }\n"}, {"dataset": "compile", "exampleID": 5988, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 104, "focalAPIEnd": 132, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Reflections.getResources(pattern)"], "useStart": [166], "useEnd": [199], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anathema/anathema/tree/master/Platform/src/main/java/net/sf/anathema/framework/environment/dependencies/DefaultAnathemaReflections.java", "rawCode": "  @Override\n  public Set<ResourceFile> getResourcesMatching(String namePattern) {\n    Pattern pattern = Pattern.compile(namePattern);\n    return newHashSet(transform(reflections.getResources(pattern), new ToResource()));\n  }\n"}, {"dataset": "compile", "exampleID": 5989, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 76, "focalAPIEnd": 107, "followUpCheck": "pattern.matches()", "checkType": "IF", "followUpCheckExpressionStart": 132, "followUpCheckExpressionEnd": 154, "followUpCheckBlockStart": 132, "followUpCheckBlockEnd": 196, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/black-knight/Q-Cumberless-Testing/tree/master/example/calabash-android-plugin/src/java/com/trollsahead/qcumberless/device/calabash/InteractiveDesigner.java", "rawCode": "        private void checkStarted(String log) {\n          Matcher matcher = Pattern.compile(\".*Started!.*\").matcher(log);\n          if (matcher.matches()) {\n            started = true;\n          }\n        }\n"}, {"dataset": "compile", "exampleID": 5990, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 105, "tryExpressionEnd": 109, "tryBlockStart": 105, "tryBlockEnd": 1452, "catchExpressionStart": 1396, "catchExpressionEnd": 1418, "catchBlockStart": 1396, "catchBlockEnd": 1452, "exceptionHandlingCallStart": [1426], "exceptionHandlingCallEnd": [1445], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 494, "focalAPIEnd": 530, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.compile(String)", "pattern.compile(String)"], "useStart": [861, 1039], "useEnd": [902, 1087], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cnfree/sanguo/tree/master/org.sf.feeling.sanguo.patch_1.9a/src/org/sf/feeling/sanguo/patch/util/BattleUtil.java", "rawCode": "  public static List getModelFactions(String modelType) {\n    List modelFactions = new ArrayList();\n\n    try {\n      String line = null;\n      BufferedReader in =\n          new BufferedReader(\n              new InputStreamReader(new FileInputStream(FileConstants.battleFile), \"GBK\"));\n      boolean startModel = false;\n      while ((line = in.readLine()) != null) {\n        if (line.trim().startsWith(\";\")) {\n          continue;\n        }\n        if (!startModel) {\n          Pattern pattern = Pattern.compile(\"^\\\\s*(type)(\\\\s+)\");\n          Matcher matcher = pattern.matcher(line);\n          if (matcher.find()) {\n            String type = line.split(\";\")[0].replaceAll(\"type\", \"\").trim();\n            if (modelType.equals(type)) {\n              startModel = true;\n              continue;\n            }\n          }\n        } else {\n          Pattern pattern = Pattern.compile(\"^\\\\s*(model_tri)(\\\\s+)\");\n          Matcher matcher = pattern.matcher(line);\n          if (matcher.find()) {\n            break;\n          }\n\n          pattern = Pattern.compile(\"^\\\\s*(texture)(\\\\.+)(,)(\\\\s*)\");\n          matcher = pattern.matcher(line);\n          if (matcher.find()) {\n            String[] splits = line.split(\";\")[0].split(\",\")[0].trim().split(\"\\\\s+\");\n            if (splits.length == 2) modelFactions.add(splits[1].trim());\n          }\n          continue;\n        }\n      }\n      in.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return modelFactions;\n  }\n"}, {"dataset": "compile", "exampleID": 5991, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 477, "focalAPIEnd": 515, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["filterByText(Iterable<LogEntry>,pattern)"], "useStart": [534], "useEnd": [559], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/davidmoten/logan/tree/master/src/main/java/com/github/davidmoten/logan/DataCore.java", "rawCode": "  private static Iterable<LogEntry> filter(Iterable<LogEntry> entries, BucketQuery query) {\n\n    Iterable<LogEntry> filtered = entries;\n    // filter by field\n    if (query.getField().isPresent()) {\n      filtered = filterByField(filtered, query.getField().get());\n    }\n\n    // filter by source\n    if (query.getSource().isPresent()) filtered = filterBySource(filtered, query.getSource().get());\n\n    // filter by text\n    if (query.getText().isPresent()) {\n      Pattern p = Pattern.compile(query.getText().get());\n      filtered = filterByText(filtered, p);\n    }\n\n    return filtered;\n  }\n"}, {"dataset": "compile", "exampleID": 5992, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 66, "focalAPIEnd": 89, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/tools/tree/master/poc/registry/org.wso2.carbonstudio.eclipse.greg.base/src/org/wso2/carbonstudio/eclipse/greg/base/ui/editor/pages/ResourceEditorPage.java", "rawCode": "  private String removeSpaces(String url) {\n    Pattern pattern = Pattern.compile(\"\\\\s+\");\n    Matcher matcher = pattern.matcher(url);\n    boolean check = matcher.find();\n    String str = matcher.replaceAll(\"\");\n    return str;\n  }\n"}, {"dataset": "compile", "exampleID": 5993, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex,flags)", "focalAPIStart": 3511, "focalAPIEnd": 3579, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Lorquas/testrepo/tree/master/src/rhsm/cli/tests/ConfigTests.java", "rawCode": "  @Test(\n    description =\n        \"subscription-manager: after having removed all the config parameters using the config module, assert that the config list shows the default values in use by wrapping them in [] and the others are simply blanked.\",\n    groups = {},\n    dataProvider = \"getConfigSectionNameData\",\n    dependsOnMethods = {\"ConfigRemoveSectionNameValue_Test\"},\n    alwaysRun = true,\n    enabled = true\n  )\n  // @ImplementsNitrateTest(caseId=)\n  public void ConfigGetSectionNameValueAndVerifyDefault_Test(\n      Object bugzilla, String section, String name, String ignoreValue) {\n\n    // get a the config list (only once to save some unnecessary logging)\n    // SSHCommandResult sshCommandResultFromConfigGetSectionNameValue_Test =\n    // clienttasks.config(true,null,null,(String[])null);\n    if (sshCommandResultFromConfigGetSectionNameValueAndVerifyDefault_Test == null) {\n      sshCommandResultFromConfigGetSectionNameValueAndVerifyDefault_Test =\n          clienttasks.config(true, null, null, (String[]) null);\n    }\n\n    // [root@jsefler-onprem-62server ~]# subscription-manager config --list\n    // [server]\n    // ca_cert_dir = [/etc/rhsm/ca/]\n    // hostname =\n    // insecure = [0]\n    // port = [8443]\n    // prefix = [/candlepin]\n    // proxy_hostname = []\n    // proxy_password = []\n    // proxy_port = []\n    // proxy_user = []\n    // repo_ca_cert = [/etc/rhsm/ca/redhat-uep.pem]\n    // ssl_verify_depth = [3]\n    //\n    // [] - Default value in use\n\n    // there are two cases to test\n    // 1. there is a default value hard-coded for the parameter that will be used after having\n    // called config --remove section.name\n    // 2. there is not a default value for the parameter yet it was set in the rhsm.conf file and is\n    // not set to \"\" after having called config --remove section.name\n\n    // assert that the section name's expectedValue was listed\n    String regexForName =\n        \"(\"\n            + name\n            + \"|\"\n            + name.toLowerCase()\n            + \")\"; // note: python will write and tolerate all lowercase parameter names\n    String regexForValue = null;\n    String assertMsg = \"\";\n    if (clienttasks.defaultConfFileParameterNames(true).contains(name.toLowerCase())) { // case 1:\n      // value listed for name after having removed a parameter that has a default defined\n      // ca_cert_dir = [/etc/rhsm/ca/]\n      regexForValue = \"\\\\[.*\\\\]\";\n      assertMsg =\n          \"After executing subscription-manager config to remove '\"\n              + section\n              + \".\"\n              + name.toLowerCase()\n              + \"', calling config --list shows the default value for the parameter surrounded by square brackets[].\";\n    } else { // case 2:\n      // value listed for name after having removed a parameter that does NOT have a default defined\n      // hostname =\n      regexForValue = \"\";\n      assertMsg =\n          \"After executing subscription-manager config to remove '\"\n              + section\n              + \".\"\n              + name.toLowerCase()\n              + \"', calling config --list shows the default value as an empty string since this parameter has no default.\";\n    }\n    String regexForSectionNameExpectedValue =\n        \"^\\\\[\" + section + \"\\\\](\\\\n.*?)+^ \" + regexForName + \" = \" + regexForValue + \"$\";\n    log.info(\n        \"Using regex \\\"\"\n            + regexForSectionNameExpectedValue\n            + \"\\\"to assert the default value was listed by config after having removed the parameter name.\");\n    Pattern pattern = Pattern.compile(regexForSectionNameExpectedValue, Pattern.MULTILINE);\n    Matcher matcher =\n        pattern.matcher(\n            sshCommandResultFromConfigGetSectionNameValueAndVerifyDefault_Test.getStdout());\n\n    Assert.assertTrue(matcher.find(), assertMsg);\n  }\n"}, {"dataset": "compile", "exampleID": 5994, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 143, "focalAPIEnd": 167, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)", "pattern.matcher(String)", "pattern.compile(String)"], "useStart": [177, 318, 361, 688, 732, 1199, 1240, 1315], "useEnd": [199, 351, 380, 722, 751, 1230, 1263, 1346], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/tests/libcore/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Pattern2Test.java", "rawCode": "  public void testCapturingGroups() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    // Test simple capturing groups\n    p = Pattern.compile(\"(a+)b\");\n    m = p.matcher(\"aaaaaaaab\");\n    assertTrue(m.matches());\n    assertEquals(1, m.groupCount());\n    assertEquals(\"aaaaaaaa\", m.group(1));\n\n    p = Pattern.compile(\"((an)+)((as)+)\");\n    m = p.matcher(\"ananas\");\n    assertTrue(m.matches());\n    assertEquals(4, m.groupCount());\n    assertEquals(\"ananas\", m.group(0));\n    assertEquals(\"anan\", m.group(1));\n    assertEquals(\"an\", m.group(2));\n    assertEquals(\"as\", m.group(3));\n    assertEquals(\"as\", m.group(4));\n\n    // Test grouping without capture (?:...)\n    p = Pattern.compile(\"(?:(?:an)+)(as)\");\n    m = p.matcher(\"ananas\");\n    assertTrue(m.matches());\n    assertEquals(1, m.groupCount());\n    assertEquals(\"as\", m.group(1));\n    try {\n      m.group(2);\n      fail(\"expected IndexOutOfBoundsException\");\n    } catch (IndexOutOfBoundsException ioobe) {\n      // expected\n    }\n\n    // Test combination of grouping and capture\n    // TODO\n\n    // Test \\<num> sequence with capturing and non-capturing groups\n    // TODO\n\n    // Test \\<num> with <num> out of range\n    p = Pattern.compile(\"((an)+)as\\\\1\");\n    m = p.matcher(\"ananasanan\");\n    assertTrue(m.matches());\n\n    try {\n      p = Pattern.compile(\"((an)+)as\\\\4\");\n      fail(\"expected PatternSyntaxException\");\n    } catch (PatternSyntaxException pse) {\n      // expected\n    }\n  }\n"}, {"dataset": "compile", "exampleID": 5995, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new PhrescoException(*)"], "tryExpressionStart": 135, "tryExpressionEnd": 139, "tryBlockStart": 135, "tryBlockEnd": 1252, "catchExpressionStart": 1188, "catchExpressionEnd": 1208, "catchBlockStart": 1188, "catchBlockEnd": 1252, "exceptionHandlingCallStart": [1222], "exceptionHandlingCallEnd": [1245], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 740, "focalAPIEnd": 767, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/photon-infotech/framework/tree/master/phresco-framework-web/src/main/java/com/photon/phresco/framework/rest/api/util/FrameworkServiceUtil.java", "rawCode": "  public boolean loadTestResultAvail(ApplicationInfo appInfo) throws PhrescoException {\n    boolean isResultFileAvailable = false;\n    try {\n      String baseDir = Utility.getProjectHome() + appInfo.getAppDirName();\n      FrameworkUtil frameworkUtil = FrameworkUtil.getInstance();\n      List<String> testResultsTypes = new ArrayList<String>();\n      testResultsTypes.add(\"server\");\n      testResultsTypes.add(\"webservice\");\n      for (String testResultsType : testResultsTypes) {\n        StringBuilder sb = new StringBuilder(baseDir.toString());\n        String loadReportDir = frameworkUtil.getLoadTestReportDir(appInfo);\n        if (StringUtils.isNotEmpty(loadReportDir) && StringUtils.isNotEmpty(testResultsType)) {\n          Pattern p = Pattern.compile(\"dir_type\");\n          Matcher matcher = p.matcher(loadReportDir);\n          loadReportDir = matcher.replaceAll(testResultsType);\n          sb.append(loadReportDir);\n        }\n        File file = new File(sb.toString());\n        File[] children = file.listFiles(new XmlNameFileFilter(FILE_EXTENSION_XML));\n        if (!ArrayUtils.isEmpty(children)) {\n          isResultFileAvailable = true;\n          break;\n        }\n      }\n    } catch (Exception e) {\n      throw new PhrescoException(e);\n    }\n\n    return isResultFileAvailable;\n  }\n"}, {"dataset": "compile", "exampleID": 5996, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 1017, "focalAPIEnd": 1088, "followUpCheck": "true || !emailVar.replaceAll(pattern.pattern(),\"\").isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 1357, "followUpCheckExpressionEnd": 1435, "followUpCheckBlockStart": 1357, "followUpCheckBlockEnd": 1677, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/max-konin/globerry/tree/master/GloberryMain/Globerry/src/main/java/com/globerry/project/controllers/RegistrationController.java", "rawCode": "  /**\n   * Method for registration or return errors if they exist.\n   *\n   * @param nameVar Name of company\n   * @param emailVar Contact email\n   * @param password Company's password\n   * @param cPassword Confirming company's password\n   * @param model Standard model to put variables to .jsp\n   * @return\n   */\n  @RequestMapping(value = \"/registration\", method = RequestMethod.POST)\n  public String tryRegistration(\n      @RequestParam(value = \"name\", required = false) String nameVar,\n      @RequestParam(value = \"email\", required = false) String emailVar,\n      @RequestParam(value = \"pass\", required = false) String password,\n      @RequestParam(value = \"cPass\", required = false) String cPassword,\n      ModelMap model) {\n    boolean timeout;\n    if (time.before(new Date(System.currentTimeMillis() - 1000))) {\n      time = new Date(System.currentTimeMillis());\n      timeout = false;\n    } else {\n      timeout = true;\n    }\n    Map<String, String> errorMap = new HashMap<String, String>();\n    Pattern regex = Pattern.compile(\"^[A-Za-z0-9.%+\\\\-]+@[A-Za-z0-9.\\\\-]+\\\\.[A-Za-z]{2,4}\");\n    if (nameVar.isEmpty()) {\n      errorMap.put(\"name\", \"Login is empty. Please fill it.\");\n    } else {\n      Company temp = companyService.getCompanyByName(nameVar);\n      if (temp != null) {\n        errorMap.put(\"name\", \"Login already exsist.\");\n      }\n    }\n    if (emailVar.isEmpty() || !emailVar.replaceAll(regex.pattern(), \"\").isEmpty()) {\n      errorMap.put(\"email\", \"Error in email. Please fix it.\");\n    } else {\n      Company temp = companyService.getCompanyByEmail(emailVar);\n      if (temp != null) {\n        errorMap.put(\"email\", \"Email already registred.\");\n      }\n    }\n    if (password.isEmpty()) {\n      errorMap.put(\"password\", \"Password is empty. Please fill it\");\n    } else if (!password.equals(cPassword)) {\n      errorMap.put(\"password\", \"Confirming password failed.\");\n    }\n    if (errorMap.isEmpty() && !timeout) {\n      Company company = new Company();\n      company.setName(nameVar);\n      company.setLogin(nameVar);\n      company.setEmail(emailVar);\n      // company.setAccess(CompanyDao.ROLE_USER);\n      Md5PasswordEncoder md5 = new Md5PasswordEncoder();\n      company.setPassword(md5.encodePassword(password, null));\n      try {\n        companyService.addCompany(company);\n        String success =\n            \"Now you will registered by name : \"\n                + nameVar\n                + \", you can try <a href='/project/auth/login'>login</a>\";\n        model.put(\"success\", success);\n        return \"registrationpage\";\n      } catch (MySqlException mse) {\n        mse.printStackTrace(System.err);\n      }\n    }\n    model.put(\"errorList\", errorMap);\n    model.put(\"Name\", nameVar);\n    model.put(\"Email\", emailVar);\n    model.put(\"title\", \"Globerry - registration\");\n    return \"registrationpage\";\n  }\n"}, {"dataset": "compile", "exampleID": 5997, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 347, "focalAPIEnd": 376, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["skip(pattern)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)", "pattern.compile(String)"], "useStart": [340, 696, 863, 1046, 1309, 1612, 2180, 2572, 2787], "useEnd": [377, 725, 893, 1069, 1341, 1654, 2220, 2593, 2812], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/libcore/java/util/OldScannerTest.java", "rawCode": "  public void test_skip_LPattern() {\n    s = new Scanner(\"test\");\n    try {\n      s.skip((String) null);\n      fail(\"Should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    // If pattern does not match, NoSuchElementException will be thrown out.\n    s = new Scanner(\"1234\");\n    try {\n      s.skip(Pattern.compile(\"\\\\p{Lower}\"));\n      fail(\"Should throw NoSuchElementException\");\n    } catch (NoSuchElementException e) {\n      // expected\n    }\n    // Then, no matchResult will be thrown out.\n    try {\n      s.match();\n      fail(\"Should throw IllegalStateException\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n\n    s.skip(Pattern.compile(\"\\\\p{Digit}\"));\n    MatchResult matchResult = s.match();\n    assertEquals(0, matchResult.start());\n    assertEquals(1, matchResult.end());\n\n    s.skip(Pattern.compile(\"\\\\p{Digit}+\"));\n    matchResult = s.match();\n    assertEquals(1, matchResult.start());\n    assertEquals(4, matchResult.end());\n\n    s.close();\n    try {\n      s.skip(Pattern.compile(\"test\"));\n      fail(\"Should throw IllegalStateException\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n\n    MockStringReader2Read reader = new MockStringReader2Read(\"test\");\n    s = new Scanner(reader);\n    try {\n      s.skip(Pattern.compile(\"\\\\p{Digit}{4}\"));\n      fail(\"Should throw NoSuchElementException\");\n    } catch (NoSuchElementException e) {\n      // expected\n    }\n    try {\n      s.match();\n      fail(\"Should throw IllegalStateException\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n    s.skip(Pattern.compile(\"\\\\p{Digit}{3}\\\\p{Lower}\"));\n    matchResult = s.match();\n    assertEquals(0, matchResult.start());\n    assertEquals(4, matchResult.end());\n\n    s.close();\n    try {\n      s.skip((Pattern) null);\n      fail(\"Should throw IllegalStateException\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n\n    StringBuilder stringBuilder = new StringBuilder();\n    char[] chars = new char[1024];\n    Arrays.fill(chars, 'a');\n    stringBuilder.append(chars);\n    stringBuilder.append('3');\n    s = new Scanner(stringBuilder.toString());\n    s.skip(Pattern.compile(\"\\\\p{Lower}+\\\\p{Digit}\"));\n    matchResult = s.match();\n    assertEquals(0, matchResult.start());\n    assertEquals(1025, matchResult.end());\n\n    // Large amount of input may be cached\n    chars = new char[102400];\n    Arrays.fill(chars, 'a');\n    stringBuilder = new StringBuilder();\n    stringBuilder.append(chars);\n    s = new Scanner(stringBuilder.toString());\n    s.skip(Pattern.compile(\".*\"));\n    matchResult = s.match();\n    assertEquals(0, matchResult.start());\n    assertEquals(102400, matchResult.end());\n\n    // skip something without risking a NoSuchElementException\n    s.skip(Pattern.compile(\"[ \\t]*\"));\n    matchResult = s.match();\n    assertEquals(102400, matchResult.start());\n    assertEquals(102400, matchResult.end());\n  }\n"}, {"dataset": "compile", "exampleID": 5998, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 298, "focalAPIEnd": 320, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stevenhwu/ABI/tree/master/beast-mcmc-srp/src/dr/app/beauti/options/DateGuesser.java", "rawCode": "  private void guessDateFromRegex(String label, String regex, double[] values)\n      throws GuessDatesException {\n\n    if (!regex.contains(\"(\")) {\n      // if user hasn't specified a replace element, assume the whole regex should match\n      regex = \"(\" + regex + \")\";\n    }\n\n    Pattern pattern = Pattern.compile(regex);\n    Matcher matcher = pattern.matcher(label);\n    if (!matcher.find()) {\n      throw new GuessDatesException(\n          \"Regular expression doesn't find a match in taxon label, \" + label);\n    }\n\n    if (matcher.groupCount() < 1) {\n      throw new GuessDatesException(\"Date group not defined in regular expression\");\n    }\n\n    parseDate(label, matcher.group(0), values);\n  }\n"}, {"dataset": "compile", "exampleID": 5999, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 104, "focalAPIEnd": 126, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lowasser/guava-experimental/tree/master/guava-tests/test/com/google/common/base/SplitterTest.java", "rawCode": "  @GwtIncompatible(\"java.util.regex.Pattern\")\n  private static Pattern literalDotPattern() {\n    return Pattern.compile(\"\\\\.\");\n  }\n"}, {"dataset": "compile", "exampleID": 6000, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "pattern = pattern.compile(regex)", "focalAPIStart": 403, "focalAPIEnd": 441, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mscheper/onebusaway-ms-application-modules/tree/master/onebusaway-presentation/src/main/java/org/onebusaway/presentation/impl/resources/CssDocumentHandlerImpl.java", "rawCode": "  public void ignorableAtRule(String atRule) throws CSSException {\n\n    if (atRule.startsWith(AT_RULE_SPRITE)) {\n\n      String snippet = atRule.substring(AT_RULE_SPRITE.length());\n      snippet = snippet.trim();\n      parse(snippet);\n\n    } else if (atRule.startsWith(AT_RULE_URL)) {\n      String snippet = atRule.substring(AT_RULE_URL.length());\n      snippet = snippet.trim();\n      Pattern pattern = Pattern.compile(\"^(\\\\w+)\\\\s+(\\\\w+);$\");\n      Matcher matcher = pattern.matcher(snippet);\n      if (matcher.matches()) {\n        String name = matcher.group(1);\n        String resource = matcher.group(2);\n        handleUrl(name, resource);\n      }\n    }\n  }\n"}]