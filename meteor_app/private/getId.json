[{"dataset": "getId", "exampleID": 101, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.getAppId()", "activity.getBody()", "activity.getBodyId()", "activity.getExternalId()"], "configurationStart": [424, 564, 620, 668], "configurationEnd": [447, 586, 644, 696], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 730, "focalAPIEnd": 750, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["put(String,id)", "activity.getUpdated()", "activity.getPostedTime()", "activity.getPriority()", "activity.getStreamFaviconUrl()", "activity.getStreamSourceUrl()", "activity.getStreamTitle()", "activity.getStreamUrl()", "activity.getTitle()", "activity.getTitleId()", "activity.getUrl()", "activity.getUserId()"], "useStart": [703, 761, 879, 1007, 1227, 1298, 1364, 1424, 1693, 1863, 1919, 1968], "useEnd": [751, 786, 907, 1033, 1261, 1331, 1393, 1451, 1716, 1888, 1940, 1992], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chrismarx/cmestemp22/tree/master/server/src/main/java/org/eurekastreams/server/service/opensocial/spi/ActivityServiceImpl.java", "rawCode": "  /**\n   * Helper method that converts a passed in eurekastreams Activity object into a Shindig Activity\n   * object.\n   *\n   * @param inOSActivity - eurekastreams Activity to be converted.\n   * @return converted Activity object.\n   */\n  private HashMap<String, String> convertActivityFromOSToEureka(final Activity inOSActivity) {\n    HashMap<String, String> outMap = new HashMap<String, String>();\n\n    outMap.put(\"appId\", inOSActivity.getAppId());\n    if (inOSActivity.getBody() == null) {\n      outMap.put(\"body\", \"body\");\n    } else {\n      outMap.put(\"body\", inOSActivity.getBody());\n    }\n    outMap.put(\"bodyId\", inOSActivity.getBodyId());\n    outMap.put(\"id\", inOSActivity.getExternalId());\n    outMap.put(\"openSocialId\", inOSActivity.getId());\n    if (inOSActivity.getUpdated() != null) {\n      outMap.put(\"updated\", inOSActivity.getUpdated().toString());\n    }\n    if (inOSActivity.getPostedTime() != null) {\n      outMap.put(\"postedTime\", inOSActivity.getPostedTime().toString());\n    }\n\n    if (inOSActivity.getPriority() == null) {\n      outMap.put(\"priority\", Float.valueOf(0).toString());\n    } else {\n      outMap.put(\"priority\", inOSActivity.getPriority().toString());\n    }\n    outMap.put(\"streamFaviconUrl\", inOSActivity.getStreamFaviconUrl());\n    outMap.put(\"streamSourceUrl\", inOSActivity.getStreamSourceUrl());\n    outMap.put(\"streamTitle\", inOSActivity.getStreamTitle());\n    outMap.put(\"streamUrl\", inOSActivity.getStreamUrl());\n\n    if (inOSActivity.getTemplateParams() != null) {\n      for (Entry<String, String> currentEntry : inOSActivity.getTemplateParams().entrySet()) {\n        outMap.put(currentEntry.getKey(), currentEntry.getValue());\n      }\n    }\n\n    if (inOSActivity.getTitle() != null && inOSActivity.getTitle().length() > 0) {\n      outMap.put(\"content\", inOSActivity.getTitle());\n    } else {\n      outMap.put(\"content\", inOSActivity.getTitleId());\n    }\n    outMap.put(\"url\", inOSActivity.getUrl());\n    outMap.put(\"userId\", inOSActivity.getUserId());\n\n    return outMap;\n  }\n"}, {"dataset": "getId", "exampleID": 102, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.getAttachedEvents(*)"], "configurationStart": [892], "configurationEnd": [957], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1136, "focalAPIEnd": 1152, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1007], "useEnd": [1153], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/StructuredElementsFactory.java", "rawCode": "  /**\n   * Creates a \"terminationHandler\" element, if the activity has a termination event attached. The\n   * sequence flow within the termination handler represents the activities that will be contained\n   * in the \"terminationHandler\" element.\n   *\n   * <p>If there are multiple termination events attached to the activity an error is added to the\n   * output and the result will be null. This will also be done if there is no termination handler\n   * connected to the termination event.\n   *\n   * @param activity The activity to create the \"terminationHandler\" element for\n   * @return The created \"terminationHandler\" element or null if there are no termination events\n   *     attached to the activity. The result will also be null if an error occured.\n   */\n  public Element createTerminationHandlerElement(Activity activity) {\n\n    List<IntermediateEvent> attachedTermEvents =\n        activity.getAttachedEvents(IntermediateEvent.TRIGGER_TERMINATION);\n\n    if (attachedTermEvents.size() > 1) {\n      this.output.addError(\n          \"The activity \" + \"is not allowed to have more than one termination event attached. \",\n          activity.getId());\n      return null;\n    }\n\n    if (!attachedTermEvents.isEmpty()) {\n      IntermediateEvent event = attachedTermEvents.get(0);\n      Handler termHandler = event.getConnectedHandler();\n\n      if (termHandler == null) {\n        this.output.addError(\n            \"A termination handler attached the event \" + \"could not be found.\", event.getId());\n        return null;\n      }\n\n      Element result = this.document.createElement(\"terminationHandler\");\n      Element sequenceFlow =\n          new SequenceFlowFactory(\n                  this.diagram, this.document, termHandler.getSubProcess(), this.output)\n              .transformSequenceFlow();\n      if (sequenceFlow != null) {\n        // create additional scope if termination handler has\n        // additional variables defined\n        result.appendChild(createHandlerScope(termHandler, sequenceFlow));\n      }\n\n      return result;\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 103, "initialization": ["Activity activity = Transition.getSource()"], "initializationStart": [479], "initializationEnd": [501], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 509, "guardExpressionEnd": 531, "guardBlockStart": 509, "guardBlockEnd": 927, "focalAPI": "id = activity.getId()", "focalAPIStart": 581, "focalAPIEnd": 598, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getObject(id)"], "useStart": [558], "useEnd": [599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/parser/ProcessParser.java", "rawCode": "  /**\n   * Builds up the graph structure based on the process transitions. For each transition the source\n   * and target object will be determined. If the source or target object does not exist in the\n   * diagram or is not an activity, an error is added to the output.\n   */\n  private void buildGraphStructure() {\n    for (Iterator<Transition> it = this.process.getTransitions().iterator(); it.hasNext(); ) {\n      Transition transition = it.next();\n      Activity sourceAct = transition.getSource();\n      if (sourceAct != null) {\n        Object source = this.diagram.getObject(sourceAct.getId());\n        if ((source != null) && (source instanceof Activity)) {\n          ((Activity) source).addSourceFor(transition, this.output);\n        } else {\n          this.output.addError(\n              \"The source activity of this transition\" + \" does not exist in the process.\",\n              transition.getId());\n        }\n      }\n      Activity targetAct = transition.getTarget();\n      if (targetAct != null) {\n        Object target = this.diagram.getObject(targetAct.getId());\n        if ((target != null) && (target instanceof Activity)) {\n          ((Activity) target).addTargetFor(transition, this.output);\n        } else {\n          this.output.addError(\n              \"The target activity of this transition\" + \" does not exist in the process.\",\n              transition.getId());\n        }\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 104, "initialization": ["Activity activity = parseActivity(*)"], "initializationStart": [695], "initializationEnd": [738], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setParentContainer(SubProcess)"], "configurationStart": [782], "configurationEnd": [823], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 748, "guardExpressionEnd": 769, "guardBlockStart": 748, "guardBlockEnd": 942, "focalAPI": "id = activity.getId()", "focalAPIStart": 904, "focalAPIEnd": 920, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["putObject(id,Activity)"], "useStart": [881], "useEnd": [931], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpel4chor/parser/ProcessParser.java", "rawCode": "  /**\n   * Parses the activity nodes contained in the given activities node. It creates an activity for\n   * each activity node and adds this activity to the process activities and to the diagram.\n   *\n   * @param activitiesNode The activities node to be parse.\n   */\n  private void parseActivities(Node activitiesNode) {\n    NodeList activityNodes = activitiesNode.getChildNodes();\n    ActivityParser parser = new ActivityParser(this.diagram, this.output);\n    for (int i = 0; i < activityNodes.getLength(); i++) {\n      Node activityNode = activityNodes.item(i);\n      if ((activityNode.getLocalName() != null) && activityNode.getLocalName().equals(\"Activity\")) {\n\n        Activity activity = parser.parseActivity(activityNodes.item(i));\n        if (activity != null) {\n          activity.setParentContainer(this.process);\n          this.process.addActivity(activity);\n          this.diagram.putObject(activity.getId(), activity);\n        }\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 105, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 782, "focalAPIEnd": 798, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [728], "useEnd": [851], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Checks, if the multiple instance loop corresponds a forEach that iterates over a set of\n   * participants (BPEL4Chor forEach). In this case there is no counter variable data object defined\n   * for the loop.\n   *\n   * @param activity The activity to check\n   * @return True if the activity is a BPEL4Chor forEach (no counter variable associated with the\n   *     loop). False otherwise.\n   */\n  private boolean isBPEL4ChorForEach(Activity activity) {\n    if ((activity.getLoop() != null)\n        && (activity.getLoop().getLoopType().equals(Loop.TYPE_MULITPLE))) {\n      // if there is a counter variable data object defined\n      // the loop is not a BPEL4ChorForEach\n      List<Association> associations =\n          this.diagram.getAssociationsWithSource(\n              activity.getId(), Association.DIRECTION_TO, VariableDataObject.class);\n\n      for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n        VariableDataObject object = (VariableDataObject) it.next().getSource();\n        if (object.getType().equals(VariableDataObject.TYPE_COUNTER)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "getId", "exampleID": 106, "initialization": ["Activity activity = List<Activity>.get(int)"], "initializationStart": [238], "initializationEnd": [255], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 342, "focalAPIEnd": 358, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(*,id)", "activity.getId()", "assertEquals(*,id)", "activity.getId()", "assertEquals(*,id)", "activity.getId()", "assertEquals(*,id)"], "useStart": [325, 382, 585, 649, 831, 888, 1054], "useEnd": [359, 446, 619, 712, 865, 941, 1088], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ushahidi/SwiftRiver-API/tree/master/src/test/java/com/ushahidi/swiftriver/core/api/dao/impl/JpaActivityDaoTest.java", "rawCode": "  @Test\n  public void findForSpecificAccount() {\n    List<Activity> activities = activityDao.find(3L, 100, Long.MAX_VALUE, false, false);\n\n    assertEquals(6, activities.size());\n\n    // There is a bucket activity\n    Activity activity = activities.get(0);\n    assertTrue(activity instanceof BucketCollaboratorActivity);\n    assertEquals(8L, activity.getId());\n    assertEquals(2L, ((BucketCollaboratorActivity) activity).getActionOnObj().getId());\n\n    // There is a bucket activity\n    activity = activities.get(1);\n    assertTrue(activity instanceof RiverCollaboratorActivity);\n    assertEquals(7L, activity.getId());\n    assertEquals(2L, (long) ((RiverCollaboratorActivity) activity).getActionOnObj().getId());\n\n    // Account activity\n    activity = activities.get(2);\n    assertTrue(activity instanceof AccountActivity);\n    assertEquals(4L, activity.getId());\n    assertEquals(4L, ((AccountActivity) activity).getActionOnObj().getId());\n\n    // Form activity\n    activity = activities.get(3);\n    assertTrue(activity instanceof FormActivity);\n    assertEquals(3L, activity.getId());\n    assertEquals(1L, (long) ((FormActivity) activity).getActionOnObj().getId());\n  }\n"}, {"dataset": "getId", "exampleID": 107, "initialization": ["Activity activity = ActivityClient.get(String)"], "initializationStart": [108], "initializationEnd": [126], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 160, "focalAPIEnd": 176, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertNotNull(activity)"], "useStart": [249], "useEnd": [272], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bwalker99/Sandbox/tree/master/REST-Jersey-Demo01/src/com/pluralsite/client/ActivityClientTest.java", "rawCode": "  @Test\n  public void testGet() {\n    ActivityClient client = new ActivityClient();\n    Activity activity = client.get(\"xxxx\");\n    System.out.println(\n        activity.getId() + \" \" + activity.getDuration() + \" \" + activity.getDescription());\n\n    assertNotNull(activity);\n  }\n"}, {"dataset": "getId", "exampleID": 108, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 257, "focalAPIEnd": 275, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Log.info(id)"], "useStart": [212], "useEnd": [276], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lmco/eurekastreams/tree/master/server/src/main/java/org/eurekastreams/server/action/execution/stream/StoreStreamHashTagsForActivityStrategyImpl.java", "rawCode": "  /**\n   * Parse and insert any necessary StreamHashTags for the input activity.\n   *\n   * @param inActivity the activity to parse for stream hashtags\n   */\n  public void execute(final Activity inActivity) {\n    log.info(\"Finding hashtags for activity #\" + inActivity.getId());\n\n    ScopeType scopeType = inActivity.getRecipientStreamScope().getScopeType();\n    if (scopeType != ScopeType.GROUP && scopeType != ScopeType.PERSON) {\n      log.info(\"This activity isn't a group or person stream - not handled.\");\n      return;\n    }\n\n    String recipientStreamKey = inActivity.getRecipientStreamScope().getUniqueKey();\n\n    // create stream hashtag entries for each of the tags being applied\n    StreamHashTag streamHashTag;\n\n    List<String> hashTagStrings = getHashTags(inActivity);\n    if (hashTagStrings.size() == 0) {\n      return;\n    }\n\n    for (HashTag hashTag : hashTagMapper.execute(hashTagStrings)) {\n      // insert the activity hashtag for the destination stream\n      if (log.isDebugEnabled()) {\n        log.debug(\n            \"Adding StreamHashTag \"\n                + hashTag.getContent()\n                + \" for direct recipient stream of type \"\n                + scopeType\n                + \", key: \"\n                + recipientStreamKey\n                + \", activity id: #\"\n                + inActivity.getId());\n      }\n\n      streamHashTag = new StreamHashTag(hashTag, inActivity, recipientStreamKey, scopeType);\n      streamHashTagInsertMapper.execute(new PersistenceRequest<StreamHashTag>(streamHashTag));\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 109, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 640, "focalAPIEnd": 665, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [588], "useEnd": [756], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Determines the reference, the sender of the received message should be bind to. This is a\n   * participant reference data object with an association from the receiving activity.\n   *\n   * @param receivingActivity The activity to get the participant reference for\n   * @return The first participant reference data object with an association from the receiving\n   *     activity. The result is null, if such an association was not found.\n   */\n  private ParticipantReferenceDataObject getReferenceToBind(Activity receivingActivity) {\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            receivingActivity.getId(),\n            Association.DIRECTION_FROM,\n            ParticipantReferenceDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantReferenceDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 110, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1585, "focalAPIEnd": 1598, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1487], "useEnd": [1599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/StructuredElementsFactory.java", "rawCode": "  /**\n   * Creates the \"catch\" and \"catchAll\" elements for the fault handlers attached to the given\n   * activity. An attached error event that does not specify an error code is mapped to a \"catchAll\"\n   * element. The \"catchAll\" element is located at the end of the list.\n   *\n   * <p>If an error event is not connected with an error handler, an error is added to the output\n   * and there will be no element created for this event. This will also be done if there are more\n   * than one events with no specified error code.\n   *\n   * @param activity The activity the error events are attached to.\n   * @return A list with the created \"catch\" and \"catchAll\" elements. If there is no error event\n   *     attached to the activity the list is empty.\n   */\n  public List<Element> createFaultHandlerElements(Activity activity) {\n    // catchAll element must be positioned at the end of the list\n    List<Element> result = new ArrayList<Element>();\n    List<IntermediateEvent> attachedErrorEvents =\n        activity.getAttachedEvents(IntermediateEvent.TRIGGER_ERROR);\n\n    Element catchAllElement = null;\n    for (Iterator<IntermediateEvent> it = attachedErrorEvents.iterator(); it.hasNext(); ) {\n\n      IntermediateEvent event = it.next();\n      ResultError trigger = null;\n      if (event.getTrigger() instanceof ResultError) {\n        trigger = (ResultError) event.getTrigger();\n      }\n      Handler errorHandler = event.getConnectedHandler();\n\n      if (errorHandler == null) {\n        this.output.addError(\n            \"The error event \" + \"is not connected with an error handler.\", event.getId());\n        continue;\n      }\n\n      if ((trigger != null)\n          && (trigger.getErrorCode() != null)\n          && !trigger.getErrorCode().equals(\"\")) {\n\n        Element element = createCatchElement(event, errorHandler, trigger.getErrorCode());\n        if (element != null) {\n          result.add(element);\n        }\n      } else if (catchAllElement == null) {\n        Element element = createCatchAllElement(errorHandler);\n        if (element != null) {\n          catchAllElement = element;\n        }\n      } else {\n        this.output.addError(\n            \"There is more than one error event without a specified\"\n                + \" error name attached to this activity \",\n            activity.getId());\n      }\n    }\n\n    if (catchAllElement != null) {\n      result.add(catchAllElement);\n    }\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 111, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 176, "focalAPIEnd": 187, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mortenk/fll/tree/master/src/main/java/no/fll/plan/bruteforce/BruteForcePlanFactory.java", "rawCode": "  private void setTeamSchedule(\n      TeamSchedule teamSchedule, Activity ringside, Activity pit, int time) {\n    teamSchedule.set(time - pit.getDuration(), pit.getDuration(), pit.getId());\n    teamSchedule.set(time, ringside.getDuration(), ringside.getId());\n  }\n"}, {"dataset": "getId", "exampleID": 112, "initialization": ["Activity activity = ActivityDao.insert(Activity)"], "initializationStart": [342], "initializationEnd": [358], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setText(String)", "activity.setName(String)"], "configurationStart": [532, 565], "configurationEnd": [559, 602], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 667, "focalAPIEnd": 681, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["findById(id)", "compareActivityFields(activity,Activity)", "assertEquals(String,activity,Activity)"], "useStart": [654, 688, 734], "useEnd": [682, 728, 813], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MichaelSieger/Hrm/tree/master/de.hswt.hrm.catalog.dao.jdbc.test/src/de/hswt/hrm/catalog/dao/jdbc/ActivityDaoTest.java", "rawCode": "  @Test\n  public void testUpdateActivity() throws ElementNotFoundException, DatabaseException {\n\n    Activity act1 = new Activity(\"FirstActivity\", \"FirstText\");\n    ITargetDao targetDao = mock(ITargetDao.class);\n    ICurrentDao currentDao = new CurrentDao(targetDao);\n\n    ActivityDao dao = new ActivityDao(currentDao);\n    Activity parsed = dao.insert(act1);\n\n    // We add another contact to ensure that the update affects just one row.\n    Activity act2 = new Activity(\"SecondActivity\", \"SecondText\");\n    dao.insert(act2);\n\n    parsed.setText(\"Some City\");\n    parsed.setName(\"someone@example.com\");\n    dao.update(parsed);\n\n    Activity requested = dao.findById(parsed.getId());\n    compareActivityFields(parsed, requested);\n    assertEquals(\"Requested object does not equal updated one.\", parsed, requested);\n  }\n"}, {"dataset": "getId", "exampleID": 113, "initialization": ["Activity activity = Association.getSource()"], "initializationStart": [1464], "initializationEnd": [1487], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1736, "focalAPIEnd": 1759, "followUpCheck": "id != null", "checkType": "IF", "followUpCheckExpressionStart": 2070, "followUpCheckExpressionEnd": 2091, "followUpCheckBlockStart": 2070, "followUpCheckBlockEnd": 2516, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Tries to determine the type of the data object from the activities it is associated with.\n   *\n   * <p>If there is an association from the data object to a sending task (invoke, reply), the type\n   * is determined from the pool, the receiving activity of the sent message belongs to.\n   *\n   * <p>If there is an association from or to a receiving task (invoke, receive), the type is\n   * determined from the pool, the sending activity of the received message belongs to.\n   *\n   * @param dataObject\n   * @return The type that was determined or null, if the type could not be determined.\n   */\n  private String getTypeFromAssociations(ParticipantReferenceDataObject dataObject) {\n    String id = dataObject.getId();\n    List<Association> outgoingAssociations =\n        this.diagram.getAssociationsWithTarget(id, null, Activity.class);\n    String targetId = null;\n    String sourceId = null;\n    Iterator<Association> it = outgoingAssociations.iterator();\n    while ((targetId == null) && (sourceId == null) && it.hasNext()) {\n      Association association = it.next();\n      if (association.getDirection().equals(Association.DIRECTION_NONE)) {\n        // if direction is none, the type can not be determined\n        continue;\n      } else if (association.getDirection().equals(Association.DIRECTION_TO)) {\n        // check if source object of the association can be used to\n        // determine the type of the reference\n        GraphicalObject source = association.getSource();\n        if ((source instanceof ServiceTask) || (source instanceof SendTask)) {\n          // if outgoing association to sending task (reply, invoke)\n          // source object of the association is the source of a message flow\n          sourceId = ((Task) source).getId();\n        }\n      }\n      // if incoming or outgoing association from data object to a receiving activity\n      // the association is the target of a message flow\n      Activity source = (Activity) association.getSource();\n      if (source.isReceiving()) {\n        targetId = source.getId();\n      }\n    }\n\n    if (sourceId != null) {\n      // if the source object of an association is a source of a message flow\n      // the type can be determined from the swimlane the target of the message flow\n      // is located in\n      MessageFlow messageFlow = this.diagram.getMessageFlowWithSource(sourceId);\n      if ((messageFlow != null) && (messageFlow.getTarget() != null)) {\n        return messageFlow.getTarget().getParentSwimlane().getName();\n      }\n    }\n    if (targetId != null) {\n      // if the source object of an association is the target of a message flow\n      // the type can be determined from swimlane the source of\n      // the message flow is located in\n      List<MessageFlow> messageFlows = this.diagram.getMessageFlowsWithTarget(targetId);\n      if (!messageFlows.isEmpty()) {\n        return messageFlows.get(0).getSource().getParentSwimlane().getName();\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 114, "initialization": ["Activity activity = Association.getSource()"], "initializationStart": [1464], "initializationEnd": [1487], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1736, "focalAPIEnd": 1759, "followUpCheck": "id != null", "checkType": "IF", "followUpCheckExpressionStart": 2070, "followUpCheckExpressionEnd": 2091, "followUpCheckBlockStart": 2070, "followUpCheckBlockEnd": 2516, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Tries to determine the type of the data object from the activities it is associated with.\n   *\n   * <p>If there is an association from the data object to a sending task (invoke, reply), the type\n   * is determined from the pool, the receiving activity of the sent message belongs to.\n   *\n   * <p>If there is an association from or to a receiving task (invoke, receive), the type is\n   * determined from the pool, the sending activity of the received message belongs to.\n   *\n   * @param dataObject\n   * @return The type that was determined or null, if the type could not be determined.\n   */\n  private String getTypeFromAssociations(ParticipantReferenceDataObject dataObject) {\n    String id = dataObject.getId();\n    List<Association> outgoingAssociations =\n        this.diagram.getAssociationsWithTarget(id, null, Activity.class);\n    String targetId = null;\n    String sourceId = null;\n    Iterator<Association> it = outgoingAssociations.iterator();\n    while ((targetId == null) && (sourceId == null) && it.hasNext()) {\n      Association association = it.next();\n      if (association.getDirection().equals(Association.DIRECTION_NONE)) {\n        // if direction is none, the type can not be determined\n        continue;\n      } else if (association.getDirection().equals(Association.DIRECTION_TO)) {\n        // check if source object of the association can be used to\n        // determine the type of the reference\n        GraphicalObject source = association.getSource();\n        if ((source instanceof ServiceTask) || (source instanceof SendTask)) {\n          // if outgoing association to sending task (reply, invoke)\n          // source object of the association is the source of a message flow\n          sourceId = ((Task) source).getId();\n        }\n      }\n      // if incoming or outgoing association from data object to a receiving activity\n      // the association is the target of a message flow\n      Activity source = (Activity) association.getSource();\n      if (source.isReceiving()) {\n        targetId = source.getId();\n      }\n    }\n\n    if (sourceId != null) {\n      // if the source object of an association is a source of a message flow\n      // the type can be determined from the swimlane the target of the message flow\n      // is located in\n      MessageFlow messageFlow = this.diagram.getMessageFlowWithSource(sourceId);\n      if ((messageFlow != null) && (messageFlow.getTarget() != null)) {\n        return messageFlow.getTarget().getParentSwimlane().getName();\n      }\n    }\n    if (targetId != null) {\n      // if the source object of an association is the target of a message flow\n      // the type can be determined from swimlane the source of\n      // the message flow is located in\n      List<MessageFlow> messageFlows = this.diagram.getMessageFlowsWithTarget(targetId);\n      if (!messageFlows.isEmpty()) {\n        return messageFlows.get(0).getSource().getParentSwimlane().getName();\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 115, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 103, "focalAPIEnd": 119, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["findById(id)", "List<Activity>.indexOf(activity)", "activity.getPriority()", "activity.setPriority(double)", "save(activity)"], "useStart": [82, 192, 308, 422, 458], "useEnd": [120, 214, 331, 450, 472], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tassiovirginio/firststepinagile/tree/master/src/main/java/br/com/fa7/firststepinagile/business/ActivityBusiness.java", "rawCode": "  public void upActivityPriority(Activity activity, Story story) {\n    activity = activityDAO.findById(activity.getId());\n    List<Activity> list = findActivityByStory(story);\n    int index = list.indexOf(activity);\n    if (index != 0) {\n      Activity activity2 = list.get(index - 1);\n      double index1 = activity2.getPriority();\n      double index2 = activity.getPriority();\n      activity2.setPriority(index2);\n      activity.setPriority(index1);\n      save(activity);\n      save(activity2);\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 116, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 812, "focalAPIEnd": 828, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,String,*)"], "useStart": [760], "useEnd": [878], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/TopologyFactory.java", "rawCode": "  /**\n   * Determines the participant reference data objects that are associated with the given activity.\n   *\n   * @param activity The activity the associated references will be determined for\n   * @param direction The direction of the association connecting the activity with the reference.\n   * @return A list with participant reference data objects associated with the given activity. If\n   *     no participant reference data object was found, an emtpy list will be returned.\n   */\n  private List<ParticipantReferenceDataObject> getAssociatedParticipantReferences(\n      Activity activity, String direction) {\n\n    List<ParticipantReferenceDataObject> result = new ArrayList<ParticipantReferenceDataObject>();\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            activity.getId(), direction, ParticipantReferenceDataObject.class);\n\n    for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n      Association assoc = it.next();\n      result.add((ParticipantReferenceDataObject) assoc.getTarget());\n    }\n\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 117, "initialization": ["Activity activity = Association.getSource()"], "initializationStart": [1464], "initializationEnd": [1487], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1736, "focalAPIEnd": 1759, "followUpCheck": "id != null", "checkType": "IF", "followUpCheckExpressionStart": 2070, "followUpCheckExpressionEnd": 2091, "followUpCheckBlockStart": 2070, "followUpCheckBlockEnd": 2516, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Tries to determine the type of the data object from the activities it is associated with.\n   *\n   * <p>If there is an association from the data object to a sending task (invoke, reply), the type\n   * is determined from the pool, the receiving activity of the sent message belongs to.\n   *\n   * <p>If there is an association from or to a receiving task (invoke, receive), the type is\n   * determined from the pool, the sending activity of the received message belongs to.\n   *\n   * @param dataObject\n   * @return The type that was determined or null, if the type could not be determined.\n   */\n  private String getTypeFromAssociations(ParticipantReferenceDataObject dataObject) {\n    String id = dataObject.getId();\n    List<Association> outgoingAssociations =\n        this.diagram.getAssociationsWithTarget(id, null, Activity.class);\n    String targetId = null;\n    String sourceId = null;\n    Iterator<Association> it = outgoingAssociations.iterator();\n    while ((targetId == null) && (sourceId == null) && it.hasNext()) {\n      Association association = it.next();\n      if (association.getDirection().equals(Association.DIRECTION_NONE)) {\n        // if direction is none, the type can not be determined\n        continue;\n      } else if (association.getDirection().equals(Association.DIRECTION_TO)) {\n        // check if source object of the association can be used to\n        // determine the type of the reference\n        GraphicalObject source = association.getSource();\n        if ((source instanceof ServiceTask) || (source instanceof SendTask)) {\n          // if outgoing association to sending task (reply, invoke)\n          // source object of the association is the source of a message flow\n          sourceId = ((Task) source).getId();\n        }\n      }\n      // if incoming or outgoing association from data object to a receiving activity\n      // the association is the target of a message flow\n      Activity source = (Activity) association.getSource();\n      if (source.isReceiving()) {\n        targetId = source.getId();\n      }\n    }\n\n    if (sourceId != null) {\n      // if the source object of an association is a source of a message flow\n      // the type can be determined from the swimlane the target of the message flow\n      // is located in\n      MessageFlow messageFlow = this.diagram.getMessageFlowWithSource(sourceId);\n      if ((messageFlow != null) && (messageFlow.getTarget() != null)) {\n        return messageFlow.getTarget().getParentSwimlane().getName();\n      }\n    }\n    if (targetId != null) {\n      // if the source object of an association is the target of a message flow\n      // the type can be determined from swimlane the source of\n      // the message flow is located in\n      List<MessageFlow> messageFlows = this.diagram.getMessageFlowsWithTarget(targetId);\n      if (!messageFlows.isEmpty()) {\n        return messageFlows.get(0).getSource().getParentSwimlane().getName();\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 118, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1010, "focalAPIEnd": 1021, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)", "createSourcesAndTargets(activity,Element,List<Link>,Expression)"], "useStart": [933, 1082], "useEnd": [1022, 1136], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/SequenceFlowFactory.java", "rawCode": "  /**\n   * Maps an activity to its BPEL4Chor representation. If the activity is not a block activity, task\n   * or intermediate event, an error is added to the output and the result will be null.\n   *\n   * @param act The activity to be mapped.\n   * @param links Links that are defined in the context of the activity.\n   * @param joinCond The join condition the mapped element should define.\n   * @return The created BPEL4Chor element the activity represents or null if the activity could not\n   *     be mapped.\n   */\n  public Element mapActivity(Activity act, List<Link> links, Expression joinCond) {\n    Element element = null;\n    if (act instanceof BlockActivity) {\n      element = mapBlockActivity((BlockActivity) act);\n    } else if (act instanceof Task) {\n      element = mapTask((Task) act);\n    } else if (act instanceof IntermediateEvent) {\n      element = mapIntermediateEvent((IntermediateEvent) act);\n    } else {\n      this.output.addError(\"Activity \" + \"could not be transformed to BPEL4Chor.\", act.getId());\n      return null;\n    }\n    if (element != null) {\n      createSourcesAndTargets(act, element, links, joinCond);\n    }\n    return element;\n  }\n"}, {"dataset": "getId", "exampleID": 119, "initialization": ["Activity activity = parseActivity(*)"], "initializationStart": [793], "initializationEnd": [836], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setParentContainer(SubProcess)"], "configurationStart": [880], "configurationEnd": [919], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 846, "guardExpressionEnd": 867, "guardBlockStart": 846, "guardBlockEnd": 1036, "focalAPI": "id = activity.getId()", "focalAPIStart": 998, "focalAPIEnd": 1014, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["putObject(id,Activity)"], "useStart": [975], "useEnd": [1025], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpel4chor/parser/SubProcessParser.java", "rawCode": "  /**\n   * Parses the activity nodes contained in the given activities node. It creates an activity for\n   * each activity node and adds this activity to the sub-process activities and to the diagram.\n   *\n   * @param subProcess The sub process to add the parsed activities to.\n   * @param activitiesNode The activities node to be parse.\n   */\n  private void parseActivities(SubProcess subProcess, Node activitiesNode) {\n    NodeList activityNodes = activitiesNode.getChildNodes();\n    ActivityParser parser = new ActivityParser(this.diagram, this.output);\n    for (int i = 0; i < activityNodes.getLength(); i++) {\n      Node activityNode = activityNodes.item(i);\n      if ((activityNode.getLocalName() != null) && activityNode.getLocalName().equals(\"Activity\")) {\n        Activity activity = parser.parseActivity(activityNodes.item(i));\n        if (activity != null) {\n          activity.setParentContainer(subProcess);\n          subProcess.addActivity(activity);\n          this.diagram.putObject(activity.getId(), activity);\n        }\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 120, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1585, "focalAPIEnd": 1598, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1487], "useEnd": [1599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/StructuredElementsFactory.java", "rawCode": "  /**\n   * Creates the \"catch\" and \"catchAll\" elements for the fault handlers attached to the given\n   * activity. An attached error event that does not specify an error code is mapped to a \"catchAll\"\n   * element. The \"catchAll\" element is located at the end of the list.\n   *\n   * <p>If an error event is not connected with an error handler, an error is added to the output\n   * and there will be no element created for this event. This will also be done if there are more\n   * than one events with no specified error code.\n   *\n   * @param activity The activity the error events are attached to.\n   * @return A list with the created \"catch\" and \"catchAll\" elements. If there is no error event\n   *     attached to the activity the list is empty.\n   */\n  public List<Element> createFaultHandlerElements(Activity activity) {\n    // catchAll element must be positioned at the end of the list\n    List<Element> result = new ArrayList<Element>();\n    List<IntermediateEvent> attachedErrorEvents =\n        activity.getAttachedEvents(IntermediateEvent.TRIGGER_ERROR);\n\n    Element catchAllElement = null;\n    for (Iterator<IntermediateEvent> it = attachedErrorEvents.iterator(); it.hasNext(); ) {\n\n      IntermediateEvent event = it.next();\n      ResultError trigger = null;\n      if (event.getTrigger() instanceof ResultError) {\n        trigger = (ResultError) event.getTrigger();\n      }\n      Handler errorHandler = event.getConnectedHandler();\n\n      if (errorHandler == null) {\n        this.output.addError(\n            \"The error event \" + \"is not connected with an error handler.\", event.getId());\n        continue;\n      }\n\n      if ((trigger != null)\n          && (trigger.getErrorCode() != null)\n          && !trigger.getErrorCode().equals(\"\")) {\n\n        Element element = createCatchElement(event, errorHandler, trigger.getErrorCode());\n        if (element != null) {\n          result.add(element);\n        }\n      } else if (catchAllElement == null) {\n        Element element = createCatchAllElement(errorHandler);\n        if (element != null) {\n          catchAllElement = element;\n        }\n      } else {\n        this.output.addError(\n            \"There is more than one error event without a specified\"\n                + \" error name attached to this activity \",\n            activity.getId());\n      }\n    }\n\n    if (catchAllElement != null) {\n      result.add(catchAllElement);\n    }\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 121, "initialization": ["Activity activity = getParent()"], "initializationStart": [312], "initializationEnd": [334], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 404, "guardExpressionEnd": 424, "guardBlockStart": 404, "guardBlockEnd": 477, "focalAPI": "id = activity.getId()", "focalAPIStart": 445, "focalAPIEnd": 460, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["put(id,Activity)"], "useStart": [433], "useEnd": [470], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jogetworkflow/jw-community/tree/master/wflow-designer/src/main/java/org/enhydra/jawe/base/panel/StandardPanelGenerator.java", "rawCode": "  protected XMLPanel getPanelForFROMAttribute(Transition transition) {\n    SequencedHashMap choices =\n        JaWEManager.getInstance().getTransitionHandler().getPossibleSourceActivities(transition);\n\n    String tFrom = transition.getFrom();\n\n    Activity current =\n        ((Activities) ((XMLCollectionElement) transition.getParent().getParent()).get(\"Activities\"))\n            .getActivity(tFrom);\n    if (current != null) {\n      choices.put(current.getId(), current);\n    }\n\n    Activity choosen = null;\n    if (!tFrom.equals(\"\")) {\n      choosen = (Activity) choices.get(tFrom);\n    }\n\n    XMLAttribute from = (XMLAttribute) transition.get(\"From\");\n    SpecialChoiceElement cc =\n        new SpecialChoiceElement(\n            from,\n            \"\",\n            new ArrayList(choices.values()),\n            choosen,\n            true,\n            \"Id\",\n            \"From\",\n            from.isRequired());\n    cc.setReadOnly(from.isReadOnly());\n    return new XMLComboPanel(\n        getPanelContainer(),\n        cc,\n        null,\n        false,\n        true,\n        false,\n        false,\n        JaWEManager.getInstance().getJaWEController().canModifyElement(from));\n  }\n"}, {"dataset": "getId", "exampleID": 122, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 259, "focalAPIEnd": 326, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/test/java/com/collabinate/server/resources/FeedResourceTest.java", "rawCode": "  @Test\n  public void liked_item_in_feed_should_contain_user_like_indication() {\n    // add activity to the stream of entity\n    Request request =\n        new Request(Method.POST, \"riap://application/1/tenant/entities/entity/stream\");\n    String activityId = (new Activity(component.handle(request).getEntityAsText())).getId();\n\n    // follow the entity\n    request = new Request(Method.PUT, \"riap://application/1/tenant/users/user/following/entity\");\n    component.handle(request);\n\n    // like the entity\n    request =\n        new Request(\n            Method.PUT, \"riap://application/1/tenant/users/user/likes/entity/\" + activityId);\n    component.handle(request);\n\n    ActivityStreamsCollection feed = new ActivityStreamsCollection(get().getEntityAsText());\n\n    assertNotNull(feed.get(0).getCollabinateValue(\"likedByUser\"));\n  }\n"}, {"dataset": "getId", "exampleID": 123, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1010, "focalAPIEnd": 1021, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)", "createSourcesAndTargets(activity,Element,List<Link>,Expression)"], "useStart": [933, 1082], "useEnd": [1022, 1136], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/SequenceFlowFactory.java", "rawCode": "  /**\n   * Maps an activity to its BPEL4Chor representation. If the activity is not a block activity, task\n   * or intermediate event, an error is added to the output and the result will be null.\n   *\n   * @param act The activity to be mapped.\n   * @param links Links that are defined in the context of the activity.\n   * @param joinCond The join condition the mapped element should define.\n   * @return The created BPEL4Chor element the activity represents or null if the activity could not\n   *     be mapped.\n   */\n  public Element mapActivity(Activity act, List<Link> links, Expression joinCond) {\n    Element element = null;\n    if (act instanceof BlockActivity) {\n      element = mapBlockActivity((BlockActivity) act);\n    } else if (act instanceof Task) {\n      element = mapTask((Task) act);\n    } else if (act instanceof IntermediateEvent) {\n      element = mapIntermediateEvent((IntermediateEvent) act);\n    } else {\n      this.output.addError(\"Activity \" + \"could not be transformed to BPEL4Chor.\", act.getId());\n      return null;\n    }\n    if (element != null) {\n      createSourcesAndTargets(act, element, links, joinCond);\n    }\n    return element;\n  }\n"}, {"dataset": "getId", "exampleID": 124, "initialization": ["Activity activity = activity()"], "initializationStart": [1068], "initializationEnd": [1109], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["message(String)"], "tryExpressionStart": 683, "tryExpressionEnd": 687, "tryBlockStart": 683, "tryBlockEnd": 1802, "catchExpressionStart": 1719, "catchExpressionEnd": 1744, "catchBlockStart": 1719, "catchBlockEnd": 1802, "exceptionHandlingCallStart": [1752], "exceptionHandlingCallEnd": [1795], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1216, "focalAPIEnd": 1232, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["create(*,*,*,id,*)"], "useStart": [1320], "useEnd": [1591], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mfaerevaag/tidslampe/tree/master/src/controller/view/CalendarViewController.java", "rawCode": "  public void addRegisterTimeEntry() {\n    String startString =\n        viewState.getDateString().trim() + \" \" + viewState.getStartTimeString().trim();\n    String endString = viewState.getDateString().trim() + \" \" + viewState.getEndTimeString().trim();\n    DateFormat df = new SimpleDateFormat(\"dd-MM-yyyy HH:mm\");\n    df.setLenient(false);\n    Calendar startDate = Calendar.getInstance();\n    Calendar endDate = Calendar.getInstance();\n\n    Activity act = this.viewState.getSelectedActivity();\n    Project project = this.viewState.getSelectedProject();\n    if (act == null || project == null) {\n      Dialog.message(\"You must select project and activity\");\n      return;\n    }\n\n    try {\n      startDate.setTime(df.parse(startString));\n      endDate.setTime(df.parse(endString));\n\n      if ((startDate.get(Calendar.MINUTE) % 30) + endDate.get(Calendar.MINUTE) % 30 != 0) {\n        Dialog.message(\"Please use 30 minute time resolution\");\n        return;\n      }\n\n      int actId = 0;\n      if (this.viewState.getFixedState()) {\n        Activity fixedAct =\n            this.database\n                .activity()\n                .createFixedActivity(this.viewState.getSelectedActivityType(), \"\", 0, 0);\n        actId = fixedAct.getId();\n      } else {\n        actId = act.getId();\n      }\n      TimeEntry entry =\n          database\n              .registerTime()\n              .create(\n                  startDate.getTimeInMillis(),\n                  endDate.getTimeInMillis(),\n                  this.developer.getId(),\n                  actId,\n                  this.viewState.getAssistState());\n      if (entry == null)\n        Dialog.message(\"Specified date and time is overlapping existing time registrations\");\n\n    } catch (ParseException e) {\n      Dialog.message(\"Specified date is invalid\");\n    }\n\n    this.updateStartDate();\n  }\n"}, {"dataset": "getId", "exampleID": 125, "initialization": ["Activity activity = createActivity(String,int)"], "initializationStart": [388], "initializationEnd": [414], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 614, "focalAPIEnd": 633, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new LazyActivityTreeNode(id,*,*)"], "useStart": [589], "useEnd": [669], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tellary/timetracker/tree/master/src/test/java/ru/silvestrov/timetracker/model/activitytree/ActivityTreeManagerWithRealDataTest.java", "rawCode": "  @Test\n  public void testAggregateTimeSpentAfterAddingAnotherChild() {\n    ParentActivityTree tree =\n        (ParentActivityTree) activityTreeManager.loadAllActivitiesTree().getActivityTree();\n    tree.getAggregateTimeSpent();\n    long expectedTime = (60 + 30 + 780 + 78 + 80 + 180) * 1000;\n    Assert.assertEquals(expectedTime, tree.getAggregateTimeSpent());\n    Activity newActivity = createActivity(\"new\", 120);\n    for (ActivityTreeNode child : tree.getChildren()) {\n      if (child.getId() == a1.getId()) {\n        ((ParentActivityTree) child)\n            .addChild(\n                new LazyActivityTreeNode(newActivity.getId(), newActivity.getName(), 120 * 1000));\n      }\n    }\n\n    Assert.assertEquals(expectedTime + 120 * 1000, tree.getAggregateTimeSpent());\n  }\n"}, {"dataset": "getId", "exampleID": 126, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1530, "focalAPIEnd": 1553, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)", "activity.getLoop()", "activity.getId()", "addError(String,id)"], "useStart": [1438, 1571, 1873, 1805], "useEnd": [1554, 1596, 1896, 1897], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/StructuredElementsFactory.java", "rawCode": "  /**\n   * Creates a \"repeatUntil\" element for the given looping activity. The \"repeatUntil\" element will\n   * contain the given content element. If the content is null and the looping is a block activity,\n   * the content will be generated from the sequence flow within the sub-process of the block\n   * activity. If the content could not be generated, an error is added to the output. If there is\n   * no loop condition defined in the Loop object of the activiy, an error is added to the output,\n   * too.\n   *\n   * @param loopingActivity The activity representing the \"reoeatUntil\" element.\n   * @param content The element that will be added as content to the created \"repeatUntil element.\n   * @return The created \"repeatUntil\" element.\n   */\n  private Element createRepeatUntilLoop(Activity loopingActivity, Element content) {\n    Element result = this.document.createElement(\"repeatUntil\");\n\n    BPELUtil.setStandardAttributes(result, loopingActivity);\n\n    if (content != null) {\n      result.appendChild(content);\n    } else if (loopingActivity instanceof BlockActivity) {\n      BlockActivity activity = (BlockActivity) loopingActivity;\n      Element sequenceFlow =\n          new SequenceFlowFactory(\n                  this.diagram, this.document, activity.getSubProcess(), this.output)\n              .transformSequenceFlow();\n      if (sequenceFlow != null) {\n        result.appendChild(sequenceFlow);\n      }\n    } else {\n      this.output.addError(\n          \"Content of looping activity \" + \"could not be generated.\", loopingActivity.getId());\n    }\n\n    if (loopingActivity.getLoop().getLoopCondition() != null) {\n      result.appendChild(\n          this.supportingFactory.createExpressionElement(\n              \"condition\", loopingActivity.getLoop().getLoopCondition()));\n    } else {\n      this.output.addError(\"The loop \" + \"must define a loop condition.\", loopingActivity.getId());\n    }\n\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 127, "initialization": ["Activity activity = ResponseList<Activity>.get(int)"], "initializationStart": [422], "initializationEnd": [436], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 455, "focalAPIEnd": 470, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertThat(id,*)", "activity.getCategory()", "activity.getName()", "activity.getCreatedTime()"], "useStart": [444, 513, 570, 623], "useEnd": [494, 534, 587, 647], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/roundrop/facebook4j/tree/master/facebook4j-core/src/test/java/facebook4j/ActivitiesMethodsTest.java", "rawCode": "    @Test\n    public void id() throws Exception {\n      facebook.setMockJSON(\"mock_json/activity/activities.json\");\n      ResponseList<Activity> actuals = facebook.getActivities(\"1234567890123456\");\n      assertThat(facebook.getHttpMethod(), is(RequestMethod.GET));\n      assertThat(facebook.getEndpointURL(), is(pathOf(\"/1234567890123456/activities\")));\n\n      assertThat(actuals.size(), is(2));\n      Activity actual1 = actuals.get(0);\n      assertThat(actual1.getId(), is(\"111111111111111\"));\n      assertThat(actual1.getCategory(), is(\"Interest\"));\n      assertThat(actual1.getName(), is(\"Aaaaaaaa\"));\n      assertThat(actual1.getCreatedTime(), is(iso8601DateOf(\"2012-07-17T14:20:00+0000\")));\n      Activity actual2 = actuals.get(1);\n      assertThat(actual2.getId(), is(\"222222222222222\"));\n      assertThat(actual2.getCategory(), is(\"Interest\"));\n      assertThat(actual2.getName(), is(\"Bbbbbbbb\"));\n      assertThat(actual2.getCreatedTime(), is(iso8601DateOf(\"2012-04-13T12:09:11+0000\")));\n    }\n"}, {"dataset": "getId", "exampleID": 128, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 757, "focalAPIEnd": 773, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,String,*)"], "useStart": [705], "useEnd": [817], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/transformation/factories/TopologyFactory.java", "rawCode": "  /**\n   * Determines all participant set data objects that are associated with the given activity.\n   *\n   * @param activity The activity the associated sets will be determined for\n   * @param direction The direction of the association connecting the activity with the set.\n   * @return A list with participant set data objects associated with the given activity. If no\n   *     participant set data object was found, an emtpy list will be returned.\n   */\n  private List<ParticipantSetDataObject> getAssociatedParticipantSets(\n      Activity activity, String direction) {\n    List<ParticipantSetDataObject> result = new ArrayList<ParticipantSetDataObject>();\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            activity.getId(), direction, ParticipantSetDataObject.class);\n    for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n      Association assoc = it.next();\n      result.add((ParticipantSetDataObject) assoc.getTarget());\n    }\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 129, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 168, "focalAPIEnd": 184, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/psc/tree/master/core/src/test/java/edu/northwestern/bioinformatics/studycalendar/dao/ActivityDaoTest.java", "rawCode": "  public void testGetByCodeAndSourceName() throws Exception {\n    Activity activity = dao.getByCodeAndSourceName(\"CS\", \"ICD9\");\n    assertEquals(\"Wrong id\", -98, (int) activity.getId());\n  }\n"}, {"dataset": "getId", "exampleID": 130, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 341, "focalAPIEnd": 357, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Activity.setId(id)", "activity.setTalking(Talking)", "activity.setClub(*)", "activity.setMerchant(*)", "activity.setDatetime(*)", "activity.setHeat(*)", "activity.setParticipantCount(int)", "uploadImage(activity,File,String,*)", "uploadVideo(activity,File,String,*)", "ActivityService.initTalking(activity,Activity)", "ActivityService.addOrUpdate(Talking,activity)", "ActivityService.update(activity)"], "useStart": [323, 471, 524, 571, 626, 681, 728, 860, 991, 1273, 1331, 1389], "useEnd": [358, 516, 563, 618, 673, 720, 791, 985, 1112, 1323, 1377, 1421], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wayne0332/xiaojh/tree/master/src/com/tjxjh/action/ActivityAction.java", "rawCode": "  @Action(\n    value = \"adminModifyActivity\",\n    results = {@Result(name = SUCCESS, type = REDIRECT_ACTION, location = \"adminActivitys\")}\n  )\n  @com.tjxjh.annotation.Auth(auths = {AuthEnum.ADMIN})\n  public String adminModifyActivity() {\n    user = Auth.getUserFromSession();\n    Activity oldactivity = new Activity();\n    oldactivity.setId(activity.getId());\n    oldactivity = activityService.findByHql(user, merchant, oldactivity);\n    if (oldactivity != null) {\n      activity.setTalking(oldactivity.getTalking());\n      activity.setClub(oldactivity.getClub());\n      activity.setMerchant(oldactivity.getMerchant());\n      activity.setDatetime(oldactivity.getDatetime());\n      activity.setHeat(oldactivity.getHeat());\n      activity.setParticipantCount(oldactivity.getParticipantCount());\n    } else {\n      return ERROR;\n    }\n    boolean upimg =\n        activityService.uploadImage(\n            activity, uploadImage, uploadImageFileName, UPLOAD_IMAGE_PATH + uploadImageFileName);\n    activityService.uploadVideo(\n        activity, uploadVideo, uploadVideoFileName, UPLOAD_IMAGE_PATH + uploadVideoFileName);\n    if (!upimg) {\n      return ERROR;\n    }\n    if (!activity.getStatus().equals(\"REFUSE\") && !activity.getStatus().equals(\"APPLY\")) {\n      Talking talking = activityService.initTalking(activity, oldactivity);\n      activityService.addOrUpdate(talking, activity);\n    }\n    activityService.update(activity);\n    return SUCCESS;\n  }\n"}, {"dataset": "getId", "exampleID": 131, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 246, "focalAPIEnd": 262, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Action(String,*,id)"], "useStart": [201], "useEnd": [263], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rickyclarkson/katari/tree/master/dev/katari-search/src/test/java/com/globant/katari/search/domain/mock/ActivitySearchAdapterExample.java", "rawCode": "  public SearchResultElement convert(final Object o, final float score) {\n\n    Activity activity = (Activity) o;\n\n    ArrayList<Action> actions;\n    actions = new ArrayList<Action>();\n\n    actions.add(new Action(\"Edit\", null, \"userEdit.do?id=\" + activity.getId()));\n    actions.add(new Action(\"Delete\", null, \"userDelete.do?id=\" + activity.getId()));\n\n    StringBuilder description = new StringBuilder();\n    description.append(\"Activity - name: \" + activity.getName());\n\n    return new SearchResultElement(\n        \"Activity\",\n        activity.getName(),\n        description.toString(),\n        \"activity.do?id=\" + activity.getId(),\n        actions,\n        score);\n  }\n"}, {"dataset": "getId", "exampleID": 132, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(activity.getId()<0)", "guardType": "IF {", "guardExpressionStart": 164, "guardExpressionEnd": 189, "guardBlockStart": 164, "guardBlockEnd": 267, "focalAPI": "id = activity.getId()", "focalAPIStart": 168, "focalAPIEnd": 184, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setParameter(*,id)", "activity.getName()", "activity.getText()"], "useStart": [622, 709, 769], "useEnd": [668, 727, 787], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MichaelSieger/Hrm/tree/master/de.hswt.hrm.catalog.dao.jdbc/src/de/hswt/hrm/catalog/dao/jdbc/ActivityDao.java", "rawCode": "  @Override\n  public void update(Activity activity) throws ElementNotFoundException, SaveException {\n    checkNotNull(activity, \"Activity must not be null.\");\n\n    if (activity.getId() < 0) {\n      throw new ElementNotFoundException(\"Element has no valid ID.\");\n    }\n\n    SqlQueryBuilder builder = new SqlQueryBuilder();\n    builder.update(TABLE_NAME, Fields.NAME, Fields.TEXT);\n    builder.where(Fields.ID);\n\n    final String query = builder.toString();\n\n    try (Connection con = DatabaseFactory.getConnection()) {\n      try (NamedParameterStatement stmt = NamedParameterStatement.fromConnection(con, query)) {\n        stmt.setParameter(Fields.ID, activity.getId());\n        stmt.setParameter(Fields.NAME, activity.getName());\n        stmt.setParameter(Fields.TEXT, activity.getText());\n\n        int affectedRows = stmt.executeUpdate();\n        if (affectedRows != 1) {\n          throw new SaveException();\n        }\n      }\n    } catch (SQLException | DatabaseException e) {\n      throw new SaveException(e);\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 133, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "activity.getActivities().size()!=1", "guardType": "IF {", "guardExpressionStart": 623, "guardExpressionEnd": 670, "guardBlockStart": 623, "guardBlockEnd": 821, "focalAPI": "id = activity.getId()", "focalAPIStart": 772, "focalAPIEnd": 794, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)", "activity.getActivities()", "activity.get(int)", "activity.getId()", "addError(String,id)"], "useStart": [679, 842, 842, 1020, 927], "useEnd": [795, 872, 879, 1042, 1043], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/transformation/factories/GeneralizedFlowMapper.java", "rawCode": "  /**\n   * Finishes the mapping of the generalized flow component, if there is only one task left. This\n   * task must be a folded task. A \"links\" element has to be added to the BPEL code belonging to\n   * this task if links were created. This \"links\" element is generated from the links created\n   * during the mapping.\n   *\n   * @param links The links created during the mapping\n   * @return The folded task representing the generalized flow component. The result is null if\n   *     there is more than one activity left or the activity is not a folded task.\n   */\n  private FoldedTask finishFlow(List<Link> links) {\n    if (this.component.getActivities().size() != 1) {\n      this.output.addError(\n          \"A generalized flow pattern could not be mapped correctly.\", this.component.getId());\n      return null;\n    }\n\n    Activity act = this.component.getActivities().get(0);\n    if (!(act instanceof FoldedTask)) {\n      this.output.addError(\n          \"A generalized flow pattern could not be mapped correctly.\", this.component.getId());\n      return null;\n    }\n\n    Element element = ((FoldedTask) act).getBPELElement();\n    if (element == null) {\n      this.output.addError(\n          \"An Activity could not be mapped correctly, since the BPELElement is null\", act.getId());\n      return null;\n    }\n    Element linksElement =\n        new SupportingFactory(this.diagram, this.document, this.output).createLinks(links);\n    if (linksElement != null) {\n      Node child = element.getFirstChild();\n      if (child == null) {\n        element.appendChild(linksElement);\n      } else {\n        element.insertBefore(linksElement, child);\n      }\n    }\n\n    return (FoldedTask) act;\n  }\n"}, {"dataset": "getId", "exampleID": 134, "initialization": ["Activity activity = parseActivity(*)"], "initializationStart": [793], "initializationEnd": [836], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setParentContainer(SubProcess)"], "configurationStart": [880], "configurationEnd": [919], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 846, "guardExpressionEnd": 867, "guardBlockStart": 846, "guardBlockEnd": 1036, "focalAPI": "id = activity.getId()", "focalAPIStart": 998, "focalAPIEnd": 1014, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["putObject(id,Activity)"], "useStart": [975], "useEnd": [1025], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/parser/SubProcessParser.java", "rawCode": "  /**\n   * Parses the activity nodes contained in the given activities node. It creates an activity for\n   * each activity node and adds this activity to the sub-process activities and to the diagram.\n   *\n   * @param subProcess The sub process to add the parsed activities to.\n   * @param activitiesNode The activities node to be parse.\n   */\n  private void parseActivities(SubProcess subProcess, Node activitiesNode) {\n    NodeList activityNodes = activitiesNode.getChildNodes();\n    ActivityParser parser = new ActivityParser(this.diagram, this.output);\n    for (int i = 0; i < activityNodes.getLength(); i++) {\n      Node activityNode = activityNodes.item(i);\n      if ((activityNode.getLocalName() != null) && activityNode.getLocalName().equals(\"Activity\")) {\n        Activity activity = parser.parseActivity(activityNodes.item(i));\n        if (activity != null) {\n          activity.setParentContainer(subProcess);\n          subProcess.addActivity(activity);\n          this.diagram.putObject(activity.getId(), activity);\n        }\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 135, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 314, "focalAPIEnd": 329, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setParameter(*,id)"], "useStart": [673], "useEnd": [732], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MichaelSieger/Hrm/tree/master/de.hswt.hrm.catalog.dao.jdbc/src/de/hswt/hrm/catalog/dao/jdbc/ActivityDao.java", "rawCode": "  @Override\n  public void addToCurrent(Current current, Activity activity) throws SaveException {\n\n    SqlQueryBuilder builder = new SqlQueryBuilder();\n    builder.insert(CROSS_TABLE_NAME, Fields.CROSS_CURRENT_FK, Fields.CROSS_ACTIVITY_FK);\n\n    // Insert target and current if not already in the database\n    if (current.getId() < 0) {\n      current = currentDao.insert(current);\n    }\n\n    if (activity.getId() < 0) {\n      activity = insert(activity);\n    }\n\n    final String query = builder.toString();\n\n    try (Connection con = DatabaseFactory.getConnection()) {\n      try (NamedParameterStatement stmt = NamedParameterStatement.fromConnection(con, query)) {\n        stmt.setParameter(Fields.CROSS_CURRENT_FK, current.getId());\n        stmt.setParameter(Fields.CROSS_ACTIVITY_FK, activity.getId());\n\n        int affectedRows = stmt.executeUpdate();\n        if (affectedRows != 1) {\n          throw new SaveException();\n        }\n      }\n\n    } catch (SQLException | DatabaseException e) {\n      throw new SaveException(e);\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 136, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 782, "focalAPIEnd": 798, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [728], "useEnd": [851], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Checks, if the multiple instance loop corresponds a forEach that iterates over a set of\n   * participants (BPEL4Chor forEach). In this case there is no counter variable data object defined\n   * for the loop.\n   *\n   * @param activity The activity to check\n   * @return True if the activity is a BPEL4Chor forEach (no counter variable associated with the\n   *     loop). False otherwise.\n   */\n  private boolean isBPEL4ChorForEach(Activity activity) {\n    if ((activity.getLoop() != null)\n        && (activity.getLoop().getLoopType().equals(Loop.TYPE_MULITPLE))) {\n      // if there is a counter variable data object defined\n      // the loop is not a BPEL4ChorForEach\n      List<Association> associations =\n          this.diagram.getAssociationsWithSource(\n              activity.getId(), Association.DIRECTION_TO, VariableDataObject.class);\n\n      for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n        VariableDataObject object = (VariableDataObject) it.next().getSource();\n        if (object.getType().equals(VariableDataObject.TYPE_COUNTER)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "getId", "exampleID": 137, "initialization": ["Activity activity = Iterator<Activity>.next()"], "initializationStart": [492], "initializationEnd": [501], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setParentSwimlane(Swimlane)"], "configurationStart": [741], "configurationEnd": [777], "guardCondition": "!(activity.getParentSwimlane()==null)", "guardType": "IF {", "guardExpressionStart": 509, "guardExpressionEnd": 550, "guardBlockStart": 509, "guardBlockEnd": 901, "focalAPI": "id = activity.getId()", "focalAPIStart": 875, "focalAPIEnd": 891, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [802], "useEnd": [892], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/parser/SwimlaneParser.java", "rawCode": "  /**\n   * Sets the parent swimlane for the given activities. If an activity already has a parent swimlane\n   * specified, an error is added to the output.\n   *\n   * @param swimlane The parent swimlane for the given activities.\n   * @param activities The activities to set the parent swimlane for.\n   */\n  private void setSwimlaneForActivities(Swimlane swimlane, List<Activity> activities) {\n    for (Iterator<Activity> it = activities.iterator(); it.hasNext(); ) {\n      Activity activity = it.next();\n      if (activity.getParentSwimlane() == null) {\n        if (activity instanceof BlockActivity) {\n          setSwimlaneForActivities(\n              swimlane, ((BlockActivity) activity).getSubProcess().getActivities());\n        }\n        activity.setParentSwimlane(swimlane);\n      } else {\n        this.output.addError(\"Activity \" + \" is located in multiple swimlanes.\", activity.getId());\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 138, "initialization": ["Activity activity = StartEvent.getSuccessor()"], "initializationStart": [890], "initializationEnd": [910], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1361, "focalAPIEnd": 1378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1289], "useEnd": [1379], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/SequenceFlowFactory.java", "rawCode": "  /**\n   * Maps a trivial sequence flow (see {@link #isTrivial(StartEvent, EndEvent)}) to its BPEL4Chor\n   * elements it represents. For this purpose the start event and the activity in between is mapped.\n   *\n   * @param start The start event of the sequence flow.\n   * @param end The end event of the sequence flow.\n   * @return The created BPEL4Chor element the sequence flow represents.\n   */\n  private Element mapTrivial(StartEvent start, EndEvent end) {\n    if (start.getSuccessor().equals(end)) {\n      // start is follwed directly by the end event\n      // can only be mapped, if start is a message start event\n      if (start.getTriggerType().equals(StartEvent.TRIGGER_MESSAGE)) {\n        return this.basicFactory.createReceiveElement(start, this.container instanceof Process);\n      }\n    } else if (start.getSuccessor().equals(end.getPredecessor())) {\n      Activity successor = start.getSuccessor();\n      Element result = null;\n      if (successor instanceof Task) {\n        result = mapTask((Task) successor);\n      } else if (successor instanceof BlockActivity) {\n        return mapBlockActivity((BlockActivity) successor);\n      } else if (successor instanceof IntermediateEvent) {\n        return mapIntermediateEvent((IntermediateEvent) successor);\n      } else {\n        this.output.addError(\"A trivial component was not generated correctly\", successor.getId());\n        return null;\n      }\n\n      if (start.getTriggerType().equals(StartEvent.TRIGGER_MESSAGE) && !this.messageHandler) {\n        // if start event is a message event, map start event as\n        // receive and create additional sequence element\n        // containing the receive and the already mapped element\n        Element receive =\n            this.basicFactory.createReceiveElement(start, this.container instanceof Process);\n\n        if (result.getNodeName().equals(\"sequence\")) {\n          result.insertBefore(receive, result.getFirstChild());\n          return result;\n        }\n        Element resultSequence = this.document.createElement(\"sequence\");\n        resultSequence.appendChild(receive);\n        resultSequence.appendChild(result);\n        return resultSequence;\n      }\n      return result;\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 139, "initialization": ["Activity activity = List.get(int)"], "initializationStart": [432], "initializationEnd": [445], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 461, "focalAPIEnd": 472, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["id.longValue()"], "useStart": [501], "useEnd": [518], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/catrip/tree/master/codebase/projects/tumor registry/test/edu/duke/cabig/tumorregistry/domain/ProcedureTest.java", "rawCode": "  public Long getNextId() throws Exception {\n    Long maxId = Long.valueOf(0);\n    Session session = HibernateUtil.currentSession();\n    Transaction tx = session.beginTransaction();\n\n    List result = new ArrayList();\n    result = session.createQuery(\"from Activity where id = (select max(id) from Activity)\").list();\n\n    tx.commit();\n    HibernateUtil.closeSession();\n    if (result.size() != 0) {\n      Activity obj = (Activity) result.get(0);\n      maxId = obj.getId();\n    }\n    return new Long((maxId.longValue() + 1));\n  }\n"}, {"dataset": "getId", "exampleID": 140, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 320, "focalAPIEnd": 344, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getPlannedActivitiesForActivity(id)", "activity.getId()", "getPlannedActivitiesForActivity(id)"], "useStart": [269, 465, 414], "useEnd": [345, 489, 490], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/psc/tree/master/web/src/test/java/edu/northwestern/bioinformatics/studycalendar/restlets/ActivityResourceTest.java", "rawCode": "  private void expectActivityUsedByPlannedCalendar(Activity expectedActivity, boolean isExcepted) {\n    if (isExcepted) {\n      List<PlannedActivity> plannedActivities = new ArrayList<PlannedActivity>();\n      plannedActivities.add(new PlannedActivity());\n      expect(plannedActivityDao.getPlannedActivitiesForActivity(expectedActivity.getId()))\n          .andReturn(plannedActivities);\n    } else {\n      expect(plannedActivityDao.getPlannedActivitiesForActivity(expectedActivity.getId()))\n          .andReturn(null);\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 141, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 166, "focalAPIEnd": 182, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getActivity(id)", "assertEquals(*,activity)", "deleteActivity(activity,*)", "activity.getId()", "getActivity(id)"], "useStart": [143, 130, 201, 290, 267], "useEnd": [183, 194, 248, 306, 307], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Cybion-Italy/elderspaces/tree/master/trunk/persistence/src/test/java/eu/elderspaces/persistence/EntitiesRepositoryTestCase.java", "rawCode": "  @Test\n  public void shouldTestActivities() throws RepositoryException {\n\n    repository.postActivity(activity, new Date());\n    assertEquals(repository.getActivity(activity.getId()), activity);\n\n    repository.deleteActivity(activity, new Date());\n\n    try {\n      repository.getActivity(activity.getId());\n    } catch (final RepositoryException e) {\n      assertTrue(true);\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 142, "initialization": ["Activity activity = getActivityFromATOMEntry(Feed,SyndEntryImpl,FeedObjectActivityBuilder)"], "initializationStart": [3923], "initializationEnd": [3982], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.clone()"], "configurationStart": [5077], "configurationEnd": [5093], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 7174, "focalAPIEnd": 7190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(id)"], "useStart": [7150], "useEnd": [7191], "hasFinally": 1, "cleanUpCall": ["Feed.setLastSeenGUID(String)", "Feed.setIsFeedBroken(Boolean)", "Feed.setLastPostDate(Date)", "new Date()", "getTime()", "setLastUpdated(*)", "Feed.setUpdateFrequency(Long)", "Feed.setPending(boolean)"], "finallyExpressionStart": 7658, "finallyExpressionEnd": 7666, "finallyBlockStart": 7658, "finallyBlockEnd": 7936, "cleanUpCallStart": [7674, 7716, 7756, 7818, 7818, 7798, 7859, 7907], "cleanUpCallEnd": [7708, 7748, 7790, 7828, 7838, 7851, 7899, 7929], "url": "https://github.com/chrismarx/cmestemp22/tree/master/server/src/main/java/org/eurekastreams/server/action/execution/feed/RefreshFeedExecution.java", "rawCode": "  /**\n   * {@inheritDoc}.\n   *\n   * <p>Grab all the feeds, set them as pending, and fire off an async job. to refresh each one.\n   */\n  public Serializable execute(final ActionContext inActionContext) throws ExecutionException {\n    Boolean brokenFeed = true;\n    String lastSeenGUID = \"\";\n    RefreshFeedRequest request = (RefreshFeedRequest) inActionContext.getParams();\n    Feed feed = feedFinder.execute(new FindByIdRequest(\"Feed\", request.getFeedId()));\n    Date lastPostDate = feed.getLastPostDate();\n    Long updateFrequency = null;\n    Boolean isOutOfOrder = false;\n\n    log.info(\"Processor feed: \" + feed.getUrl());\n    for (String oooFeed : outOfOrderFeeds) {\n      if (feed.getUrl().contains(oooFeed)) {\n        log.info(\"Feed marked out of order: \" + feed.getUrl());\n        isOutOfOrder = true;\n        break;\n      }\n    }\n\n    try {\n      // fetch the feeds\n      // Gives the fetcher the feed and a list of the requestors; the fetcher will decide if it can\n      // make a single\n      // unauthenticated request or if it needs to make one request per requestor. A set is used to\n      // prevent\n      // giving the fetcher any duplicates.\n      Set<String> requestorAccounts = new HashSet<String>();\n      for (FeedSubscriber feedSubscriber : feed.getFeedSubscribers()) {\n        requestorAccounts.add(feedSubscriber.getRequestor().getAccountId());\n      }\n      Map<String, SyndFeed> syndFeeds =\n          feedFetcherFactory.getSyndicatedFeed(feed.getUrl(), requestorAccounts);\n\n      FeedObjectActivityBuilder selectedObjectMapper = null;\n      for (ObjectBuilderForSpecificUrl entry : specificUrlMappers) {\n        if (entry.match(feed.getUrl())) {\n          selectedObjectMapper = entry.getBuilder();\n          break;\n        }\n      }\n\n      // iterate through all feed instances returned by the fetcher\n      List<Activity> insertedActivities = new LinkedList<Activity>();\n      for (Map.Entry<String, SyndFeed> mapEntry : syndFeeds.entrySet()) {\n        SyndFeed syndFeed = mapEntry.getValue();\n        List<FeedSubscriber> subscribers = getFeedSubscribers(mapEntry.getKey(), feed);\n\n        // check for update frequency info\n        if (updateFrequency == null) {\n          SyModule syMod = (SyModule) syndFeed.getModule(SyModule.URI);\n          if (syMod != null) {\n            updateFrequency =\n                getUpdateFrequency(syMod.getUpdatePeriod(), syMod.getUpdateFrequency());\n          }\n        }\n\n        if (syndFeed.getEntries().size() > 0) {\n          SyndEntryImpl entry = (SyndEntryImpl) syndFeed.getEntries().get(0);\n          lastSeenGUID = entry.getUri();\n        }\n\n        Boolean brokenOutOfOrder = false;\n\n        if (isOutOfOrder && feed.getLastSeenGUID() != null) {\n          brokenOutOfOrder = true;\n          // iterate through each entry in the feed instance\n          for (Object entryObject : syndFeed.getEntries()) {\n            try {\n              SyndEntryImpl entry = (SyndEntryImpl) entryObject;\n              if (feed.getLastSeenGUID().equals(entry.getUri())) {\n                log.info(\"Found matching GUID in out of order feed: \" + lastSeenGUID);\n                brokenOutOfOrder = false;\n                break;\n              }\n            } catch (Exception ex) {\n              log.warn(\n                  \"ATOM/RSS entry is not to spec. \"\n                      + \"Skipping entry and moving to the next one. Feed url: \"\n                      + feed.getUrl(),\n                  ex);\n            }\n          }\n        }\n\n        if (!brokenOutOfOrder) {\n          // iterate through each entry in the feed instance\n          for (Object entryObject : syndFeed.getEntries()) {\n            try {\n              SyndEntryImpl entry = (SyndEntryImpl) entryObject;\n\n              if (lastPostDate == null || entry.getPublishedDate().after(lastPostDate)) {\n                lastPostDate = entry.getPublishedDate();\n              }\n\n              Activity activity = getActivityFromATOMEntry(feed, entry, selectedObjectMapper);\n              // We were able to parse at least one good entry to completion, so the feed isn't\n              // broken.\n              brokenFeed = false;\n\n              if (isOutOfOrder && feed.getLastSeenGUID().equals(entry.getUri())) {\n                log.info(\"Match found based on GUID: \" + lastSeenGUID);\n                break;\n              } else {\n                log.info(\"No match found based on GUID: \" + entry.getUri());\n              }\n\n              if (!isOutOfOrder && !entry.getPublishedDate().after(feed.getLastPostDate())) {\n                log.info(\"Match found based on Date: \" + feed.getLastPostDate());\n                break;\n              } else {\n                log.info(\n                    \"No match found based on Date: \"\n                        + entry.getPublishedDate()\n                        + \" Last Post Date: \"\n                        + feed.getLastPostDate());\n              }\n\n              // create activities per subscriber\n              for (FeedSubscriber feedSubscriber : subscribers) {\n                Activity activityForIndividual = (Activity) activity.clone();\n\n                if (feedSubscriber.getEntityType().equals(EntityType.PERSON)) {\n                  Person person =\n                      personFinder.execute(\n                          new FindByIdRequest(\"Person\", feedSubscriber.getEntityId()));\n                  activityForIndividual.setActorId(person.getAccountId());\n                  activityForIndividual.setRecipientParentOrg(person.getParentOrganization());\n                  activityForIndividual.setRecipientStreamScope(person.getStreamScope());\n                  activityForIndividual.setIsDestinationStreamPublic(true);\n                } else if (feedSubscriber.getEntityType().equals(EntityType.GROUP)) {\n                  DomainGroup group =\n                      groupFinder.execute(\n                          new FindByIdRequest(\"DomainGroup\", feedSubscriber.getEntityId()));\n\n                  activityForIndividual.setActorId(group.getShortName());\n                  activityForIndividual.setRecipientParentOrg(group.getParentOrganization());\n                  activityForIndividual.setRecipientStreamScope(group.getStreamScope());\n                  activityForIndividual.setIsDestinationStreamPublic(group.isPublicGroup());\n                }\n                activityForIndividual.setActorType(feedSubscriber.getEntityType());\n                insertedActivities.add(activityForIndividual);\n              }\n\n            } catch (Exception ex) {\n              log.warn(\n                  \"ATOM/RSS entry is not to spec. \"\n                      + \"Skipping entry and moving to the next one. Feed url: \"\n                      + feed.getUrl(),\n                  ex);\n            }\n          }\n        }\n      }\n\n      // updateFeedMapper.execute(new PersistenceRequest<Feed>(feed));\n      if (!insertedActivities.isEmpty()) {\n        ArrayList<Long> insertedActivityIds = new ArrayList<Long>();\n        Collections.reverse(insertedActivities);\n        for (Activity activity : insertedActivities) {\n          activityDBInserter.execute(new PersistenceRequest<Activity>(activity));\n          insertedActivityIds.add(activity.getId());\n        }\n        Collections.reverse(insertedActivityIds);\n\n        // TODO: this is not performant; fix\n        if (cache.get(CacheKeys.BUFFERED_ACTIVITIES) == null) {\n          cache.setList(CacheKeys.BUFFERED_ACTIVITIES, insertedActivityIds);\n        } else {\n          cache.addToTopOfList(CacheKeys.BUFFERED_ACTIVITIES, insertedActivityIds);\n        }\n      }\n    } catch (Exception ex) {\n      log.error(\"Error retrieving feed: \" + feed.getUrl(), ex);\n    } finally {\n      feed.setLastSeenGUID(lastSeenGUID);\n      feed.setIsFeedBroken(brokenFeed);\n      feed.setLastPostDate(lastPostDate);\n      feed.setLastUpdated(new Date().getTime() / MS_IN_MIN);\n      feed.setUpdateFrequency(updateFrequency);\n      feed.setPending(false);\n    }\n\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 143, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.getTitle()"], "configurationStart": [175], "configurationEnd": [194], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 212, "focalAPIEnd": 228, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["valueOf(id)"], "useStart": [196], "useEnd": [229], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yukung/tasklet/tree/master/src/main/java/org/yukung/tasklet/dao/impl/ActivityDaoImpl.java", "rawCode": "  @Override\n  public void modifyTitle(Connection conn, Activity activity) throws SQLException {\n    String sql = getSQLFromPropertyFile(\"modifyTitle\");\n    Object[] params = {activity.getTitle(), Integer.valueOf(activity.getId())};\n    runner.update(conn, sql, params);\n  }\n"}, {"dataset": "getId", "exampleID": 144, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.getAttachedEvents(*)"], "configurationStart": [892], "configurationEnd": [957], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1136, "focalAPIEnd": 1152, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1007], "useEnd": [1153], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/transformation/factories/StructuredElementsFactory.java", "rawCode": "  /**\n   * Creates a \"terminationHandler\" element, if the activity has a termination event attached. The\n   * sequence flow within the termination handler represents the activities that will be contained\n   * in the \"terminationHandler\" element.\n   *\n   * <p>If there are multiple termination events attached to the activity an error is added to the\n   * output and the result will be null. This will also be done if there is no termination handler\n   * connected to the termination event.\n   *\n   * @param activity The activity to create the \"terminationHandler\" element for\n   * @return The created \"terminationHandler\" element or null if there are no termination events\n   *     attached to the activity. The result will also be null if an error occured.\n   */\n  public Element createTerminationHandlerElement(Activity activity) {\n\n    List<IntermediateEvent> attachedTermEvents =\n        activity.getAttachedEvents(IntermediateEvent.TRIGGER_TERMINATION);\n\n    if (attachedTermEvents.size() > 1) {\n      this.output.addError(\n          \"The activity \" + \"is not allowed to have more than one termination event attached. \",\n          activity.getId());\n      return null;\n    }\n\n    if (!attachedTermEvents.isEmpty()) {\n      IntermediateEvent event = attachedTermEvents.get(0);\n      Handler termHandler = event.getConnectedHandler();\n\n      if (termHandler == null) {\n        this.output.addError(\n            \"A termination handler attached the event \" + \"could not be found.\", event.getId());\n        return null;\n      }\n\n      Element result = this.document.createElement(\"terminationHandler\");\n      Element sequenceFlow =\n          new SequenceFlowFactory(\n                  this.diagram, this.document, termHandler.getSubProcess(), this.output)\n              .transformSequenceFlow();\n      if (sequenceFlow != null) {\n        // create additional scope if termination handler has\n        // additional variables defined\n        result.appendChild(createHandlerScope(termHandler, sequenceFlow));\n      }\n\n      return result;\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 145, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 260, "focalAPIEnd": 327, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/test/java/com/collabinate/server/resources/FeedResourceTest.java", "rawCode": "  @Test\n  public void collection_count_should_account_for_deleted_activities() {\n    // add activity to the stream of entity 1\n    Request request =\n        new Request(Method.POST, \"riap://application/1/tenant/entities/entity1/stream\");\n    String deleteId = (new Activity(component.handle(request).getEntityAsText())).getId();\n    component.handle(request);\n\n    // add activity to the stream of entity 2\n    request = new Request(Method.POST, \"riap://application/1/tenant/entities/entity2/stream\");\n    component.handle(request);\n    component.handle(request);\n    component.handle(request);\n\n    // follow the entities\n    request = new Request(Method.PUT, \"riap://application/1/tenant/users/user/following/entity1\");\n    component.handle(request);\n    request = new Request(Method.PUT, \"riap://application/1/tenant/users/user/following/entity2\");\n    component.handle(request);\n\n    request =\n        new Request(\n            Method.DELETE, \"riap://application/1/tenant/entities/entity1/stream/\" + deleteId);\n    component.handle(request);\n\n    ActivityStreamsCollection feed = new ActivityStreamsCollection(get().getEntityAsText());\n\n    assertEquals(4, feed.getTotalItems());\n  }\n"}, {"dataset": "getId", "exampleID": 146, "initialization": ["Activity activity = ResponseList<Activity>.get(int)"], "initializationStart": [390], "initializationEnd": [404], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 423, "focalAPIEnd": 438, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertThat(id,*)", "activity.getCategory()", "activity.getName()", "activity.getCreatedTime()"], "useStart": [412, 481, 538, 591], "useEnd": [462, 502, 555, 615], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/roundrop/facebook4j/tree/master/facebook4j-core/src/test/java/facebook4j/ActivitiesMethodsTest.java", "rawCode": "    @Test\n    public void me() throws Exception {\n      facebook.setMockJSON(\"mock_json/activity/activities.json\");\n      ResponseList<Activity> actuals = facebook.getActivities();\n      assertThat(facebook.getHttpMethod(), is(RequestMethod.GET));\n      assertThat(facebook.getEndpointURL(), is(pathOf(\"/me/activities\")));\n\n      assertThat(actuals.size(), is(2));\n      Activity actual1 = actuals.get(0);\n      assertThat(actual1.getId(), is(\"111111111111111\"));\n      assertThat(actual1.getCategory(), is(\"Interest\"));\n      assertThat(actual1.getName(), is(\"Aaaaaaaa\"));\n      assertThat(actual1.getCreatedTime(), is(iso8601DateOf(\"2012-07-17T14:20:00+0000\")));\n      Activity actual2 = actuals.get(1);\n      assertThat(actual2.getId(), is(\"222222222222222\"));\n      assertThat(actual2.getCategory(), is(\"Interest\"));\n      assertThat(actual2.getName(), is(\"Bbbbbbbb\"));\n      assertThat(actual2.getCreatedTime(), is(iso8601DateOf(\"2012-04-13T12:09:11+0000\")));\n    }\n"}, {"dataset": "getId", "exampleID": 147, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.getSeq()"], "configurationStart": [187], "configurationEnd": [204], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 223, "focalAPIEnd": 239, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["valueOf(id)"], "useStart": [207], "useEnd": [240], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yukung/tasklet/tree/master/src/main/java/org/yukung/tasklet/dao/impl/ActivityDaoImpl.java", "rawCode": "  @Override\n  public void updateSeq(Connection conn, Activity activity) throws SQLException {\n    String sql = getSQLFromPropertyFile(\"updateSeq\");\n    Object[] params = {Integer.valueOf(activity.getSeq()), Integer.valueOf(activity.getId())};\n    runner.update(conn, sql, params);\n  }\n"}, {"dataset": "getId", "exampleID": 148, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 245, "focalAPIEnd": 272, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/julianchurchill/Topical/tree/master/src/com/ChewieLouie/Topical/GooglePlus.java", "rawCode": "  private static Map<DataType, String> extractDataFromActivity(Activity activity) {\n    Map<DataType, String> values = null;\n    if (activity != null) {\n      values = new HashMap<DataType, String>();\n      putString(values, DataType.AUTHOR_ID, activity.getActor().getId());\n      putString(values, DataType.AUTHOR_IMAGE, activity.getActor().getImage().getUrl());\n      final String authorName = activity.getActor().getDisplayName();\n      putString(values, DataType.AUTHOR_NAME, authorName);\n      putString(values, DataType.COMMENTS, activity.getPlusObject().getReplies().toString());\n      if (activity.getUpdated() != null)\n        putString(values, DataType.MODIFICATION_TIME, activity.getUpdated().toStringRfc3339());\n      else putString(values, DataType.MODIFICATION_TIME, activity.getPublished().toStringRfc3339());\n      putString(values, DataType.POST_CONTENT, activity.getPlusObject().getContent());\n      putString(values, DataType.POST_ID, activity.getId());\n      putString(values, DataType.SUMMARY, activity.getTitle());\n      putString(values, DataType.TITLE, authorName);\n      putString(values, DataType.URL, activity.getUrl());\n      String reshareAuthorName = \"\";\n      if (activity.getPlusObject().getActor() != null)\n        reshareAuthorName = activity.getPlusObject().getActor().getDisplayName();\n      putString(values, DataType.RESHARE_AUTHOR_NAME, reshareAuthorName);\n    }\n    return values;\n  }\n"}, {"dataset": "getId", "exampleID": 149, "initialization": ["Activity activity = getParent()"], "initializationStart": [305], "initializationEnd": [327], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 395, "guardExpressionEnd": 415, "guardBlockStart": 395, "guardBlockEnd": 468, "focalAPI": "id = activity.getId()", "focalAPIStart": 436, "focalAPIEnd": 451, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["put(id,Activity)"], "useStart": [424], "useEnd": [461], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jogetworkflow/jw-community/tree/master/wflow-designer/src/main/java/org/enhydra/jawe/base/panel/StandardPanelGenerator.java", "rawCode": "  protected XMLPanel getPanelForTOAttribute(Transition transition) {\n    SequencedHashMap choices =\n        JaWEManager.getInstance().getTransitionHandler().getPossibleTargetActivities(transition);\n    String tTo = transition.getTo();\n\n    Activity current =\n        ((Activities) ((XMLCollectionElement) transition.getParent().getParent()).get(\"Activities\"))\n            .getActivity(tTo);\n    if (current != null) {\n      choices.put(current.getId(), current);\n    }\n\n    Activity choosen = null;\n    if (!tTo.equals(\"\")) {\n      choosen = (Activity) choices.get(tTo);\n    }\n\n    XMLAttribute to = (XMLAttribute) transition.get(\"To\");\n    SpecialChoiceElement cc =\n        new SpecialChoiceElement(\n            to, \"\", new ArrayList(choices.values()), choosen, true, \"Id\", \"To\", to.isRequired());\n    cc.setReadOnly(to.isReadOnly());\n    return new XMLComboPanel(\n        getPanelContainer(),\n        cc,\n        null,\n        false,\n        true,\n        false,\n        false,\n        JaWEManager.getInstance().getJaWEController().canModifyElement(to));\n  }\n"}, {"dataset": "getId", "exampleID": 150, "initialization": ["Activity activity = new Activity()"], "initializationStart": [61], "initializationEnd": [75], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setName(String)", "activity.setDeleted(boolean)"], "configurationStart": [81, 127], "configurationEnd": [121, 153], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 497, "focalAPIEnd": 513, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["find(*,id)", "activity.getId()", "remove(id)", "activity.getId()", "find(*,id)"], "useStart": [460, 668, 649, 866, 829], "useEnd": [514, 684, 685, 882, 883], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/smartly23/CaloryCounter/tree/master/CaloryCounter-BusinessLogic/src/test/java/cz/fi/muni/pa165/calorycounter/backend/dao/ActivityDaoTest.java", "rawCode": "  @Test\n  public void testRemove() {\n    Activity activity = new Activity();\n    activity.setName(\"Chopping wood slowww\");\n    activity.setDeleted(false);\n\n    context.getTransaction().begin();\n    context.persist(activity);\n    context.getTransaction().commit();\n\n    another_context = emf.createEntityManager(); // to avoid returning result from cache lvl 1\n    ActivityDao activityDao2 = new ActivityDaoImplJPA(another_context);\n    Activity testActivity = another_context.find(Activity.class, activity.getId());\n    // veryfying, that it is indeed in the database now:\n    assertNotNull(testActivity);\n\n    context.getTransaction().begin();\n    activityDao.remove(activity.getId());\n    context.getTransaction().commit();\n\n    another_context.clear(); // preco nefunguje aj em2.flush (obalene v transakcii)?\n    assertFalse(!another_context.find(Activity.class, activity.getId()).isDeleted());\n  }\n"}, {"dataset": "getId", "exampleID": 151, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 246, "focalAPIEnd": 262, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Action(String,*,id)"], "useStart": [201], "useEnd": [263], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/katari/Katari/tree/master/dev/katari-search/src/test/java/com/globant/katari/search/domain/mock/ActivitySearchAdapterExample.java", "rawCode": "  public SearchResultElement convert(final Object o, final float score) {\n\n    Activity activity = (Activity) o;\n\n    ArrayList<Action> actions;\n    actions = new ArrayList<Action>();\n\n    actions.add(new Action(\"Edit\", null, \"userEdit.do?id=\" + activity.getId()));\n    actions.add(new Action(\"Delete\", null, \"userDelete.do?id=\" + activity.getId()));\n\n    StringBuilder description = new StringBuilder();\n    description.append(\"Activity - name: \" + activity.getName());\n\n    return new SearchResultElement(\n        \"Activity\",\n        activity.getName(),\n        description.toString(),\n        \"activity.do?id=\" + activity.getId(),\n        actions,\n        score);\n  }\n"}, {"dataset": "getId", "exampleID": 152, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.save()"], "configurationStart": [157], "configurationEnd": [172], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 227, "focalAPIEnd": 243, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["activity.getById(*)", "assertEquals(activity,Activity)"], "useStart": [210, 279], "useEnd": [244, 309], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aidGer/aidGer/tree/master/tests/de/aidger/model/models/ActivityTest.java", "rawCode": "  /** Test of constructor, of class Activity. */\n  @Test\n  public void testConstructor() throws SienaException {\n    System.out.println(\"Constructor\");\n\n    activity.save();\n\n    Activity result = new Activity(activity.getById(activity.getId()));\n\n    assertNotNull(result);\n    assertEquals(activity, result);\n  }\n"}, {"dataset": "getId", "exampleID": 153, "initialization": ["Activity activity = parseActivity(*)"], "initializationStart": [793], "initializationEnd": [836], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setParentContainer(SubProcess)"], "configurationStart": [880], "configurationEnd": [919], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 846, "guardExpressionEnd": 867, "guardBlockStart": 846, "guardBlockEnd": 1036, "focalAPI": "id = activity.getId()", "focalAPIStart": 998, "focalAPIEnd": 1014, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["putObject(id,Activity)"], "useStart": [975], "useEnd": [1025], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/parser/SubProcessParser.java", "rawCode": "  /**\n   * Parses the activity nodes contained in the given activities node. It creates an activity for\n   * each activity node and adds this activity to the sub-process activities and to the diagram.\n   *\n   * @param subProcess The sub process to add the parsed activities to.\n   * @param activitiesNode The activities node to be parse.\n   */\n  private void parseActivities(SubProcess subProcess, Node activitiesNode) {\n    NodeList activityNodes = activitiesNode.getChildNodes();\n    ActivityParser parser = new ActivityParser(this.diagram, this.output);\n    for (int i = 0; i < activityNodes.getLength(); i++) {\n      Node activityNode = activityNodes.item(i);\n      if ((activityNode.getLocalName() != null) && activityNode.getLocalName().equals(\"Activity\")) {\n        Activity activity = parser.parseActivity(activityNodes.item(i));\n        if (activity != null) {\n          activity.setParentContainer(subProcess);\n          subProcess.addActivity(activity);\n          this.diagram.putObject(activity.getId(), activity);\n        }\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 154, "initialization": ["Activity activity = Iterator.next()"], "initializationStart": [558], "initializationEnd": [566], "hasTryCatch": 1, "exceptionType": "GenericEntityException", "exceptionHandlingCall": ["new PersistenceException(*)"], "tryExpressionStart": 578, "tryExpressionEnd": 582, "tryBlockStart": 578, "tryBlockEnd": 790, "catchExpressionStart": 697, "catchExpressionEnd": 730, "catchBlockStart": 697, "catchBlockEnd": 790, "exceptionHandlingCallStart": [750], "exceptionHandlingCallEnd": [777], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 628, "focalAPIEnd": 644, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["deleteDeadlines(String,id,SharkTransaction)", "activity.remove()"], "useStart": [596, 666], "useEnd": [652, 683], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AsherBond/opentaps/tree/master/specialpurpose/shark/src/org/ofbiz/shark/instance/EntityPersistentMgr.java", "rawCode": "  public void deleteProcess(String processId, boolean admin, SharkTransaction trans)\n      throws PersistenceException {\n    Delegator delegator = SharkContainer.getDelegator();\n    if (admin) {\n      if (Debug.infoOn()) Debug.log(\":: deleteProcess ::\", module);\n      Process process = (Process) this.restoreProcess(processId, trans);\n      List activities = this.getAllActivitiesForProcess(processId, trans);\n      if (activities != null) {\n        Iterator i = activities.iterator();\n        while (i.hasNext()) {\n          Activity activity = (Activity) i.next();\n          try {\n            this.deleteDeadlines(processId, activity.getId(), trans);\n            activity.remove();\n          } catch (GenericEntityException e) {\n            throw new PersistenceException(e);\n          }\n        }\n      }\n      try {\n        delegator.removeByAnd(\n            org.ofbiz.shark.SharkConstants.WfActivity,\n            UtilMisc.toMap(org.ofbiz.shark.SharkConstants.subFlowId, processId));\n\n        process.remove();\n      } catch (Exception e) {\n        throw new PersistenceException(e);\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 155, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 782, "focalAPIEnd": 798, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [728], "useEnd": [851], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/transformation/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Checks, if the multiple instance loop corresponds a forEach that iterates over a set of\n   * participants (BPEL4Chor forEach). In this case there is no counter variable data object defined\n   * for the loop.\n   *\n   * @param activity The activity to check\n   * @return True if the activity is a BPEL4Chor forEach (no counter variable associated with the\n   *     loop). False otherwise.\n   */\n  private boolean isBPEL4ChorForEach(Activity activity) {\n    if ((activity.getLoop() != null)\n        && (activity.getLoop().getLoopType().equals(Loop.TYPE_MULITPLE))) {\n      // if there is a counter variable data object defined\n      // the loop is not a BPEL4ChorForEach\n      List<Association> associations =\n          this.diagram.getAssociationsWithSource(\n              activity.getId(), Association.DIRECTION_TO, VariableDataObject.class);\n\n      for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n        VariableDataObject object = (VariableDataObject) it.next().getSource();\n        if (object.getType().equals(VariableDataObject.TYPE_COUNTER)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "getId", "exampleID": 156, "initialization": ["Activity activity = Iterator<Activity>.next()"], "initializationStart": [492], "initializationEnd": [501], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setParentSwimlane(Swimlane)"], "configurationStart": [741], "configurationEnd": [777], "guardCondition": "!(activity.getParentSwimlane()==null)", "guardType": "IF {", "guardExpressionStart": 509, "guardExpressionEnd": 550, "guardBlockStart": 509, "guardBlockEnd": 901, "focalAPI": "id = activity.getId()", "focalAPIStart": 875, "focalAPIEnd": 891, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [802], "useEnd": [892], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/parser/SwimlaneParser.java", "rawCode": "  /**\n   * Sets the parent swimlane for the given activities. If an activity already has a parent swimlane\n   * specified, an error is added to the output.\n   *\n   * @param swimlane The parent swimlane for the given activities.\n   * @param activities The activities to set the parent swimlane for.\n   */\n  private void setSwimlaneForActivities(Swimlane swimlane, List<Activity> activities) {\n    for (Iterator<Activity> it = activities.iterator(); it.hasNext(); ) {\n      Activity activity = it.next();\n      if (activity.getParentSwimlane() == null) {\n        if (activity instanceof BlockActivity) {\n          setSwimlaneForActivities(\n              swimlane, ((BlockActivity) activity).getSubProcess().getActivities());\n        }\n        activity.setParentSwimlane(swimlane);\n      } else {\n        this.output.addError(\"Activity \" + \" is located in multiple swimlanes.\", activity.getId());\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 157, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 166, "focalAPIEnd": 214, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/test/java/com/collabinate/server/resources/StreamResourceTest.java", "rawCode": "  @Test\n  public void liked_item_in_stream_should_contain_user_like_indication() {\n    // add activity to the stream of entity and get the ID\n    String activityId = (new Activity(post().getEntityAsText())).getId();\n\n    // like the entity\n    Request request =\n        new Request(\n            Method.PUT, \"riap://application/1/tenant/users/user/likes/entity/\" + activityId);\n    component.handle(request);\n\n    ActivityStreamsCollection stream =\n        new ActivityStreamsCollection(get(\"?userLiked=user\").getEntityAsText());\n\n    assertNotNull(stream.get(0).getCollabinateValue(\"likedByUser\"));\n  }\n"}, {"dataset": "getId", "exampleID": 158, "initialization": ["Activity activity = new Activity(*)"], "initializationStart": [509], "initializationEnd": [588], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 612, "focalAPIEnd": 626, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/test/java/com/collabinate/server/resources/StreamResourceTest.java", "rawCode": "  @Test\n  public void existing_comments_on_activity_should_be_added_to_its_comments() {\n    // create an activity that has a comment\n    String commentContent = \"random test comment\";\n    ActivityStreamsObject comment = new ActivityStreamsObject(commentContent);\n    ActivityStreamsCollection comments = new ActivityStreamsCollection();\n    comments.add(comment);\n    Activity activity = new Activity();\n    activity.setReplies(comments);\n\n    // post the activity to the stream\n    Activity posted =\n        new Activity(post(activity.toString(), MediaType.TEXT_PLAIN).getEntityAsText());\n    String postedId = posted.getId();\n\n    // ensure comment exists as addressable item\n    Request request =\n        new Request(\n            Method.GET,\n            \"riap://application/1/tenant/entities/entity/stream/\" + postedId + \"/comments\");\n    comments = new ActivityStreamsCollection(component.handle(request).getEntityAsText());\n\n    assertEquals(commentContent, comments.get(0).getContent());\n    assertNotNull(comments.get(0).getId());\n  }\n"}, {"dataset": "getId", "exampleID": 159, "initialization": ["Activity activity = EntityManager.merge(Activity)"], "initializationStart": [238], "initializationEnd": [254], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 270, "focalAPIEnd": 286, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/smartly23/CaloryCounter/tree/master/CaloryCounter-BusinessLogic/src/main/java/cz/fi/muni/pa165/calorycounter/backend/dao/impl/ActivityDaoImplJPA.java", "rawCode": "  @Override\n  public Long create(Activity entity) {\n    if (entity == null) {\n      throw new IllegalArgumentException(\"Invalid entity (Activity): \" + entity);\n    }\n    log.debug(\"Creating \" + entity.toString());\n    Activity activity = em.merge(entity);\n    Long id = activity.getId();\n    log.debug(\"Created \" + activity.toString() + \". Assigned ID: \" + id);\n    return id;\n  }\n"}, {"dataset": "getId", "exampleID": 160, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 265, "focalAPIEnd": 281, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(id,*)"], "useStart": [252], "useEnd": [303], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/unpush/apache-incubator-shindig/tree/master/java/social-api/src/test/java/org/apache/shindig/social/opensocial/util/BeanXStreamConverterTest.java", "rawCode": "  public void testActivityToXml() throws Exception {\n    String xml = XSDValidator.validateOpenSocial(beanXmlConverter.convertToString(activity));\n\n    Element element = XmlUtil.parse(xml);\n    Node id = element.getElementsByTagName(\"id\").item(0);\n    assertEquals(activity.getId(), id.getTextContent());\n  }\n"}, {"dataset": "getId", "exampleID": 161, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 172, "focalAPIEnd": 220, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/test/java/com/collabinate/server/resources/StreamResourceTest.java", "rawCode": "  @Test\n  public void unliked_item_in_stream_should_not_contain_user_like_indication() {\n    // add activity to the stream of entity and get the ID\n    String activityId = (new Activity(post().getEntityAsText())).getId();\n\n    // like the entity\n    Request request =\n        new Request(\n            Method.PUT, \"riap://application/1/tenant/users/user/likes/entity/\" + activityId);\n    component.handle(request);\n\n    // unlike the entity\n    request =\n        new Request(\n            Method.DELETE, \"riap://application/1/tenant/users/user/likes/entity/\" + activityId);\n    component.handle(request);\n\n    ActivityStreamsCollection stream =\n        new ActivityStreamsCollection(get(\"?userLiked=user\").getEntityAsText());\n\n    assertNull(stream.get(0).getCollabinateValue(\"likedByUser\"));\n  }\n"}, {"dataset": "getId", "exampleID": 162, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.getAttachedEvents(*)"], "configurationStart": [900], "configurationEnd": [966], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1144, "focalAPIEnd": 1160, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1015], "useEnd": [1161], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/StructuredElementsFactory.java", "rawCode": "  /**\n   * Creates a \"compensationHandler\" element, if the activity has a compensation event attached. The\n   * sequence flow within the compensation handler represents the activities that will be contained\n   * in the \"compensationHandler\" element.\n   *\n   * <p>If there are multiple compensation events attached to the activity an error is added to the\n   * output and the result will be null. This will also be done if there is no compensation handler\n   * connected to the termination event.\n   *\n   * @param activity The activity to create the \"compensationHandler\" element for\n   * @return The created \"terminationHandler\" element or null if there are no termination events\n   *     attached to the activity. The result will also be null if an error occured.\n   */\n  public Element createCompensationHandlerElement(Activity activity) {\n\n    List<IntermediateEvent> attachedCompEvents =\n        activity.getAttachedEvents(IntermediateEvent.TRIGGER_COMPENSATION);\n    if (attachedCompEvents.size() > 1) {\n      this.output.addError(\n          \"The activity is not allowed to \" + \"have more than one compensation event attached.\",\n          activity.getId());\n    }\n    if (!attachedCompEvents.isEmpty()) {\n      IntermediateEvent event = attachedCompEvents.get(0);\n      Handler compHandler = this.diagram.getAssociatedCompensationHandler(event);\n      if (compHandler == null) {\n        this.output.addError(\n            \"A compensation handler attached to this event \" + \"could not be found.\",\n            event.getId());\n        return null;\n      }\n\n      Element result = this.document.createElement(\"compensationHandler\");\n      Element sequenceFlow =\n          new SequenceFlowFactory(\n                  this.diagram, this.document, compHandler.getSubProcess(), this.output)\n              .transformSequenceFlow();\n      if (sequenceFlow != null) {\n        // create additional scope if compensation handler has\n        // additional variables defined\n        result.appendChild(createHandlerScope(compHandler, sequenceFlow));\n      }\n      return result;\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 163, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 582, "focalAPIEnd": 605, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [543], "useEnd": [664], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpel4chor/model/Diagram.java", "rawCode": "  /**\n   * Determines the first participant set data object that is associated with the given activity.\n   * Only associations with direction To are considered (association from data object to activity).\n   *\n   * @param loopingActivity A multiple instance looping activity.\n   * @return The first participant set data object associated with the given activity. Or null of no\n   *     participant set was found.\n   */\n  public ParticipantSetDataObject getLoopCounterSet(Activity loopingActivity) {\n    List<Association> associations =\n        getAssociationsWithSource(\n            loopingActivity.getId(), Association.DIRECTION_TO, ParticipantSetDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantSetDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 164, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 142, "focalAPIEnd": 155, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Activity.setId(id)", "activity.getName()"], "useStart": [129, 183], "useEnd": [156, 198], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BigLep/ChuckanutBayFoodsInternal/tree/master/src/com/chuckanutbay/webapp/common/server/DtoUtils.java", "rawCode": "        @Override\n        public ActivityDto apply(Activity input) {\n          ActivityDto output = new ActivityDto();\n          output.setId(input.getId());\n          output.setName(input.getName());\n          return output;\n        }\n"}, {"dataset": "getId", "exampleID": 165, "initialization": ["Activity activity = new Activity(*)"], "initializationStart": [533], "initializationEnd": [612], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 636, "focalAPIEnd": 650, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/test/java/com/collabinate/server/resources/StreamResourceTest.java", "rawCode": "  @Test\n  public void existing_likes_on_activity_should_be_added_to_its_likes() {\n    // create an activity that has a like in it by a particular user\n    ActivityStreamsObject actor = new ActivityStreamsObject();\n    actor.setId(\"user\");\n    Activity like = new Activity();\n    like.setActor(actor);\n    ActivityStreamsCollection likes = new ActivityStreamsCollection();\n    likes.add(like);\n    Activity activity = new Activity();\n    activity.setLikes(likes);\n\n    // post the activity to the stream\n    Activity posted =\n        new Activity(post(activity.toString(), MediaType.TEXT_PLAIN).getEntityAsText());\n    String postedId = posted.getId();\n\n    // ensure like exists as addressable item\n    Request request =\n        new Request(\n            Method.GET,\n            \"riap://application/1/tenant/entities/entity/stream/\" + postedId + \"/likes\");\n    likes = new ActivityStreamsCollection(component.handle(request).getEntityAsText());\n    like = new Activity(likes.get(0).toString());\n\n    assertEquals(actor.getId(), like.getActor().getId());\n  }\n"}, {"dataset": "getId", "exampleID": 166, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 593, "focalAPIEnd": 609, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["createActivityUri(id)", "activity.getUpdated()", "activity.getTitle()", "activity.getObject()", "activity.getId()", "Activity.setId(id)", "activity.getTitle()", "activity.getActor()", "activity.getActor()", "activity.getUrl()", "activity.getPublished()", "activity.getUpdated()", "activity.getObject()"], "useStart": [575, 741, 1010, 1123, 1604, 1591, 1710, 1806, 1972, 2216, 2345, 2464, 2608], "useEnd": [610, 762, 1029, 1143, 1620, 1621, 1729, 1825, 1991, 2233, 2368, 2485, 2628], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/m0ep/master-thesis/tree/master/source/socc/socc-core/src/main/java/de/m0ep/socc/core/connector/google/plus/GooglePlusSiocUtils.java", "rawCode": "  /**\n   * Crates a {@link Post} for an {@link Activity}.\n   *\n   * @param connector Used Connector\n   * @param activity The {@link Activity} to convert.\n   * @param container The parent {@link Container} of that {@link Activity}.\n   * @return A {@link Post} convertet from the {@link Activity}.\n   */\n  public static Post createSiocPost(\n      final GooglePlusConnector connector, final Activity activity, final Container container) {\n    Node serviceEndpoint = connector.getService().getServiceEndpoint();\n    Model model = connector.getContext().getModel();\n    URI uri = createActivityUri(activity.getId());\n\n    Post result = null;\n    if (Post.hasInstance(model, uri)) {\n      result = Post.getInstance(model, uri);\n\n      if (null != activity.getUpdated()) {\n        Node modifiedNode =\n            Builder.createPlainliteral(DateUtils.formatISO8601(activity.getUpdated().getValue()));\n\n        if (!result.hasModified(modifiedNode)) {\n          result.setModified(modifiedNode);\n\n          if (null != activity.getTitle()) {\n            result.setTitle(activity.getTitle());\n          }\n\n          String content = activity.getObject().getContent();\n          result.setContent(StringUtils.stripHTML(content));\n\n          result.removeAllAttachments();\n          if (null != activity.getObject().getAttachments()) {\n            for (Attachments attachments : activity.getObject().getAttachments()) {\n              result.addAttachment(Builder.createURI(attachments.getUrl()));\n            }\n          }\n        }\n      }\n    } else {\n      result = new Post(model, uri, true);\n      result.setId(activity.getId());\n      result.setIsPartOf(connector.getStructureReader().getSite());\n\n      if (null != activity.getTitle()) {\n        result.setTitle(activity.getTitle());\n      }\n\n      if (null != activity.getActor()) {\n        UserAccount creator = null;\n        try {\n          creator =\n              UserAccountUtils.findUserAccount(\n                  model, activity.getActor().getId(), serviceEndpoint.asURI());\n        } catch (NotFoundException e) {\n          creator = createSiocUserAccount(connector, activity.getActor());\n        }\n\n        result.setCreator(creator);\n      }\n\n      if (null != activity.getUrl()) {\n        result.addSeeAlso(Builder.createURI(activity.getUrl()));\n      }\n\n      Date createdDate = new Date(activity.getPublished().getValue());\n      result.setCreated(DateUtils.formatISO8601(createdDate));\n\n      if (null != activity.getUpdated()) {\n        result.setModified(DateUtils.formatISO8601(activity.getUpdated().getValue()));\n      }\n\n      String content = activity.getObject().getContent();\n      result.setContent(StringUtils.stripHTML(content));\n\n      if (null != activity.getObject().getAttachments()) {\n        for (Attachments attachments : activity.getObject().getAttachments()) {\n          result.addAttachment(Builder.createURI(attachments.getUrl()));\n        }\n      }\n\n      if (null != container) {\n        result.setContainer(container);\n        container.addContainerOf(result);\n        SiocUtils.incNumItems(container);\n        SiocUtils.updateLastItemDate(container, createdDate);\n      }\n    }\n\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 167, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 88, "focalAPIEnd": 99, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["activity.getId()", "new Cookie(id,String)"], "useStart": [111, 67], "useEnd": [122, 123], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wayne0332/xiaojh/tree/master/src/com/tjxjh/service/ActivityService.java", "rawCode": "  public void addCanyuCookie(Activity tak) {\n    Cookie myCookie = new Cookie(\"canyu\" + tak.getId(), \"canyu\" + tak.getId());\n    myCookie.setMaxAge(60 * 60 * 24 * 7);\n    HttpServletResponse response = GetRequsetResponse.getResponse();\n    response.addCookie(myCookie);\n  }\n"}, {"dataset": "getId", "exampleID": 168, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 897, "focalAPIEnd": 913, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chrismarx/cmestemp22/tree/master/server/src/main/java/org/eurekastreams/server/service/opensocial/spi/ActivityServiceImpl.java", "rawCode": "  /**\n   * Create Activity Implementation for Shindig.\n   *\n   * @param userId - id of the user to create the activity for.\n   * @param groupId - id of the group that the user belongs to.\n   * @param appId - id of the application creating the activity.\n   * @param fields - //TODO not sure about this one yet.\n   * @param activity - the activity to be added.\n   * @param token - the security token for the request.\n   * @return void\n   */\n  public Future<Void> createActivity(\n      final UserId userId,\n      final GroupId groupId,\n      final String appId,\n      final Set<String> fields,\n      final Activity activity,\n      final SecurityToken token) {\n    log.debug(\n        \"Entering createActivity data with userId \"\n            + userId.getUserId(token)\n            + \", appId \"\n            + appId\n            + \", \"\n            + fields.size()\n            + \", AcivityId \"\n            + activity.getId()\n            + \", token appId \"\n            + token.getAppId());\n    try {\n      Principal currentUserPrincipal =\n          openSocialPrincipalPopulator.getPrincipal(userId.getUserId(token));\n\n      // Create the actor.\n      StreamEntityDTO actorEntity = new StreamEntityDTO();\n      actorEntity.setUniqueIdentifier(currentUserPrincipal.getOpenSocialId());\n      actorEntity.setType(EntityType.PERSON);\n\n      // Create the destination stream.\n      StreamEntityDTO destStream = new StreamEntityDTO();\n      destStream.setUniqueIdentifier(currentUserPrincipal.getAccountId());\n      destStream.setType(EntityType.PERSON);\n\n      // Create the activitydto object.\n      ActivityDTO currentActivity = new ActivityDTO();\n      currentActivity.setActor(actorEntity);\n      currentActivity.setBaseObjectProperties(\n          new HashMap<String, String>(convertActivityFromOSToEureka(activity)));\n      Long appIdNumeric = Long.valueOf(appId);\n      currentActivity.setAppId(appIdNumeric);\n      currentActivity.setAppType(EntityType.APPLICATION);\n      currentActivity.setAppName(lookupGadgetTitle(appIdNumeric));\n\n      // Sets default activity type\n      if (!currentActivity.getBaseObjectProperties().containsKey(\"baseObjectType\")) {\n        currentActivity.setBaseObjectType(BaseObjectType.NOTE);\n      } else {\n        String objectType = currentActivity.getBaseObjectProperties().get(\"baseObjectType\");\n        currentActivity.setBaseObjectType(BaseObjectType.valueOf(objectType));\n\n        if (currentActivity.getBaseObjectProperties().containsKey(\"source\")) {\n          currentActivity.setAppSource(currentActivity.getBaseObjectProperties().get(\"source\"));\n        }\n      }\n\n      currentActivity.setVerb(ActivityVerb.POST);\n      currentActivity.setDestinationStream(destStream);\n\n      PostActivityRequest params = new PostActivityRequest(currentActivity);\n      ServiceActionContext currentContext = new ServiceActionContext(params, currentUserPrincipal);\n      // Make the call to the action to perform the create.\n      serviceActionController.execute(currentContext, postActivityAction);\n    } catch (Exception e) {\n      log.error(\"Error occurred creating Activity \", e);\n      throw new ProtocolException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.toString());\n    }\n\n    return ImmediateFuture.newInstance(null);\n  }\n"}, {"dataset": "getId", "exampleID": 169, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1647, "focalAPIEnd": 1663, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)", "addError(String,id)"], "useStart": [1556, 2405], "useEnd": [1664, 2547], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/Componentizer.java", "rawCode": "  /**\n   * Determines the sink object of the attached-error-events-pattern.\n   *\n   * <p>The sink object is defined as inclusive or exclusive merge gateway every error handler of\n   * the activity is connected with.\n   *\n   * @param activity The activity, that may have error handlers.\n   * @return The sink object (inclusive of exlusive merge gateway) of the attached-events-pattern or\n   *     null if such a pattern could not be found.\n   */\n  private Gateway getAttachedErrorEventSinkObject(Activity activity) {\n    List<Handler> errorHandlers = getErrorHandlers(activity);\n    if ((errorHandlers == null) || errorHandlers.isEmpty()) {\n      return null;\n    }\n\n    Gateway gateway = null;\n    int counter = 0;\n    List<Activity> predecessors = new ArrayList<Activity>();\n\n    // the error handler that misses a gateway\n    Handler missing = null;\n\n    for (Iterator<Handler> itHandler = errorHandlers.iterator(); itHandler.hasNext(); ) {\n      Handler errorHandler = itHandler.next();\n\n      // check if successor of handler is a gateway\n      Activity target = errorHandler.getSuccessor();\n      if (target instanceof Gateway) {\n        Gateway targetGateway = (Gateway) target;\n\n        // check if this gateway is equals to the gateways the other event handlers lead to\n        if (targetGateway.getGatewayType().equals(Gateway.TYPE_OR)\n            || targetGateway.getGatewayType().equals(Gateway.TYPE_XOR)) {\n          if (gateway == null) {\n            gateway = targetGateway;\n          } else if (!gateway.equals(targetGateway)) {\n            this.output.addError(\n                \"Each error handler must lead to the same gateway.\", activity.getId());\n            return null;\n          }\n          predecessors.add(errorHandler);\n          counter++;\n        } else {\n          missing = errorHandler;\n          break;\n        }\n      } else {\n        missing = errorHandler;\n        break;\n      }\n    }\n\n    if (missing != null) {\n      this.output.addError(\n          \"The outgoing transition of this error handler \"\n              + \" must lead to an inclusive or\"\n              + \" exclusive merge gateway.\",\n          missing.getId());\n      return null;\n    }\n\n    if (gateway == null) {\n      return null;\n    }\n\n    // check if gateway is successor of activity\n    if ((activity.getSuccessor() != null) && activity.getSuccessor().equals(gateway)) {\n      return gateway;\n    }\n\n    this.output.addError(\n        \"The successor of this activity \" + \" must be the gateway with id \" + gateway.getId(),\n        activity.getId());\n    this.output.addError(\n        \"This gateway has to be the successor of the acitivity with id \" + activity.getId(),\n        gateway.getId());\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 170, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 139, "focalAPIEnd": 150, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/offerijns/wielwijk/tree/master/Wielwijk/src/wielwijk/ActivityWindow.java", "rawCode": "  private void UpdateAccList() {\n    java.util.List res =\n        Wielwijk.db.query(\"SELECT * FROM accommodations WHERE activity_id = '\" + act.getId() + \"'\");\n    ArrayList<Accommodation> data = new ArrayList<Accommodation>();\n    for (int i = 0; i < res.size(); i++) {\n      Map<String, Object> map = (HashMap<String, Object>) res.get(i);\n      Accommodation acc;\n      acc =\n          new Accommodation(\n              (Long) map.get(\"id\"),\n              (Integer) map.get(\"activity_id\"),\n              (Integer) map.get(\"user_id\"),\n              (String) map.get(\"address\"),\n              (Integer) map.get(\"people\"),\n              (Integer) map.get(\"capacity\"));\n\n      data.add(acc);\n    }\n\n    for (Accommodation acc : data) {\n      java.util.List res2 =\n          Wielwijk.db.query(\n              \"SELECT accommodation_id FROM accommodation_registrations WHERE user_id = '\"\n                  + LoginWindow.CurrentUser.getId()\n                  + \"' AND accommodation_id='\"\n                  + acc.getId()\n                  + \"'\");\n\n      for (int i = 0; i < res2.size(); i++) {\n\n        Map<String, Object> map2 = (HashMap<String, Object>) res2.get(i);\n        int hier = (Integer) map2.get(\"accommodation_id\");\n        System.out.println(\"hier\" + String.valueOf(hier));\n        slaaptIn.add(hier);\n        System.out.println(\"slaaptin:\" + slaaptIn.toString());\n      }\n      myList.setListData(data.toArray());\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 171, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 640, "focalAPIEnd": 665, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [588], "useEnd": [756], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Determines the reference, the sender of the received message should be bind to. This is a\n   * participant reference data object with an association from the receiving activity.\n   *\n   * @param receivingActivity The activity to get the participant reference for\n   * @return The first participant reference data object with an association from the receiving\n   *     activity. The result is null, if such an association was not found.\n   */\n  private ParticipantReferenceDataObject getReferenceToBind(Activity receivingActivity) {\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            receivingActivity.getId(),\n            Association.DIRECTION_FROM,\n            ParticipantReferenceDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantReferenceDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 172, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 580, "focalAPIEnd": 596, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,String,*)"], "useStart": [528], "useEnd": [640], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/TopologyFactory.java", "rawCode": "  /**\n   * Determines the first participant set data object that is associated with the given activity\n   *\n   * @param activity The activity the associated sets will be determined for\n   * @param direction The direction of the association connecting the activity with the set.\n   * @return The first participant set data object that is associated with the activity.\n   */\n  private ParticipantSetDataObject getAssociatedParticipantSet(\n      Activity activity, String direction) {\n\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            activity.getId(), direction, ParticipantSetDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantSetDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 173, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 640, "focalAPIEnd": 665, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [588], "useEnd": [756], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Determines the reference, the sender of the received message should be bind to. This is a\n   * participant reference data object with an association from the receiving activity.\n   *\n   * @param receivingActivity The activity to get the participant reference for\n   * @return The first participant reference data object with an association from the receiving\n   *     activity. The result is null, if such an association was not found.\n   */\n  private ParticipantReferenceDataObject getReferenceToBind(Activity receivingActivity) {\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            receivingActivity.getId(),\n            Association.DIRECTION_FROM,\n            ParticipantReferenceDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantReferenceDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 174, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new ProtocolException(*,String,*)"], "tryExpressionStart": 272, "tryExpressionEnd": 276, "tryBlockStart": 272, "tryBlockEnd": 2312, "catchExpressionStart": 2161, "catchExpressionEnd": 2181, "catchBlockStart": 2161, "catchBlockEnd": 2312, "exceptionHandlingCallStart": [2195], "exceptionHandlingCallEnd": [2305], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 613, "focalAPIEnd": 629, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Activity.setId(id)", "activity.getBodyId()", "activity.getBody()", "activity.getExternalId()", "activity.getTitleId()", "activity.getTitle()", "activity.getPriority()", "activity.getStreamFaviconUrl()", "activity.getStreamSourceUrl()", "activity.getStreamTitle()", "activity.getStreamUrl()", "activity.getUrl()", "activity.getTemplateParams()"], "useStart": [596, 659, 707, 759, 814, 864, 956, 1018, 1087, 1151, 1209, 1259, 1741], "useEnd": [630, 679, 725, 783, 835, 883, 978, 1048, 1116, 1176, 1232, 1276, 1769], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/unpush/apache-incubator-shindig/tree/master/java/samples/src/main/java/org/apache/shindig/social/opensocial/jpa/spi/ActivityServiceDb.java", "rawCode": "  public Future<Void> createActivity(\n      UserId userId,\n      GroupId groupId,\n      String appId,\n      Set<String> fields,\n      Activity activity,\n      SecurityToken token)\n      throws ProtocolException {\n    String uid = SPIUtils.getUserList(userId, token);\n\n    try {\n      // Map activity into a new ActivityDb instance\n      // TODO Could we use dozer to do this mapping instead, for future-proofing reasons?\n      ActivityDb activityDb = new ActivityDb();\n      activityDb.setPostedTime(new Date().getTime());\n      activityDb.setAppId(appId);\n      activityDb.setUserId(uid);\n      activityDb.setId(activity.getId());\n      activityDb.setBodyId(activity.getBodyId());\n      activityDb.setBody(activity.getBody());\n      activityDb.setExternalId(activity.getExternalId());\n      activityDb.setTitleId(activity.getTitleId());\n      activityDb.setTitle(activity.getTitle());\n      activityDb.setUpdated(new Date());\n      activityDb.setPriority(activity.getPriority());\n      activityDb.setStreamFaviconUrl(activity.getStreamFaviconUrl());\n      activityDb.setStreamSourceUrl(activity.getStreamSourceUrl());\n      activityDb.setStreamTitle(activity.getStreamTitle());\n      activityDb.setStreamUrl(activity.getStreamUrl());\n      activityDb.setUrl(activity.getUrl());\n      if (activity.getMediaItems() != null) {\n        List<MediaItem> mediaItems = new ArrayList<MediaItem>();\n        for (MediaItem m : activity.getMediaItems()) {\n          MediaItemDb mediaItem = new MediaItemDb();\n          mediaItem.setMimeType(m.getMimeType());\n          mediaItem.setType(m.getType());\n          mediaItem.setUrl(m.getUrl());\n          mediaItems.add(mediaItem);\n        }\n        activityDb.setMediaItems(mediaItems);\n      }\n      if (activity.getTemplateParams() != null) {\n        activityDb.setTemplateParams(activity.getTemplateParams());\n      }\n\n      // TODO How should transactions be managed? Should samples be using warp-persist instead?\n      if (!entityManager.getTransaction().isActive()) {\n        entityManager.getTransaction().begin();\n      }\n      entityManager.persist(activityDb);\n      entityManager.getTransaction().commit();\n\n    } catch (Exception e) {\n      throw new ProtocolException(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to create activity\", e);\n    }\n\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 175, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 782, "focalAPIEnd": 798, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [728], "useEnd": [851], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/ParticipantsFactory.java", "rawCode": "  /**\n   * Checks, if the multiple instance loop corresponds a forEach that iterates over a set of\n   * participants (BPEL4Chor forEach). In this case there is no counter variable data object defined\n   * for the loop.\n   *\n   * @param activity The activity to check\n   * @return True if the activity is a BPEL4Chor forEach (no counter variable associated with the\n   *     loop). False otherwise.\n   */\n  private boolean isBPEL4ChorForEach(Activity activity) {\n    if ((activity.getLoop() != null)\n        && (activity.getLoop().getLoopType().equals(Loop.TYPE_MULITPLE))) {\n      // if there is a counter variable data object defined\n      // the loop is not a BPEL4ChorForEach\n      List<Association> associations =\n          this.diagram.getAssociationsWithSource(\n              activity.getId(), Association.DIRECTION_TO, VariableDataObject.class);\n\n      for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n        VariableDataObject object = (VariableDataObject) it.next().getSource();\n        if (object.getType().equals(VariableDataObject.TYPE_COUNTER)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "getId", "exampleID": 176, "initialization": ["Activity activity = Iterator<Activity>.next()"], "initializationStart": [1251], "initializationEnd": [1263], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1794, "focalAPIEnd": 1808, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1666], "useEnd": [1809], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/SynchronizingProcessMapper.java", "rawCode": "  /**\n   * Derives the join conditions for each activity from the set of control links. The join condition\n   * is build up of all control links that lead to this activity.#\n   *\n   * @param links The links that are defined in the context of the component.\n   * @param output The output to print erros to.\n   * @return A map that maps the activity to its determined join condition.\n   */\n  private Map<Activity, Expression> calcJoinCond(List<Link> links, Output output) {\n    Map<Activity, Expression> joinConds = new HashMap<Activity, Expression>();\n    for (Iterator<Activity> it = this.component.getActivities().iterator(); it.hasNext(); ) {\n      Activity target = it.next();\n\n      if ((target instanceof Task)\n          || (target instanceof Event)\n          || (target instanceof BlockActivity)) {\n\n        List<TEC> tecs = preTECSets(target);\n        Expression joinCond = new Expression();\n        joinCond.setExpressionLanguage(\"urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0\");\n\n        for (Iterator<TEC> itTEC = tecs.iterator(); itTEC.hasNext(); ) {\n          TEC next = itTEC.next();\n          String joinPart = \"\";\n          for (Iterator<Activity> itAct = next.activities.iterator(); itAct.hasNext(); ) {\n            Activity source = itAct.next();\n            // determine link name for link with source and target and\n            // combine it in the appropriate way\n            Link link = getLink(links, source, target);\n            if (link != null) {\n              joinPart = joinPart + \"$\" + link.getName();\n              if (itAct.hasNext()) {\n                joinPart = joinPart + \" and \";\n              }\n            } else {\n              output.addError(\n                  \"A link could not be generated \" + \"for a synchronizing process pattern.\",\n                  source.getId());\n            }\n          }\n          if (!joinPart.equals(\"\")) {\n            if (joinCond.getExpression() == null) {\n              joinCond.setExpression(\"(\" + joinPart + \")\");\n            } else {\n              joinCond.setExpression(joinCond.getExpression() + \" or (\" + joinPart + \")\");\n            }\n          }\n        }\n        joinConds.put(target, joinCond);\n      }\n    }\n    return joinConds;\n  }\n"}, {"dataset": "getId", "exampleID": 177, "initialization": ["Activity activity = Transition.getSource()"], "initializationStart": [479], "initializationEnd": [501], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "activity!=null", "guardType": "IF {", "guardExpressionStart": 509, "guardExpressionEnd": 531, "guardBlockStart": 509, "guardBlockEnd": 927, "focalAPI": "id = activity.getId()", "focalAPIStart": 581, "focalAPIEnd": 598, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getObject(id)"], "useStart": [558], "useEnd": [599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IAAS/oryx-editor/tree/master/editor/server/src/de/hpi/bpel4chor/parser/ProcessParser.java", "rawCode": "  /**\n   * Builds up the graph structure based on the process transitions. For each transition the source\n   * and target object will be determined. If the source or target object does not exist in the\n   * diagram or is not an activity, an error is added to the output.\n   */\n  private void buildGraphStructure() {\n    for (Iterator<Transition> it = this.process.getTransitions().iterator(); it.hasNext(); ) {\n      Transition transition = it.next();\n      Activity sourceAct = transition.getSource();\n      if (sourceAct != null) {\n        Object source = this.diagram.getObject(sourceAct.getId());\n        if ((source != null) && (source instanceof Activity)) {\n          ((Activity) source).addSourceFor(transition, this.output);\n        } else {\n          this.output.addError(\n              \"The source activity of this transition\" + \" does not exist in the process.\",\n              transition.getId());\n        }\n      }\n      Activity targetAct = transition.getTarget();\n      if (targetAct != null) {\n        Object target = this.diagram.getObject(targetAct.getId());\n        if ((target != null) && (target instanceof Activity)) {\n          ((Activity) target).addTargetFor(transition, this.output);\n        } else {\n          this.output.addError(\n              \"The target activity of this transition\" + \" does not exist in the process.\",\n              transition.getId());\n        }\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 178, "initialization": ["Activity activity = ResultCompensation.getActivity()"], "initializationStart": [831], "initializationEnd": [852], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.getName()"], "configurationStart": [980], "configurationEnd": [993], "guardCondition": "activity instanceof Task &&  activity.getAttachedEvents(IntermediateEvent.TRIGGER_COMPENSATION,).isEmpty() && !(activity instanceof ServiceTask)", "guardType": "IF {", "guardExpressionStart": 1087, "guardExpressionEnd": 1163, "guardBlockStart": 1087, "guardBlockEnd": 1365, "focalAPI": "id = activity.getId()", "focalAPIStart": 1311, "focalAPIEnd": 1322, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)", "generateScopeName(activity)", "activity.getName()"], "useStart": [1181, 1441, 1520], "useEnd": [1323, 1472, 1533], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/transformation/factories/BasicActivityFactory.java", "rawCode": "  /**\n   * Creates the BPEL4Chor \"compensate\" or \"compensateScope\" element from an intermediate event.\n   *\n   * <p>The standard attributes are taken from the event. If the trigger defines an activity to\n   * compensate, an \"compensateScope\" element will be generated with the target attribute set to\n   * this activity.\n   *\n   * @param event The event, to generate the compensate of compensateScope element from.\n   * @return The generated BPEL4Chor \"compensate\" or \"compensateScope\" element\n   */\n  public Element createCompensateElement(IntermediateEvent event) {\n    Element result = null;\n    if ((event.getTrigger() != null) && (event.getTrigger() instanceof ResultCompensation)) {\n      ResultCompensation trigger = (ResultCompensation) event.getTrigger();\n      if (trigger.getActivity() != null) {\n        Activity act = trigger.getActivity();\n        String name = null;\n        if (act instanceof Task) {\n          if (act instanceof ServiceTask) {\n            name = act.getName();\n          } else {\n            // task must have an attached compensation event\n            if (act.getAttachedEvents(IntermediateEvent.TRIGGER_COMPENSATION).isEmpty()) {\n\n              this.output.addError(\n                  \"The task must have an attached compensation event to be compensated.\",\n                  act.getId());\n              return null;\n            }\n            // scope created around task is compensated\n            name = BPELUtil.generateScopeName(act);\n          }\n        } else {\n          name = act.getName();\n        }\n        result = this.document.createElement(\"compensateScope\");\n        result.setAttribute(\"target\", name);\n        return result;\n      }\n    }\n    result = this.document.createElement(\"compensate\");\n    BPELUtil.setStandardAttributes(result, event);\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 179, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 580, "focalAPIEnd": 596, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,String,*)"], "useStart": [528], "useEnd": [640], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/TopologyFactory.java", "rawCode": "  /**\n   * Determines the first participant set data object that is associated with the given activity\n   *\n   * @param activity The activity the associated sets will be determined for\n   * @param direction The direction of the association connecting the activity with the set.\n   * @return The first participant set data object that is associated with the activity.\n   */\n  private ParticipantSetDataObject getAssociatedParticipantSet(\n      Activity activity, String direction) {\n\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            activity.getId(), direction, ParticipantSetDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantSetDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 180, "initialization": ["Activity activity = Iterator.next()"], "initializationStart": [558], "initializationEnd": [566], "hasTryCatch": 1, "exceptionType": "GenericEntityException", "exceptionHandlingCall": ["new PersistenceException(*)"], "tryExpressionStart": 578, "tryExpressionEnd": 582, "tryBlockStart": 578, "tryBlockEnd": 790, "catchExpressionStart": 697, "catchExpressionEnd": 730, "catchBlockStart": 697, "catchBlockEnd": 790, "exceptionHandlingCallStart": [750], "exceptionHandlingCallEnd": [777], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 628, "focalAPIEnd": 644, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["deleteDeadlines(String,id,SharkTransaction)", "activity.remove()"], "useStart": [596, 666], "useEnd": [652, 683], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/QADM/SCG/tree/master/opentaps-1.5/specialpurpose/shark/src/org/ofbiz/shark/instance/EntityPersistentMgr.java", "rawCode": "  public void deleteProcess(String processId, boolean admin, SharkTransaction trans)\n      throws PersistenceException {\n    Delegator delegator = SharkContainer.getDelegator();\n    if (admin) {\n      if (Debug.infoOn()) Debug.log(\":: deleteProcess ::\", module);\n      Process process = (Process) this.restoreProcess(processId, trans);\n      List activities = this.getAllActivitiesForProcess(processId, trans);\n      if (activities != null) {\n        Iterator i = activities.iterator();\n        while (i.hasNext()) {\n          Activity activity = (Activity) i.next();\n          try {\n            this.deleteDeadlines(processId, activity.getId(), trans);\n            activity.remove();\n          } catch (GenericEntityException e) {\n            throw new PersistenceException(e);\n          }\n        }\n      }\n      try {\n        delegator.removeByAnd(\n            org.ofbiz.shark.SharkConstants.WfActivity,\n            UtilMisc.toMap(org.ofbiz.shark.SharkConstants.subFlowId, processId));\n\n        process.remove();\n      } catch (Exception e) {\n        throw new PersistenceException(e);\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 181, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 75, "focalAPIEnd": 84, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["newActivity(id)", "activity.getStartTime()", "activity.getEndTime()"], "useStart": [63, 235, 273], "useEnd": [85, 251, 287], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lucmoreau/ProvToolbox/tree/master/prov-model/src/main/java/org/openprovenance/prov/model/ProvFactory.java", "rawCode": "  public Activity newActivity(Activity a) {\n    Activity res = newActivity(a.getId());\n    res.getType().addAll(a.getType());\n    res.getLabel().addAll(a.getLabel());\n    res.getLocation().addAll(a.getLocation());\n    res.setStartTime(a.getStartTime());\n    res.setEndTime(a.getEndTime());\n    return res;\n  }\n"}, {"dataset": "getId", "exampleID": 182, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 549, "focalAPIEnd": 565, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addVertex(id)"], "useStart": [454], "useEnd": [566], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/main/java/com/collabinate/server/engine/GraphEngine.java", "rawCode": "  /**\n   * Creates a new vertex representation of a given activity.\n   *\n   * @param activity The activity to be represented.\n   * @param tenantId The tenant for the activity.\n   * @param entityId The entity to which the activity belongs.\n   * @return A vertex that represents the given activity.\n   */\n  private Vertex serializeActivity(\n      final Activity activity, final String tenantId, final String entityId) {\n    Vertex activityVertex =\n        graph.addVertex(\n            tenantId + STRING_ID_SEPARATOR + entityId + STRING_ID_SEPARATOR + activity.getId());\n    activityVertex.setProperty(STRING_TENANT_ID, tenantId);\n    activityVertex.setProperty(STRING_ENTITY_ID, entityId);\n    activityVertex.setProperty(STRING_ACTIVITY_ID, activity.getId());\n    activityVertex.setProperty(STRING_TYPE, STRING_ACTIVITY);\n    activityVertex.setProperty(STRING_SORTTIME, activity.getSortTime().toString());\n    activityVertex.setProperty(STRING_CREATED, DateTime.now(DateTimeZone.UTC).toString());\n    activityVertex.setProperty(STRING_CONTENT, activity.toString());\n    activityVertex.setProperty(STRING_COMMENT_COUNT, 0);\n    activityVertex.setProperty(STRING_LIKE_COUNT, 0);\n    return activityVertex;\n  }\n"}, {"dataset": "getId", "exampleID": 183, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 582, "focalAPIEnd": 605, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [543], "useEnd": [664], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/model/Diagram.java", "rawCode": "  /**\n   * Determines the first participant set data object that is associated with the given activity.\n   * Only associations with direction To are considered (association from data object to activity).\n   *\n   * @param loopingActivity A multiple instance looping activity.\n   * @return The first participant set data object associated with the given activity. Or null of no\n   *     participant set was found.\n   */\n  public ParticipantSetDataObject getLoopCounterSet(Activity loopingActivity) {\n    List<Association> associations =\n        getAssociationsWithSource(\n            loopingActivity.getId(), Association.DIRECTION_TO, ParticipantSetDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantSetDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 184, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 582, "focalAPIEnd": 605, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,*,*)"], "useStart": [543], "useEnd": [664], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mduduzik/flowframe/tree/master/editors/oryx/frontend/src/main/java/de/hpi/bpel4chor/model/Diagram.java", "rawCode": "  /**\n   * Determines the first participant set data object that is associated with the given activity.\n   * Only associations with direction To are considered (association from data object to activity).\n   *\n   * @param loopingActivity A multiple instance looping activity.\n   * @return The first participant set data object associated with the given activity. Or null of no\n   *     participant set was found.\n   */\n  public ParticipantSetDataObject getLoopCounterSet(Activity loopingActivity) {\n    List<Association> associations =\n        getAssociationsWithSource(\n            loopingActivity.getId(), Association.DIRECTION_TO, ParticipantSetDataObject.class);\n\n    if (!associations.isEmpty()) {\n      return (ParticipantSetDataObject) associations.get(0).getTarget();\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 185, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 240, "focalAPIEnd": 256, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["findById(id)", "activity.getClub()", "activity.getMerchant()"], "useStart": [231, 361, 408], "useEnd": [257, 379, 430], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wayne0332/xiaojh/tree/master/src/com/tjxjh/service/ActivityService.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  @Transactional(readOnly = true, propagation = Propagation.SUPPORTS)\n  public Activity findByHql(User user, Merchant merchant, Activity activity) {\n    List<ClubMember> list = null;\n    activity = findById(activity.getId());\n    if (user.getStatus() == UserStatus.ADMIN) { // \n      return activity;\n    }\n    Club club = activity.getClub();\n    Merchant oldmerchant = activity.getMerchant();\n    if (club != null) {\n      list =\n          (List<ClubMember>)\n              dao.executeHql(\n                  \"from ClubMember cm where cm.user.id=? and cm.club.id=? and cm.role in ('MANAGER','PROPRIETER')\",\n                  user.getId(),\n                  club.getId());\n      if (list.size() == 1) {\n        return activity;\n      }\n    } else if (oldmerchant != null) {\n      int merchantid = oldmerchant.getId();\n      if (merchantid == merchant.getId()) {\n        return activity;\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 186, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 34, "focalAPIEnd": 50, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bingluo/nauty/tree/master/src/cn/seu/cose/entity/ActivityPojo.java", "rawCode": "  public int getId() {\n    return activity.getId();\n  }\n"}, {"dataset": "getId", "exampleID": 187, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 812, "focalAPIEnd": 828, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,String,*)"], "useStart": [760], "useEnd": [878], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/TopologyFactory.java", "rawCode": "  /**\n   * Determines the participant reference data objects that are associated with the given activity.\n   *\n   * @param activity The activity the associated references will be determined for\n   * @param direction The direction of the association connecting the activity with the reference.\n   * @return A list with participant reference data objects associated with the given activity. If\n   *     no participant reference data object was found, an emtpy list will be returned.\n   */\n  private List<ParticipantReferenceDataObject> getAssociatedParticipantReferences(\n      Activity activity, String direction) {\n\n    List<ParticipantReferenceDataObject> result = new ArrayList<ParticipantReferenceDataObject>();\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            activity.getId(), direction, ParticipantReferenceDataObject.class);\n\n    for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n      Association assoc = it.next();\n      result.add((ParticipantReferenceDataObject) assoc.getTarget());\n    }\n\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 188, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "activity.getActivities().size()!=1", "guardType": "IF {", "guardExpressionStart": 623, "guardExpressionEnd": 670, "guardBlockStart": 623, "guardBlockEnd": 821, "focalAPI": "id = activity.getId()", "focalAPIStart": 772, "focalAPIEnd": 794, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)", "activity.getActivities()", "activity.get(int)", "activity.getId()", "addError(String,id)"], "useStart": [679, 842, 842, 1020, 927], "useEnd": [795, 872, 879, 1042, 1043], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/GeneralizedFlowMapper.java", "rawCode": "  /**\n   * Finishes the mapping of the generalized flow component, if there is only one task left. This\n   * task must be a folded task. A \"links\" element has to be added to the BPEL code belonging to\n   * this task if links were created. This \"links\" element is generated from the links created\n   * during the mapping.\n   *\n   * @param links The links created during the mapping\n   * @return The folded task representing the generalized flow component. The result is null if\n   *     there is more than one activity left or the activity is not a folded task.\n   */\n  private FoldedTask finishFlow(List<Link> links) {\n    if (this.component.getActivities().size() != 1) {\n      this.output.addError(\n          \"A generalized flow pattern could not be mapped correctly.\", this.component.getId());\n      return null;\n    }\n\n    Activity act = this.component.getActivities().get(0);\n    if (!(act instanceof FoldedTask)) {\n      this.output.addError(\n          \"A generalized flow pattern could not be mapped correctly.\", this.component.getId());\n      return null;\n    }\n\n    Element element = ((FoldedTask) act).getBPELElement();\n    if (element == null) {\n      this.output.addError(\n          \"An Activity could not be mapped correctly, since the BPELElement is null\", act.getId());\n      return null;\n    }\n    Element linksElement =\n        new SupportingFactory(this.diagram, this.document, this.output).createLinks(links);\n    if (linksElement != null) {\n      Node child = element.getFirstChild();\n      if (child == null) {\n        element.appendChild(linksElement);\n      } else {\n        element.insertBefore(linksElement, child);\n      }\n    }\n\n    return (FoldedTask) act;\n  }\n"}, {"dataset": "getId", "exampleID": 189, "initialization": ["Activity activity = List.get(int)"], "initializationStart": [432], "initializationEnd": [445], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 461, "focalAPIEnd": 472, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["id.longValue()"], "useStart": [501], "useEnd": [518], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/catrip/tree/master/codebase/projects/tumor registry/test/edu/duke/cabig/tumorregistry/domain/SurgeryTest.java", "rawCode": "  public Long getNextId() throws Exception {\n    Long maxId = Long.valueOf(0);\n    Session session = HibernateUtil.currentSession();\n    Transaction tx = session.beginTransaction();\n\n    List result = new ArrayList();\n    result = session.createQuery(\"from Activity where id = (select max(id) from Activity)\").list();\n\n    tx.commit();\n    HibernateUtil.closeSession();\n    if (result.size() != 0) {\n      Activity obj = (Activity) result.get(0);\n      maxId = obj.getId();\n    }\n    return new Long((maxId.longValue() + 1));\n  }\n"}, {"dataset": "getId", "exampleID": 190, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 170, "focalAPIEnd": 186, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getObjectById(*,id)", "activity.getObjectId()", "activity.getAction()", "activity.getTime()", "activity.isPublic()"], "useStart": [137, 371, 419, 463, 507], "useEnd": [187, 393, 439, 481, 526], "hasFinally": 1, "cleanUpCall": ["Transaction.rollback()"], "finallyExpressionStart": 554, "finallyExpressionEnd": 562, "finallyBlockStart": 554, "finallyBlockEnd": 627, "cleanUpCallStart": [589], "cleanUpCallEnd": [602], "url": "https://github.com/bcdata/bouncingdata/tree/master/src/main/java/com/bouncingdata/plfdemo/datastore/JdoDataStorage.java", "rawCode": "  @Override\n  public void updateActivity(Activity activity) {\n    PersistenceManager pm = getPersistenceManager();\n    Activity pstObj = pm.getObjectById(Activity.class, activity.getId());\n    if (pstObj == null) {\n      // throw an custom exception?\n      return;\n    }\n\n    Transaction tx = pm.currentTransaction();\n    try {\n      tx.begin();\n      pstObj.setObjectId(activity.getObjectId());\n      pstObj.setAction(activity.getAction());\n      pstObj.setTime(activity.getTime());\n      pstObj.setPublic(activity.isPublic());\n      tx.commit();\n    } finally {\n      if (tx.isActive()) tx.rollback();\n      pm.close();\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 191, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 156, "focalAPIEnd": 172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Activity.get(id)", "activity.setActivityRequirementBindings(*)", "activity.getId()", "Activity.get(id)", "activity.setActivityPatternBindings(*)", "activity.getId()", "Activity.get(id)", "activity.setDefined(*)", "activity.setExpression(*)", "activity.setEnabled(*)", "activity.getId()", "add(id)", "activity.getId()", "contains(id)", "activity.setEnabled(*)", "activity.setName(String)", "activity.setDescription(String)", "activity.getId()", "contains(id)", "activity.setDefaultEnabled(*)", "new ActivityEvent(activity,boolean,boolean,boolean,boolean,boolean,boolean,boolean)"], "useStart": [112, 232, 489, 449, 561, 795, 767, 843, 1277, 2001, 2310, 2282, 2421, 2393, 2373, 2482, 2607, 2858, 2802, 2762, 3117], "useEnd": [173, 407, 505, 506, 692, 811, 812, 890, 1336, 2071, 2326, 2327, 2437, 2438, 2439, 2564, 2716, 2874, 2875, 2876, 3381], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/maihde/org.eclipse.rap/tree/master/bundles/org.eclipse.rap.ui.workbench/Eclipse UI/org/eclipse/ui/internal/activities/MutableActivityManager.java", "rawCode": "  private ActivityEvent updateActivity(Activity activity) {\n    Set activityRequirementBindings =\n        (Set) activityRequirementBindingsByActivityId.get(activity.getId());\n    boolean activityRequirementBindingsChanged =\n        activity.setActivityRequirementBindings(\n            activityRequirementBindings != null\n                ? activityRequirementBindings\n                : Collections.EMPTY_SET);\n    Set activityPatternBindings = (Set) activityPatternBindingsByActivityId.get(activity.getId());\n    boolean activityPatternBindingsChanged =\n        activity.setActivityPatternBindings(\n            activityPatternBindings != null ? activityPatternBindings : Collections.EMPTY_SET);\n    ActivityDefinition activityDefinition =\n        (ActivityDefinition) activityDefinitionsById.get(activity.getId());\n    boolean definedChanged = activity.setDefined(activityDefinition != null);\n\n    // enabledWhen comes into play\n    IEvaluationReference ref =\n        (IEvaluationReference) refsByActivityDefinition.get(activityDefinition);\n    IEvaluationService evaluationService =\n        (IEvaluationService) PlatformUI.getWorkbench().getService(IEvaluationService.class);\n    boolean newRef = false;\n    if (activityDefinition != null && evaluationService != null) {\n      activity.setExpression(activityDefinition.getEnabledWhen());\n      if (ref == null && activityDefinition.getEnabledWhen() != null) {\n        addingEvaluationListener = true;\n        try {\n          ref =\n              evaluationService.addEvaluationListener(\n                  activityDefinition.getEnabledWhen(),\n                  enabledWhenListener,\n                  activityDefinition.getId());\n          newRef = true;\n        } finally {\n          addingEvaluationListener = false;\n        }\n        if (ref != null) {\n          refsByActivityDefinition.put(activityDefinition, ref);\n        }\n      }\n    }\n    final boolean enabledChanged;\n    if (ref != null && evaluationService != null) {\n      enabledChanged = activity.setEnabled(ref.evaluate(evaluationService.getCurrentState()));\n      if (newRef && activity.isEnabled()) {\n        // make sure this activity is in the enabled set for this\n        // manager - event firing will be handled by the caller to this\n        // method.\n        this.enabledActivityIds.add(activity.getId());\n      }\n    } else {\n      enabledChanged = activity.setEnabled(enabledActivityIds.contains(activity.getId()));\n    }\n\n    boolean nameChanged =\n        activity.setName(activityDefinition != null ? activityDefinition.getName() : null);\n    boolean descriptionChanged =\n        activity.setDescription(\n            activityDefinition != null ? activityDefinition.getDescription() : null);\n    boolean defaultEnabledChanged =\n        activity.setDefaultEnabled(\n            activityRegistry.getDefaultEnabledActivities().contains(activity.getId()));\n    if (activityRequirementBindingsChanged\n        || activityPatternBindingsChanged\n        || definedChanged\n        || enabledChanged\n        || nameChanged\n        || descriptionChanged\n        || defaultEnabledChanged) {\n      return new ActivityEvent(\n          activity,\n          activityRequirementBindingsChanged,\n          activityPatternBindingsChanged,\n          definedChanged,\n          descriptionChanged,\n          enabledChanged,\n          nameChanged,\n          defaultEnabledChanged);\n    }\n\n    return null;\n  }\n"}, {"dataset": "getId", "exampleID": 192, "initialization": ["Activity activity = Iterator<Activity>.next()"], "initializationStart": [492], "initializationEnd": [501], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setParentSwimlane(Swimlane)"], "configurationStart": [741], "configurationEnd": [777], "guardCondition": "!(activity.getParentSwimlane()==null)", "guardType": "IF {", "guardExpressionStart": 509, "guardExpressionEnd": 550, "guardBlockStart": 509, "guardBlockEnd": 901, "focalAPI": "id = activity.getId()", "focalAPIStart": 875, "focalAPIEnd": 891, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [802], "useEnd": [892], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpel4chor/parser/SwimlaneParser.java", "rawCode": "  /**\n   * Sets the parent swimlane for the given activities. If an activity already has a parent swimlane\n   * specified, an error is added to the output.\n   *\n   * @param swimlane The parent swimlane for the given activities.\n   * @param activities The activities to set the parent swimlane for.\n   */\n  private void setSwimlaneForActivities(Swimlane swimlane, List<Activity> activities) {\n    for (Iterator<Activity> it = activities.iterator(); it.hasNext(); ) {\n      Activity activity = it.next();\n      if (activity.getParentSwimlane() == null) {\n        if (activity instanceof BlockActivity) {\n          setSwimlaneForActivities(\n              swimlane, ((BlockActivity) activity).getSubProcess().getActivities());\n        }\n        activity.setParentSwimlane(swimlane);\n      } else {\n        this.output.addError(\"Activity \" + \" is located in multiple swimlanes.\", activity.getId());\n      }\n    }\n  }\n"}, {"dataset": "getId", "exampleID": 193, "initialization": ["Activity activity = ResponseList<Activity>.get(int)"], "initializationStart": [552], "initializationEnd": [566], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 585, "focalAPIEnd": 600, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertThat(id,*)", "activity.getCategory()", "activity.getName()", "activity.getCreatedTime()"], "useStart": [574, 643, 701, 754], "useEnd": [624, 664, 718, 778], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/roundrop/facebook4j/tree/master/facebook4j-core/src/test/java/facebook4j/ActivitiesMethodsTest.java", "rawCode": "    @Test\n    public void id_reading() throws Exception {\n      facebook.setMockJSON(\"mock_json/activity/activities_name.json\");\n      ResponseList<Activity> actuals =\n          facebook.getActivities(\"1234567890123456\", new Reading().fields(\"name\"));\n      assertThat(facebook.getHttpMethod(), is(RequestMethod.GET));\n      assertThat(facebook.getEndpointURL(), is(pathOf(\"/1234567890123456/activities\")));\n      assertThat(facebook.getEndpointURL(), hasParameter(\"fields\", \"name\"));\n\n      assertThat(actuals.size(), is(2));\n      Activity actual1 = actuals.get(0);\n      assertThat(actual1.getId(), is(\"111111111111111\"));\n      assertThat(actual1.getCategory(), is(nullValue()));\n      assertThat(actual1.getName(), is(\"Aaaaaaaa\"));\n      assertThat(actual1.getCreatedTime(), is(nullValue()));\n      Activity actual2 = actuals.get(1);\n      assertThat(actual2.getId(), is(\"222222222222222\"));\n      assertThat(actual2.getCategory(), is(nullValue()));\n      assertThat(actual2.getName(), is(\"Bbbbbbbb\"));\n      assertThat(actual2.getCreatedTime(), is(nullValue()));\n    }\n"}, {"dataset": "getId", "exampleID": 194, "initialization": ["Activity activity = Iterator<Activity>.next()"], "initializationStart": [1251], "initializationEnd": [1263], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 1794, "focalAPIEnd": 1808, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addError(String,id)"], "useStart": [1666], "useEnd": [1809], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/bpel4chor/transformation/factories/SynchronizingProcessMapper.java", "rawCode": "  /**\n   * Derives the join conditions for each activity from the set of control links. The join condition\n   * is build up of all control links that lead to this activity.#\n   *\n   * @param links The links that are defined in the context of the component.\n   * @param output The output to print erros to.\n   * @return A map that maps the activity to its determined join condition.\n   */\n  private Map<Activity, Expression> calcJoinCond(List<Link> links, Output output) {\n    Map<Activity, Expression> joinConds = new HashMap<Activity, Expression>();\n    for (Iterator<Activity> it = this.component.getActivities().iterator(); it.hasNext(); ) {\n      Activity target = it.next();\n\n      if ((target instanceof Task)\n          || (target instanceof Event)\n          || (target instanceof BlockActivity)) {\n\n        List<TEC> tecs = preTECSets(target);\n        Expression joinCond = new Expression();\n        joinCond.setExpressionLanguage(\"urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0\");\n\n        for (Iterator<TEC> itTEC = tecs.iterator(); itTEC.hasNext(); ) {\n          TEC next = itTEC.next();\n          String joinPart = \"\";\n          for (Iterator<Activity> itAct = next.activities.iterator(); itAct.hasNext(); ) {\n            Activity source = itAct.next();\n            // determine link name for link with source and target and\n            // combine it in the appropriate way\n            Link link = getLink(links, source, target);\n            if (link != null) {\n              joinPart = joinPart + \"$\" + link.getName();\n              if (itAct.hasNext()) {\n                joinPart = joinPart + \" and \";\n              }\n            } else {\n              output.addError(\n                  \"A link could not be generated \" + \"for a synchronizing process pattern.\",\n                  source.getId());\n            }\n          }\n          if (!joinPart.equals(\"\")) {\n            if (joinCond.getExpression() == null) {\n              joinCond.setExpression(\"(\" + joinPart + \")\");\n            } else {\n              joinCond.setExpression(joinCond.getExpression() + \" or (\" + joinPart + \")\");\n            }\n          }\n        }\n        joinConds.put(target, joinCond);\n      }\n    }\n    return joinConds;\n  }\n"}, {"dataset": "getId", "exampleID": 195, "initialization": ["Activity activity = new Activity(String)"], "initializationStart": [673], "initializationEnd": [702], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 783, "focalAPIEnd": 799, "followUpCheck": "null == id || id.equals(\"\")", "checkType": "IF", "followUpCheckExpressionStart": 805, "followUpCheckExpressionEnd": 837, "followUpCheckBlockStart": 805, "followUpCheckBlockEnd": 894, "use": ["activity.setId(String)", "activity.setCollabinateValue(String,String)", "CollabinateWriter.addActivity(String,String,activity)", "activity.getReplies()", "activity.getLikes()", "activity.toString()"], "useStart": [869, 1188, 1245, 1561, 2329, 2904], "useEnd": [887, 1238, 1293, 1582, 2348, 2923], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/main/java/com/collabinate/server/resources/ActivityResource.java", "rawCode": "  @Put\n  public void putActivity(String activityContent) {\n    // extract necessary information from the context\n    CollabinateWriter writer =\n        (CollabinateWriter) getContext().getAttributes().get(\"collabinateWriter\");\n    String tenantId = getAttribute(\"tenantId\");\n    String entityId = getAttribute(\"entityId\");\n    String activityId = getAttribute(\"activityId\");\n    String ignoreCommentsString = getQueryValue(\"ignoreComments\");\n    String ignoreLikesString = getQueryValue(\"ignoreLikes\");\n\n    // remove any existing activity\n    writer.deleteActivity(tenantId, entityId, activityId);\n\n    // create an activity from the given content\n    Activity activity = new Activity(activityContent);\n\n    // ensure the activity has an id - set to given id if not\n    String id = activity.getId();\n    if (null == id || id.equals(\"\")) {\n      id = activityId;\n      activity.setId(id);\n    }\n\n    // if the URL ID differs from the activity ID, the activity cannot be\n    // processed\n    if (!activityId.equals(id)) {\n      // TODO: set error message\n      setStatus(Status.CLIENT_ERROR_UNPROCESSABLE_ENTITY);\n      return;\n    }\n\n    // keep track of the entityID in the activity\n    activity.setCollabinateValue(\"entityId\", entityId);\n\n    writer.addActivity(tenantId, entityId, activity);\n\n    // if the activity has comments and we're not ignoring them,\n    // add them to the database properly\n    boolean ignoreComments =\n        null != ignoreCommentsString && !ignoreCommentsString.equalsIgnoreCase(\"false\");\n\n    ActivityStreamsCollection replies = activity.getReplies();\n\n    if (!ignoreComments && null != replies && replies.size() > 0) {\n      for (ActivityStreamsObject comment : replies.getItems()) {\n        // ensure the comment has an id - set to generated id if not\n        String commentId = comment.getId();\n        if (null == commentId || commentId.equals(\"\")) {\n          commentId = ActivityStreamsObject.generateUuidUrn();\n          comment.setId(commentId);\n        }\n        writer.addComment(tenantId, entityId, activityId, null, comment);\n      }\n    }\n\n    // if the activity has likes and we're not ignoring them,\n    // add them to the database properly\n    boolean ignoreLikes = null != ignoreLikesString && !ignoreLikesString.equalsIgnoreCase(\"false\");\n\n    ActivityStreamsCollection likes = activity.getLikes();\n\n    if (!ignoreLikes && null != likes && likes.size() > 0) {\n      for (ActivityStreamsObject likeObject : likes.getItems()) {\n        Activity like = new Activity(likeObject.toString());\n        ActivityStreamsObject actor = like.getActor();\n        if (null != actor) {\n          String userId = actor.getId();\n          if (null != userId && !userId.equals(\"\")) {\n            writer.likeActivity(tenantId, userId, entityId, activityId);\n          }\n        }\n      }\n    }\n\n    // return the activity in the response body\n    getResponse().setEntity(activity.toString(), MediaType.APPLICATION_JSON);\n\n    setStatus(Status.SUCCESS_OK);\n  }\n"}, {"dataset": "getId", "exampleID": 196, "initialization": ["Activity activity = createActivity()"], "initializationStart": [52], "initializationEnd": [68], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 392, "focalAPIEnd": 408, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Long(id)", "activity.getCompositeActivity()", "activity.getScope()", "activity.getCompositeActivity()"], "useStart": [383, 444, 821, 934], "useEnd": [409, 475, 840, 965], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/amegginson/jbpm-bpel-ftl/tree/master/bpel/library/src/test/java/org/jbpm/bpel/graph/def/AbstractActivityDbTestCase.java", "rawCode": "  public void testScope() {\n    Activity activity = createActivity();\n\n    Scope local = new Scope(\"local\");\n    local.setActivity(activity);\n\n    Sequence main = new Sequence(\"main\");\n    main.addNode(local);\n\n    processDefinition.getGlobalScope().setActivity(main);\n\n    processDefinition = saveAndReload(processDefinition);\n    activity = (Activity) session.load(Activity.class, new Long(activity.getId()));\n\n    CompositeActivity parent = activity.getCompositeActivity();\n    assertEquals(\"local\", parent.getName());\n    assertTrue(parent.isScope());\n    /*\n     * when AbstractDbTestCase.newTransaction() simply ends the current transaction and begins a new\n     * one, the session preserves the objects already loaded; thus, parent is still a Scope\n     */\n    // assertFalse(parent instanceof Scope);\n    local = activity.getScope();\n    assertEquals(\"local\", local.getName());\n\n    // verify proxy reacquisition\n    parent = activity.getCompositeActivity();\n    assertTrue(parent instanceof Scope);\n  }\n"}, {"dataset": "getId", "exampleID": 197, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 454, "focalAPIEnd": 468, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Request(*,id)"], "useStart": [294], "useEnd": [469], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Collabinate/Collabinate/tree/master/collabinate-server/src/test/java/com/collabinate/server/resources/CommentsResourceTest.java", "rawCode": "  @Test\n  public void individual_comment_should_be_retrievable_via_generated_id() {\n    addActivity();\n    String entityBody = \"{\\\"id\\\":\\\"test\\\",\\\"content\\\":\\\"TEST\\\"}\";\n    Activity posted = new Activity(post(entityBody, MediaType.TEXT_PLAIN).getEntityAsText());\n\n    Request request =\n        new Request(\n            Method.GET,\n            \"riap://application/1/tenant/entities/entity\"\n                + \"/stream/activity/comments/\"\n                + posted.getId());\n    ActivityStreamsObject comment =\n        new ActivityStreamsObject(component.handle(request).getEntityAsText());\n\n    assertEquals(\"TEST\", comment.getContent());\n  }\n"}, {"dataset": "getId", "exampleID": 198, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 812, "focalAPIEnd": 828, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAssociationsWithSource(id,String,*)"], "useStart": [760], "useEnd": [878], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SINTEF-9012/oryx-neffics/tree/master/editor/server/src/de/hpi/bpmn2bpel/factories/TopologyFactory.java", "rawCode": "  /**\n   * Determines the participant reference data objects that are associated with the given activity.\n   *\n   * @param activity The activity the associated references will be determined for\n   * @param direction The direction of the association connecting the activity with the reference.\n   * @return A list with participant reference data objects associated with the given activity. If\n   *     no participant reference data object was found, an emtpy list will be returned.\n   */\n  private List<ParticipantReferenceDataObject> getAssociatedParticipantReferences(\n      Activity activity, String direction) {\n\n    List<ParticipantReferenceDataObject> result = new ArrayList<ParticipantReferenceDataObject>();\n    List<Association> associations =\n        this.diagram.getAssociationsWithSource(\n            activity.getId(), direction, ParticipantReferenceDataObject.class);\n\n    for (Iterator<Association> it = associations.iterator(); it.hasNext(); ) {\n      Association assoc = it.next();\n      result.add((ParticipantReferenceDataObject) assoc.getTarget());\n    }\n\n    return result;\n  }\n"}, {"dataset": "getId", "exampleID": 199, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 142, "focalAPIEnd": 166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getPlannedActivitiesForActivity(id)"], "useStart": [91], "useEnd": [167], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/psc/tree/master/core/src/test/java/edu/northwestern/bioinformatics/studycalendar/service/ActivityServiceTest.java", "rawCode": "  private void expectActivityUsedByPlannedCalendar(Activity expectedActivity) {\n    expect(plannedActivityDao.getPlannedActivitiesForActivity(expectedActivity.getId()))\n        .andReturn(Arrays.asList(new PlannedActivity()));\n  }\n"}, {"dataset": "getId", "exampleID": 200, "initialization": ["Activity activity = new Activity()"], "initializationStart": [108], "initializationEnd": [122], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["activity.setName(String)", "activity.setDescription(String)", "activity.setType(*)", "activity.setCode(String)"], "configurationStart": [130, 167, 220, 284], "configurationEnd": [159, 212, 276, 306], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "id = activity.getId()", "focalAPIStart": 350, "focalAPIEnd": 366, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ActivityDao.getById(id)"], "useStart": [499], "useEnd": [519], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/psc/tree/master/core/src/test/java/edu/northwestern/bioinformatics/studycalendar/dao/ActivityDaoTest.java", "rawCode": "  public void testSaveNewActivity() throws Exception {\n    Integer savedId;\n    {\n      Activity activity = new Activity();\n      activity.setName(\"Give drug\");\n      activity.setDescription(\"Administer aspirin\");\n      activity.setType(activityTypeDao.getByName(\"PROCEDURE\"));\n      activity.setCode(\"AA\");\n      dao.save(activity);\n      savedId = activity.getId();\n      assertNotNull(\"The saved activity didn't get an id\", savedId);\n    }\n\n    interruptSession();\n\n    {\n      Activity loaded = dao.getById(savedId);\n      assertNotNull(\"Could not reload activity with id \" + savedId, loaded);\n      assertEquals(\"Wrong code\", \"AA\", loaded.getCode());\n      assertEquals(\"Wrong name\", \"Give drug\", loaded.getName());\n      assertEquals(\n          \"Wrong name for activity type\",\n          Fixtures.createNamedInstance(\"PROCEDURE\", ActivityType.class).getName(),\n          loaded.getType().getName());\n    }\n  }\n"}]