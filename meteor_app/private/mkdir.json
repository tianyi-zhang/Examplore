[{"dataset": "mkdir", "exampleID": 2001, "initialization": ["File file = new File(String)"], "initializationStart": [787], "initializationEnd": [819], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 825, "focalAPIEnd": 837, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/logging/src/test/java/org/apache/harmony/logging/tests/java/util/logging/FormatterTest.java", "rawCode": "  protected void setUp() throws Exception {\n    super.setUp();\n    manager.reset();\n\n    // initProp\n    props.clear();\n    props.put(\"java.util.logging.FileHandler.level\", \"FINE\");\n    props.put(\"java.util.logging.FileHandler.filter\", className + \"$MockFilter\");\n    props.put(\"java.util.logging.FileHandler.formatter\", className + \"$MockFormatter\");\n    props.put(\"java.util.logging.FileHandler.encoding\", \"iso-8859-1\");\n    // limit to only two message\n    props.put(\"java.util.logging.FileHandler.limit\", \"1000\");\n    // rotation count is 2\n    props.put(\"java.util.logging.FileHandler.count\", \"2\");\n    // using append mode\n    props.put(\"java.util.logging.FileHandler.append\", \"true\");\n    props.put(\"java.util.logging.FileHandler.pattern\", \"%t/log/java%u.test\");\n\n    File file = new File(TEMPPATH + SEP + \"log\");\n    file.mkdir();\n    manager.readConfiguration(EnvironmentHelper.PropertiesToInputStream(props));\n\n    f = new MockFormatter();\n    r = new LogRecord(Level.FINE, MSG);\n    h = new FileHandler();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2002, "initialization": ["File file = new File(*)"], "initializationStart": [819], "initializationEnd": [907], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 913, "focalAPIEnd": 929, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getAbsolutePath()"], "useStart": [5946], "useEnd": [5972], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geotools-2.7.x/tree/master/modules/plugin/geotiff/src/test/java/org/geotools/gce/geotiff/GeoTiffWriterTest.java", "rawCode": "  /**\n   * Testing {@link GeoTiffWriter} capabilities to write a cropped coverage.\n   *\n   * @throws IllegalArgumentException\n   * @throws IOException\n   * @throws UnsupportedOperationException\n   * @throws ParseException\n   * @throws FactoryException\n   * @throws TransformException\n   */\n  @Test\n  public void testWriteCroppedCoverage()\n      throws IllegalArgumentException, IOException, UnsupportedOperationException, ParseException,\n          FactoryException, TransformException {\n\n    // /////////////////////////////////////////////////////////////////////\n    //\n    // Look for the original coverage that we want to crop.\n    //\n    // /////////////////////////////////////////////////////////////////////\n    final File readdir = TestData.file(GeoTiffWriterTest.class, \"\");\n    final File writedir =\n        new File(new StringBuilder(readdir.getAbsolutePath()).append(\"/testWriter/\").toString());\n    writedir.mkdir();\n    final File tiff = new File(readdir, \"latlon.tiff\");\n    assert tiff.exists() && tiff.canRead() && tiff.isFile();\n    if (TestData.isInteractiveTest()) logger.info(tiff.getAbsolutePath());\n\n    // /////////////////////////////////////////////////////////////////////\n    //\n    // Create format and reader\n    //\n    // /////////////////////////////////////////////////////////////////////\n    final GeoTiffFormat format = new GeoTiffFormat();\n    // getting a reader\n    GridCoverageReader reader = format.getReader(tiff);\n    assertNotNull(reader);\n\n    // /////////////////////////////////////////////////////////////////////\n    //\n    // Play with metadata\n    //\n    // /////////////////////////////////////////////////////////////////////\n    IIOMetadataDumper metadataDumper =\n        new IIOMetadataDumper(((GeoTiffReader) reader).getMetadata().getRootNode());\n    if (TestData.isInteractiveTest()) {\n      logger.info(metadataDumper.getMetadata());\n    } else metadataDumper.getMetadata();\n\n    // /////////////////////////////////////////////////////////////////////\n    //\n    // Read the original coverage.\n    //\n    // /////////////////////////////////////////////////////////////////////\n    GridCoverage2D gc = (GridCoverage2D) reader.read(null);\n    if (TestData.isInteractiveTest()) {\n      logger.info(\n          new StringBuilder(\"Coverage before: \")\n              .append(\"\\n\")\n              .append(gc.getCoordinateReferenceSystem().toWKT())\n              .append(gc.getEnvelope().toString())\n              .toString());\n    }\n    final CoordinateReferenceSystem sourceCRS = gc.getCoordinateReferenceSystem2D();\n    final GeneralEnvelope sourceEnvelope = (GeneralEnvelope) gc.getEnvelope();\n    final GridGeometry2D sourcedGG = (GridGeometry2D) gc.getGridGeometry();\n    final MathTransform sourceG2W = sourcedGG.getGridToCRS(PixelInCell.CELL_CENTER);\n\n    // /////////////////////////////////////////////////////////////////////\n    //\n    //\n    // CROP\n    //\n    //\n    // /////////////////////////////////////////////////////////////////////\n\n    // /////////////////////////////////////////////////////////////////////\n    //\n    // Crop the original coverage.\n    //\n    // /////////////////////////////////////////////////////////////////////\n    double xc = sourceEnvelope.getMedian(0);\n    double yc = sourceEnvelope.getMedian(1);\n    double xl = sourceEnvelope.getSpan(0);\n    double yl = sourceEnvelope.getSpan(1);\n    final GeneralEnvelope cropEnvelope =\n        new GeneralEnvelope(\n            new double[] {xc - xl / 4.0, yc - yl / 4.0},\n            new double[] {xc + xl / 4.0, yc + yl / 4.0});\n    final CoverageProcessor processor = CoverageProcessor.getInstance();\n    final ParameterValueGroup param = processor.getOperation(\"CoverageCrop\").getParameters();\n    param.parameter(\"Source\").setValue(gc);\n    param.parameter(\"Envelope\").setValue(cropEnvelope);\n    final GridCoverage2D cropped = (GridCoverage2D) processor.doOperation(param);\n\n    // /////////////////////////////////////////////////////////////////////\n    //\n    // Check that we got everything correctly after the crop.\n    //\n    // /////////////////////////////////////////////////////////////////////\n    // checking the ranges of the output image.\n    final GridGeometry2D croppedGG = (GridGeometry2D) cropped.getGridGeometry();\n    final GridEnvelope croppedGR = croppedGG.getGridRange();\n    final MathTransform croppedG2W = croppedGG.getGridToCRS(PixelInCell.CELL_CENTER);\n    final GeneralEnvelope croppedEnvelope = (GeneralEnvelope) cropped.getEnvelope();\n    assertTrue(\"min x do not match after crop\", 29 == croppedGR.getLow(0));\n    assertTrue(\"min y do not match after crop\", 30 == croppedGR.getLow(1));\n    assertTrue(\"max x do not match after crop\", 90 == croppedGR.getHigh(0) + 1);\n    assertTrue(\"max y do not match after crop\", 91 == croppedGR.getHigh(1) + 1);\n    // check that the affine transform are the same thing\n    assertTrue(\n        \"The Grdi2World tranformations of the original and the cropped covearage do not match\",\n        sourceG2W.equals(croppedG2W));\n    // check that the envelope is correct\n    final GeneralEnvelope expectedEnvelope =\n        new GeneralEnvelope(\n            croppedGR,\n            PixelInCell.CELL_CENTER,\n            croppedG2W,\n            cropped.getCoordinateReferenceSystem2D());\n    assertTrue(\n        \"Expected envelope is different from the computed one\",\n        expectedEnvelope.equals(\n            croppedEnvelope, XAffineTransform.getScale((AffineTransform) croppedG2W) / 2.0, false));\n\n    // release things\n    cropped.dispose(true);\n    gc.dispose(true);\n    try {\n      if (reader != null) reader.dispose();\n    } catch (Throwable e) {\n    }\n    // /////////////////////////////////////////////////////////////////////\n    //\n    //\n    // WRITING AND TESTING\n    //\n    //\n    // /////////////////////////////////////////////////////////////////////\n    final File writeFile =\n        new File(\n            new StringBuilder(writedir.getAbsolutePath())\n                .append(File.separatorChar)\n                .append(cropped.getName().toString())\n                .append(\".tiff\")\n                .toString());\n    final GridCoverageWriter writer = format.getWriter(writeFile);\n\n    try {\n      writer.write(cropped, null);\n    } catch (IOException e) {\n    } finally {\n      try {\n        writer.dispose();\n      } catch (Throwable e) {\n      }\n    }\n    try {\n      reader = new GeoTiffReader(writeFile, null);\n      assertNotNull(reader);\n      gc = (GridCoverage2D) reader.read(null);\n      assertNotNull(gc);\n      final CoordinateReferenceSystem targetCRS = gc.getCoordinateReferenceSystem2D();\n      assertTrue(\n          \"Source and Target coordinate reference systems do not match\",\n          CRS.equalsIgnoreMetadata(sourceCRS, targetCRS));\n      assertEquals(\n          \"Read-back and Cropped envelopes do not match\", cropped.getEnvelope(), croppedEnvelope);\n\n      if (TestData.isInteractiveTest()) {\n        logger.info(\n            new StringBuilder(\"Coverage after: \")\n                .append(\"\\n\")\n                .append(gc.getCoordinateReferenceSystem().toWKT())\n                .append(gc.getEnvelope().toString())\n                .toString());\n        if (TestData.isInteractiveTest()) gc.show();\n        else PlanarImage.wrapRenderedImage(gc.getRenderedImage()).getTiles();\n      }\n    } finally {\n      try {\n        if (reader != null) reader.dispose();\n      } catch (Throwable e) {\n      }\n\n      if (!TestData.isInteractiveTest()) gc.dispose(true);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2003, "initialization": ["File file = new File(*,String)"], "initializationStart": [230], "initializationEnd": [274], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 280, "focalAPIEnd": 300, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Minestar/MinestarCore/tree/master/src/main/java/de/minestar/core/MinestarCore.java", "rawCode": "  @Override\n  protected boolean loadingConfigs(File dataFolder) {\n    // GET GROUPMANAGER\n    this.getGroupManager();\n\n    MinestarCore.dataFolder = this.getDataFolder();\n\n    // CREATE FOLDER \"playerdata\"\n    File playerFolder = new File(this.getDataFolder(), \"playerdata\");\n    playerFolder.mkdir();\n\n    return super.loadingConfigs(dataFolder);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2004, "initialization": ["File file = File.getParentFile()"], "initializationStart": [448], "initializationEnd": [471], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 549, "focalAPIEnd": 572, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inflate(ZipFile,file,*)"], "useStart": [628], "useEnd": [675], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdeolive/geoserver-old/tree/master/rest/src/main/java/org/geoserver/rest/util/RESTUtils.java", "rawCode": "  /**\n   * Unzips a zip a file to a specified directory, deleting the zip file after unpacking.\n   *\n   * @param zipFile The zip file.\n   * @param outputDirectory The directory to unpack the contents to.\n   * @throws IOException Any I/O errors that occur.\n   *     <p>TODO: move this to IOUtils\n   */\n  public static void unzipFile(File zipFile, File outputDirectory) throws IOException {\n    if (outputDirectory == null) {\n      outputDirectory = zipFile.getParentFile();\n    }\n    if (outputDirectory != null && !outputDirectory.exists()) {\n      outputDirectory.mkdir();\n    }\n    ZipFile archive = new ZipFile(zipFile);\n    IOUtils.inflate(archive, outputDirectory, null);\n    IOUtils.deleteFile(zipFile);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2005, "initialization": ["File file = new File(*)"], "initializationStart": [320], "initializationEnd": [352], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(*)"], "tryExpressionStart": 300, "tryExpressionEnd": 304, "tryBlockStart": 300, "tryBlockEnd": 429, "catchExpressionStart": 752, "catchExpressionEnd": 772, "catchBlockStart": 752, "catchBlockEnd": 798, "exceptionHandlingCallStart": [780], "exceptionHandlingCallEnd": [791], "configuration": ["file.getCanonicalPath()"], "configurationStart": [329], "configurationEnd": [351], "guardCondition": "file!=null&&!(file.exists())", "guardType": "IF {", "guardExpressionStart": 275, "guardExpressionEnd": 291, "guardBlockStart": 275, "guardBlockEnd": 435, "focalAPI": "var = file.mkdir()", "focalAPIStart": 483, "focalAPIEnd": 494, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.deleteOnExit()", "file.getCanonicalFile()"], "useStart": [502, 722], "useEnd": [520, 744], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-7/tree/master/jetty-webapp/src/main/java/org/eclipse/jetty/webapp/WebAppContext.java", "rawCode": "  /**\n   * Set temporary directory for context. The javax.servlet.context.tempdir attribute is also set.\n   *\n   * @param dir Writable temporary directory.\n   */\n  public void setTempDirectory(File dir) {\n    if (isStarted()) throw new IllegalStateException(\"Started\");\n\n    if (dir != null) {\n      try {\n        dir = new File(dir.getCanonicalPath());\n      } catch (IOException e) {\n        LOG.warn(Log.EXCEPTION, e);\n      }\n    }\n\n    if (dir != null && !dir.exists()) {\n      dir.mkdir();\n      dir.deleteOnExit();\n    }\n\n    if (dir != null && (!dir.exists() || !dir.isDirectory() || !dir.canWrite()))\n      throw new IllegalArgumentException(\"Bad temp directory: \" + dir);\n\n    try {\n      if (dir != null) dir = dir.getCanonicalFile();\n    } catch (Exception e) {\n      LOG.warn(e);\n    }\n    _tmpDir = dir;\n    setAttribute(TEMPDIR, _tmpDir);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2006, "initialization": ["File file = new File(String,*)", "File file = new File(String,*)"], "initializationStart": [527, 668], "initializationEnd": [581, 709], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 936, "focalAPIEnd": 947, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(String,var)", "new File(file,String)", "new File(file,*)", "new File(file,*)", "new File(file,*)", "file.delete()"], "useStart": [874, 1164, 1661, 2689, 2907, 2940], "useEnd": [948, 1192, 1684, 2712, 2930, 2950], "hasFinally": 1, "cleanUpCall": ["new File(File,*)", "File.delete()"], "finallyExpressionStart": 1539, "finallyExpressionEnd": 1547, "finallyBlockStart": 1539, "finallyBlockEnd": 1579, "cleanUpCallStart": [1661, 2722], "cleanUpCallEnd": [1684, 2732], "url": "https://github.com/bluespark80/example/tree/master/luni/src/test/java/tests/api/java/io/FileTest.java", "rawCode": "  /** @tests java.io.File#list() */\n  @TestTargetNew(\n    level = TestLevel.PARTIAL_COMPLETE,\n    method = \"list\",\n    args = {}\n  )\n  public void test_list() {\n    // Test for method java.lang.String [] java.io.File.list()\n\n    String base = System.getProperty(\"java.io.tmpdir\");\n    // Old test left behind \"garbage files\" so this time it creates a\n    // directory\n    // that is guaranteed not to already exist (and deletes it afterward.)\n    int dirNumber = 1;\n    boolean dirExists = true;\n    File dir = null;\n    dir = new File(base, platformId + String.valueOf(dirNumber));\n    while (dirExists) {\n      if (dir.exists()) {\n        dirNumber++;\n        dir = new File(base, String.valueOf(dirNumber));\n      } else {\n        dirExists = false;\n      }\n    }\n\n    String[] flist = dir.list();\n\n    assertNull(\"Method list() Should Have Returned null.\", flist);\n\n    assertTrue(\"Could not create parent directory for list test\", dir.mkdir());\n\n    String[] files = {\"mtzz1.xx\", \"mtzz2.xx\", \"mtzz3.yy\", \"mtzz4.yy\"};\n    try {\n      assertEquals(\n          \"Method list() Should Have Returned An Array Of Length 0.\", 0, dir.list().length);\n\n      File file = new File(dir, \"notADir.tst\");\n      try {\n        FileOutputStream fos = new FileOutputStream(file);\n        fos.close();\n        assertNull(\n            \"listFiles Should Have Returned Null When Used On A File Instead Of A Directory.\",\n            file.list());\n      } catch (IOException e) {\n        fail(\"Unexpected IOException during test : \" + e.getMessage());\n      } finally {\n        file.delete();\n      }\n\n      try {\n        for (int i = 0; i < files.length; i++) {\n          File f = new File(dir, files[i]);\n          FileOutputStream fos = new FileOutputStream(f);\n          fos.close();\n        }\n      } catch (IOException e) {\n        fail(\"Unexpected IOException during test : \" + e.getMessage());\n      }\n\n      flist = dir.list();\n      if (flist.length != files.length) {\n        fail(\"Incorrect list returned\");\n      }\n\n      // Checking to make sure the correct files were are listed in the\n      // array.\n      boolean[] check = new boolean[flist.length];\n      for (int i = 0; i < check.length; i++) check[i] = false;\n      for (int i = 0; i < files.length; i++) {\n        for (int j = 0; j < flist.length; j++) {\n          if (flist[j].equals(files[i])) {\n            check[i] = true;\n            break;\n          }\n        }\n      }\n      int checkCount = 0;\n      for (int i = 0; i < check.length; i++) {\n        if (check[i] == false) checkCount++;\n      }\n      assertEquals(\"Invalid file returned in listing\", 0, checkCount);\n\n      for (int i = 0; i < files.length; i++) {\n        File f = new File(dir, files[i]);\n        f.delete();\n      }\n\n      assertTrue(\"Could not delete parent directory for list test.\", dir.delete());\n    } finally {\n      for (int i = 0; i < files.length; i++) {\n        File f = new File(dir, files[i]);\n        f.delete();\n      }\n      dir.delete();\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2007, "initialization": ["File file = new File(File,String)"], "initializationStart": [536], "initializationEnd": [561], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 618, "focalAPIEnd": 633, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/traycold/crengine/tree/master/android/src/org/coolreader/crengine/Engine.java", "rawCode": "  /**\n   * Get or create writable subdirectory for specified base directory\n   *\n   * @param dir is base directory\n   * @param subdir is subdirectory name, null to use base directory\n   * @param createIfNotExists is true to force directory creation\n   * @return writable directory, null if not exist or not writable\n   */\n  public static File getSubdir(\n      File dir, String subdir, boolean createIfNotExists, boolean writableOnly) {\n    if (dir == null) return null;\n    File dataDir = dir;\n    if (subdir != null) {\n      dataDir = new File(dataDir, subdir);\n      if (!dataDir.isDirectory() && createIfNotExists) dataDir.mkdir();\n    }\n    if (dataDir.isDirectory() && (!writableOnly || dataDir.canWrite())) return dataDir;\n    return null;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2008, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 136, "focalAPIEnd": 146, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,*)", "copyFile(File,file)", "new File(file,*)", "new FileOutputStream(file)"], "useStart": [439, 520, 667, 788], "useEnd": [464, 535, 695, 812], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MiniSEC/adito_reload/tree/master/adito/branches/nonembedded/maverick-util/src/main/java/com/maverick/util/IOUtil.java", "rawCode": "  public static void copyFile(File from, File to) throws IOException {\n\n    if (from.isDirectory()) {\n      if (!to.exists()) {\n        to.mkdir();\n      }\n      String[] children = from.list();\n      for (int i = 0; i < children.length; i++) {\n        File f = new File(from, children[i]);\n        if (f.getName().equals(\".\") || f.getName().equals(\"..\")) {\n          continue;\n        }\n        if (f.isDirectory()) {\n          File f2 = new File(to, f.getName());\n          copyFile(f, f2);\n        } else {\n          copyFile(f, to);\n        }\n      }\n    } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n      if (to.isDirectory()) {\n        to = new File(to, from.getName());\n      }\n      FileInputStream in = new FileInputStream(from);\n      FileOutputStream out = new FileOutputStream(to);\n      byte[] buf = new byte[32678];\n      int read;\n      while ((read = in.read(buf)) > -1) {\n        out.write(buf, 0, read);\n      }\n      closeStream(in);\n      closeStream(out);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2009, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 165, "focalAPIEnd": 187, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,*)", "copyFile(File,file)"], "useStart": [358, 439], "useEnd": [395, 479], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/umple/Umple/tree/master/UmpleUIModel/src/cruise/writer/ClassWriter.java", "rawCode": "  public static void copyDirectory(File sourceLocation, File targetLocation) {\n    if (sourceLocation.isDirectory()) {\n      if (!targetLocation.exists()) {\n        targetLocation.mkdir();\n      }\n\n      String[] children = sourceLocation.list();\n      for (int i = 0; i < children.length; i++) {\n        copyDirectory(new File(sourceLocation, children[i]), new File(targetLocation, children[i]));\n      }\n    } else {\n      try {\n        copyFile(sourceLocation, targetLocation);\n      } catch (IOException e) {\n        throw new GeneratorException(\n            \"Error: Copying the directory/file: \" + sourceLocation.getAbsolutePath(), e);\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2010, "initialization": ["File file = new File(String)"], "initializationStart": [76], "initializationEnd": [92], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 131, "focalAPIEnd": 143, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xstd/quick_setting/tree/master/src_lib/mcuslib/src/com/plugin/common/utils/zip/FileOperator.java", "rawCode": "  public static final void createDirectory(String strDir) {\n    File file = new File(strDir);\n    if (!file.isDirectory()) {\n      file.mkdir();\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2011, "initialization": ["File file = new File(*)"], "initializationStart": [3654], "initializationEnd": [3684], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 3690, "focalAPIEnd": 3701, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.mkdirs()", "file.deleteOnExit()", "file.getCanonicalPath()", "file.deleteOnExit()", "file.getCanonicalPath()"], "useStart": [3947, 4826, 4861, 5154, 5189], "useEnd": [3959, 4844, 4883, 5172, 5211], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/security/src/test/java/tests/security/permissions/JavaIoFileTest.java", "rawCode": "  @TestTargets({\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"canWrite\",\n      args = {}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"createNewFile\",\n      args = {}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"createTempFile\",\n      args = {java.lang.String.class, java.lang.String.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"createTempFile\",\n      args = {java.lang.String.class, java.lang.String.class, java.io.File.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"mkdir\",\n      args = {}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"mkdirs\",\n      args = {}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"renameTo\",\n      args = {java.io.File.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"setLastModified\",\n      args = {long.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"Verifies that write/create methods of File class call checkWrite on security manager.\",\n      method = \"setReadOnly\",\n      args = {}\n    )\n  })\n  public void test_File3() throws IOException {\n    class TestSecurityManager extends SecurityManager {\n      boolean called;\n      String file;\n\n      void reset() {\n        called = false;\n        file = null;\n      }\n\n      @Override\n      public void checkWrite(String file) {\n        called = true;\n        this.file = file;\n      }\n\n      @Override\n      public void checkPermission(Permission p) {}\n    }\n\n    String tmpPath = System.getProperty(\"java.io.tmpdir\");\n    if (!tmpPath.endsWith(\"/\")) {\n      tmpPath += \"/\";\n    }\n    long id = new java.util.Date().getTime();\n    String filename = \"SecurityPermissionsTest_\" + id;\n    String filename2 = \"SecurityPermissionsTest_\" + (id + 1);\n    File f = File.createTempFile(filename, null);\n    f.deleteOnExit();\n    filename = f.getCanonicalPath();\n\n    File f2 = File.createTempFile(filename2, null);\n    f2.deleteOnExit();\n    filename2 = f2.getCanonicalPath();\n\n    TestSecurityManager s = new TestSecurityManager();\n    System.setSecurityManager(s);\n\n    s.reset();\n    f.canWrite();\n    assertTrue(\"File.canWrite() must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", filename, s.file);\n\n    s.reset();\n    f.createNewFile();\n    assertTrue(\"File.createNewFile() must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", filename, s.file);\n\n    s.reset();\n    File tmp = new File(tmpPath + \"dir\" + id);\n    tmp.mkdir();\n    assertTrue(\"File.canWrite() must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", tmpPath + \"dir\" + id, s.file);\n\n    s.reset();\n    tmp = new File(tmpPath + \"a\" + id + \"/b/c\");\n    tmp.mkdirs();\n    assertTrue(\"File.mkdirs() must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", tmpPath + \"a\" + id + \"/b/c\", s.file);\n\n    s.reset();\n    f.renameTo(f2);\n    assertTrue(\"File.renameTo(File) must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", filename2, s.file);\n\n    s.reset();\n    f.setLastModified(id);\n    assertTrue(\"File.setLastModified() must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", filename, s.file);\n\n    s.reset();\n    f.setReadOnly();\n    assertTrue(\"File.setReadOnly() must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", filename, s.file);\n\n    s.reset();\n    tmp = File.createTempFile(\"xxx\", \"yyy\");\n    tmp.deleteOnExit();\n    filename = tmp.getCanonicalPath();\n    assertTrue(\n        \"File.createTempFile(String,String) must call checkWrite on security manager\", s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", filename, s.file);\n\n    s.reset();\n    tmp = File.createTempFile(\"xxx\", \"yyy\", (File) null);\n    tmp.deleteOnExit();\n    filename = tmp.getCanonicalPath();\n    assertTrue(\n        \"File.createTempFile(String,String,File) must call checkWrite on security manager\",\n        s.called);\n    assertEquals(\"Argument of checkWrite is not correct\", filename, s.file);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2012, "initialization": ["File file = new File(*,String)"], "initializationStart": [292], "initializationEnd": [325], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 350, "focalAPIEnd": 361, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/amal029/jop/tree/master/java/tools/src/com/jopdesign/wcet/ProjectConfig.java", "rawCode": "  /**\n   * Create and return output directory {@code OUT_DIR / getProjectName() / subdir}\n   *\n   * @param subdir subdirectory of project output directory, created if necessary\n   * @return the path to the subdirectory for output\n   */\n  public File getOutDir(String subdir) {\n    File dir = new File(getProjectDir(), subdir);\n    if (!dir.exists()) dir.mkdir();\n    return dir;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2013, "initialization": ["File file = new File(String)"], "initializationStart": [87], "initializationEnd": [150], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 196, "focalAPIEnd": 211, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getPath()"], "useStart": [244], "useEnd": [261], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/directory-server/tree/master/server-config/src/test/java/org/apache/directory/server/config/LdapServerConfigReaderTest.java", "rawCode": "  @BeforeClass\n  public static void readConfig() throws Exception {\n    File workDir = new File(System.getProperty(\"java.io.tmpdir\") + \"/server-work\");\n    FileUtils.deleteDirectory(workDir);\n    workDir.mkdir();\n\n    String workingDirectory = workDir.getPath();\n    // Extract the schema on disk (a brand new one) and load the registries\n    File schemaRepository = new File(workingDirectory, \"schema\");\n\n    if (schemaRepository.exists()) {\n      FileUtils.deleteDirectory(schemaRepository);\n    }\n\n    SchemaLdifExtractor extractor = new DefaultSchemaLdifExtractor(new File(workingDirectory));\n    extractor.extractOrCopy();\n\n    SchemaLoader loader = new LdifSchemaLoader(schemaRepository);\n    schemaManager = new DefaultSchemaManager(loader);\n\n    // We have to load the schema now, otherwise we won't be able\n    // to initialize the Partitions, as we won't be able to parse\n    // and normalize their suffix Dn\n    schemaManager.loadAllEnabled();\n\n    List<Throwable> errors = schemaManager.getErrors();\n\n    if (errors.size() != 0) {\n      throw new Exception(\"Schema load failed : \" + Exceptions.printErrors(errors));\n    }\n\n    dnFactory = new DefaultDnFactory(schemaManager, 100);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2014, "initialization": ["File file = new File(*)"], "initializationStart": [242], "initializationEnd": [296], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 314, "focalAPIEnd": 372, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nfmangano/CalicoServer/tree/master/calico3server/src/calico/controllers/CImageController.java", "rawCode": "  public static void save_to_disk(long uuid, String name, byte[] image) throws IOException {\n\n    if (imageExists(uuid)) {\n      try {\n        (new File(getImagePath(uuid))).delete();\n      } catch (Exception ioe) {\n\n      }\n    }\n\n    if (!(new File(COptions.server.images.download_folder + \"/\")).exists())\n      (new File(COptions.server.images.download_folder)).mkdir();\n\n    String fileExt = getFileExtension(name);\n\n    String filePath = COptions.server.images.download_folder + Long.toString(uuid) + \".\" + fileExt;\n\n    FileObject backupFile = COptions.fs.resolveFile(filePath);\n    if (!backupFile.exists()) backupFile.createFile();\n    backupFile.close();\n\n    File imageFile = new File(filePath);\n\n    OutputStream os = new FileOutputStream(imageFile);\n\n    os.write(image);\n\n    os.close();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2015, "initialization": ["File file = new File(String,String)"], "initializationStart": [141], "initializationEnd": [189], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 246, "focalAPIEnd": 266, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anthonydahanne/make-p2-buildable-with-tycho/tree/master/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/LocalMetadataRepositoryTest.java", "rawCode": "  protected void setUp() throws Exception {\n    super.setUp();\n    String tempDir = System.getProperty(\"java.io.tmpdir\");\n    repoLocation = new File(tempDir, \"LocalMetadataRepositoryTest\");\n    AbstractProvisioningTest.delete(repoLocation);\n    repoLocation.mkdir();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2016, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 781, "tryExpressionEnd": 785, "tryBlockStart": 781, "tryBlockEnd": 3072, "catchExpressionStart": 3006, "catchExpressionEnd": 3028, "catchBlockStart": 3006, "catchBlockEnd": 3072, "exceptionHandlingCallStart": [3042], "exceptionHandlingCallEnd": [3065], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 793, "focalAPIEnd": 815, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [835], "useEnd": [871], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geoserver-2.1.x/tree/master/extension/app-schema/app-schema-test/src/test/java/org/geoserver/test/AbstractAppSchemaMockData.java", "rawCode": "  /**\n   * Write an info.xml file describing a feature type to the feature type directory.\n   *\n   * <p>Stolen from {@link MockData}.\n   *\n   * @param namespacePrefix namespace prefix of the WFS feature type\n   * @param typeName namespace prefix of the WFS feature type\n   * @param featureTypeDir feature type directory\n   * @param dataStoreName data store directory name\n   */\n  private static void writeInfoFile(\n      String namespacePrefix, String typeName, File featureTypeDir, String dataStoreName) {\n    // prepare extra params default\n    Map<String, Object> params = new HashMap<String, Object>();\n    params.put(KEY_STYLE, \"Default\");\n    params.put(KEY_SRS_HANDLINGS, 2);\n    params.put(KEY_ALIAS, null);\n    Integer srs = 4326;\n    params.put(KEY_SRS_NUMBER, srs);\n    try {\n      featureTypeDir.mkdir();\n      File info = new File(featureTypeDir, \"info.xml\");\n      info.delete();\n      info.createNewFile();\n      FileWriter writer = new FileWriter(info);\n      writer.write(\"<featureType datastore=\\\"\" + dataStoreName + \"\\\">\");\n      writer.write(\"<name>\" + typeName + \"</name>\");\n      if (params.get(KEY_ALIAS) != null)\n        writer.write(\"<alias>\" + params.get(KEY_ALIAS) + \"</alias>\");\n      writer.write(\"<SRS>\" + params.get(KEY_SRS_NUMBER) + \"</SRS>\");\n      // this mock type may have wrong SRS compared to the actual one in the property files...\n      // let's configure SRS handling not to alter the original one, and have 4326 used only\n      // for capabilities\n      writer.write(\"<SRSHandling>\" + params.get(KEY_SRS_HANDLINGS) + \"</SRSHandling>\");\n      writer.write(\"<title>\" + typeName + \"</title>\");\n      writer.write(\"<abstract>abstract about \" + typeName + \"</abstract>\");\n      writer.write(\"<numDecimals value=\\\"8\\\"/>\");\n      writer.write(\"<keywords>\" + typeName + \"</keywords>\");\n      Envelope llEnvelope = (Envelope) params.get(KEY_LL_ENVELOPE);\n      if (llEnvelope == null) llEnvelope = DEFAULT_ENVELOPE;\n      writer.write(\n          \"<latLonBoundingBox dynamic=\\\"false\\\" minx=\\\"\"\n              + llEnvelope.getMinX()\n              + \"\\\" miny=\\\"\"\n              + llEnvelope.getMinY()\n              + \"\\\" maxx=\\\"\"\n              + llEnvelope.getMaxX()\n              + \"\\\" maxy=\\\"\"\n              + llEnvelope.getMaxY()\n              + \"\\\"/>\");\n      Envelope nativeEnvelope = (Envelope) params.get(KEY_NATIVE_ENVELOPE);\n      if (nativeEnvelope != null)\n        writer.write(\n            \"<nativeBBox dynamic=\\\"false\\\" minx=\\\"\"\n                + nativeEnvelope.getMinX()\n                + \"\\\" miny=\\\"\"\n                + nativeEnvelope.getMinY()\n                + \"\\\" maxx=\\\"\"\n                + nativeEnvelope.getMaxX()\n                + \"\\\" maxy=\\\"\"\n                + nativeEnvelope.getMaxY()\n                + \"\\\"/>\");\n      String style = (String) params.get(KEY_STYLE);\n      if (style == null) style = \"Default\";\n      writer.write(\"<styles default=\\\"\" + style + \"\\\"/>\");\n      writer.write(\"</featureType>\");\n      writer.flush();\n      writer.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2017, "initialization": ["File file = new File(File,String)"], "initializationStart": [94], "initializationEnd": [126], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 132, "focalAPIEnd": 145, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AsherBond/glusterfs-hadoop/tree/master/src/test/java/org/gluster/test/GFSUtil.java", "rawCode": "  public static File initializeMounts(File tempDirectory) throws Exception {\n    File mount = new File(tempDirectory, \"mount\");\n    mount.mkdir();\n    return mount;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2018, "initialization": ["File file = createTempFile(*,String,*)"], "initializationStart": [131], "initializationEnd": [204], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 66, "tryExpressionEnd": 70, "tryBlockStart": 66, "tryBlockEnd": 3179, "catchExpressionStart": 3090, "catchExpressionEnd": 3110, "catchBlockStart": 3090, "catchBlockEnd": 3179, "exceptionHandlingCallStart": [3118], "exceptionHandlingCallEnd": [3153], "configuration": ["file.delete()"], "configurationStart": [212], "configurationEnd": [223], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 231, "focalAPIEnd": 241, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.deleteOnExit()", "new File(file,*)"], "useStart": [249, 290], "useEnd": [266, 320], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JohannesBuchner/Jake/tree/master/violet/src/main/java/com/jakeapp/violet/actions/global/serve/ProjectRequestListener.java", "rawCode": "  @Override\n  public File getFileForRequest(FileRequest fr) {\n    try {\n      log.info(\"incoming request: \" + fr);\n      File od = File.createTempFile(fr.getPeer().getUserId(), \"\", getDeliveryDirectory());\n      od.delete();\n      od.mkdir();\n      od.deleteOnExit();\n      File tempfile = new File(od, fr.getFileName());\n      tempfile.deleteOnExit();\n      OutputStream os = new FileOutputStream(tempfile);\n\n      RequestFileMessage req =\n          requestMarshaller.decodeRequestFileMessage(fr.getFileName(), fr.getPeer());\n\n      if (!canHandleFileRequest(req)) return null;\n\n      if (req.getType() == RequestType.LOGS) {\n        List<LogEntry> logs = model.getLog().getAll(true);\n\n        logEntryMarshaller.packLogEntries(model.getProjectid(), logs, new GZIPOutputStream(os));\n        return tempfile;\n      } else {\n        if (req.getType() == RequestType.FILE\n            || req.getType() == RequestType.SIGNATURE\n            || req.getType() == RequestType.DELTA) {\n          LogEntry le = model.getLog().getById(req.getProjectId(), false);\n          String hash = le.getHow();\n          JakeObject fo = le.getWhat();\n          File origfile = new File(model.getFss().getFullpath(fo.getRelPath()));\n          log.info(\"original file at \" + origfile);\n\n          if (req.getType() == RequestType.DELTA) {\n            // so the other guy wants a delta\n            // what a smart-ass\n            // he has to send his signature first, so lets ask him\n            log.debug(\"requesting signature\");\n            RequestFileMessage msg =\n                RequestFileMessage.createRequestSignatureMessage(\n                    model.getProjectid(), fr.getPeer(), le);\n\n            InputStream fis = BlockingFileTransfer.requestFile(model, requestMarshaller, msg, null);\n            if (fis == null) {\n              log.debug(\"requesting signatures did not succeed.\");\n              return null;\n            }\n            log.debug(\"creating delta from signature\");\n            Rdiff rdiff = new Rdiff();\n            List<ChecksumPair> sums = rdiff.readSignatures(fis);\n            InputStream is = FSService.readFileStreamAbs(origfile);\n            rdiff.makeDeltas(sums, is, os);\n            log.debug(\"delta created\");\n          }\n          if (req.getType() == RequestType.SIGNATURE) {\n            // create a signature file\n            Rdiff rdiff = new Rdiff();\n            InputStream is = FSService.readFileStreamAbs(origfile);\n            rdiff.makeSignatures(is, os);\n            log.debug(\"signature created\");\n          } else {\n            // just ship the file\n            if (!model.getFss().calculateHashOverFile(fo.getRelPath()).equals(hash)) {\n              log.debug(\"can not provide file as we modified it.\");\n              return null;\n            }\n            // copy the whole file\n            FSService.writeFileStreamAbs(tempfile, FSService.readFileStreamAbs(origfile));\n            log.debug(\"file duplicated\");\n          }\n        } else {\n          log.warn(\"can't understand message\");\n          return null;\n        }\n        return tempfile;\n      }\n    } catch (Exception e) {\n      log.warn(\"unexpected Exception\", e);\n      return null;\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2019, "initialization": ["File file = new File(*)"], "initializationStart": [720], "initializationEnd": [945], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 951, "focalAPIEnd": 974, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getPage(String,String,file)", "getPage(String,String,file)"], "useStart": [1015, 1101], "useEnd": [1056, 1141], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wholcomb/tip/tree/master/projects/unsorted/get_calendar/GetCalendar.java", "rawCode": "  public File getCalendars() throws IOException {\n    fileCount = 0;\n\n    URL index =\n        new URL(\n            \"http://page-a-day.com\"\n                + \"/pub-bin/paduserlogin.pl?rm=setuser\"\n                + \"&target_uri=/index.pl\"\n                + \"&email=\"\n                + username\n                + \"&password=\"\n                + password);\n\n    HttpURLConnection connection = (HttpURLConnection) index.openConnection();\n    connection.setDoOutput(true);\n    connection.setAllowUserInteraction(false);\n    connection.setUseCaches(false);\n\n    String cookie = connection.getHeaderField(\"Set-Cookie\");\n\n    DateFormat dirFormat = new SimpleDateFormat(\"yyyy.MM.dd_hh:mm:ss\");\n\n    File outputDirectory =\n        new File(\n            System.getProperty(\"java.io.tmpdir\")\n                + File.separator\n                + calendar\n                + \"-\"\n                + dirFormat.format(time.getTime())\n                + File.separator);\n    outputDirectory.mkdir();\n\n    if ((sides & FRONT) != 0) {\n      getPage(\"front\", cookie, outputDirectory);\n    }\n    if ((sides & BACK) != 0) {\n      getPage(\"back\", cookie, outputDirectory);\n    }\n    return outputDirectory;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2020, "initialization": ["File file = new File(String)"], "initializationStart": [227], "initializationEnd": [261], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 286, "focalAPIEnd": 297, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getCanonicalFile()", "file.getPath()", "asList(file)", "file.delete()"], "useStart": [468, 585, 841, 1086], "useEnd": [490, 598, 859, 1098], "hasFinally": 1, "cleanUpCall": ["File.delete()"], "finallyExpressionStart": 1056, "finallyExpressionEnd": 1064, "finallyBlockStart": 1056, "finallyBlockEnd": 1183, "cleanUpCallStart": [1086], "cleanUpCallEnd": [1098], "url": "https://github.com/ikeji/openjdk7-langtools/tree/master/test/tools/javac/api/T6358955.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n    StandardJavaFileManager jfm = compiler.getStandardFileManager(null, null, null);\n\n    File dir = new File(\"temp\" + args.hashCode());\n    if (!dir.exists()) dir.mkdir();\n    if (!dir.isDirectory()) throw new AssertionError(\"Not a directory \" + dir);\n\n    try {\n      jfm.setLocation(\n          StandardLocation.CLASS_OUTPUT, Arrays.asList(dir.getCanonicalFile().getParentFile()));\n      try {\n        jfm.getFileForInput(StandardLocation.CLASS_OUTPUT, \"\", dir.getPath());\n        throw new AssertionError(\"IllegalArgumentException not thrown\");\n      } catch (IllegalArgumentException e) {\n        System.out.println(\"OK: \" + e.getLocalizedMessage());\n      }\n      try {\n        jfm.getJavaFileObjectsFromFiles(Arrays.asList(dir));\n        throw new AssertionError(\"IllegalArgumentException not thrown\");\n      } catch (IllegalArgumentException e) {\n        System.out.println(\"OK: \" + e.getLocalizedMessage());\n      }\n    } finally {\n      try {\n        dir.delete(); // cleanup\n      } catch (Throwable t) {\n        t.printStackTrace();\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2021, "initialization": ["File file = createTempFile(String,String,File)"], "initializationStart": [83], "initializationEnd": [130], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.delete()"], "configurationStart": [163], "configurationEnd": [176], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 182, "focalAPIEnd": 194, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nuxeo/nuxeo-ide/tree/master/plugins/org.nuxeo.ide.common/src/org/nuxeo/ide/common/IOUtils.java", "rawCode": "  public static File createTempDir(File root) throws IOException {\n    File file = File.createTempFile(\"nuxeo-ide-\", \".tmp\", root);\n    // TODO not atomic ...\n    file.delete();\n    file.mkdir();\n    return file;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2022, "initialization": ["File file = new File(File,String)"], "initializationStart": [355], "initializationEnd": [389], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 397, "focalAPIEnd": 408, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Starlink/starjava/tree/master/ant/src/main/org/apache/tools/ant/taskdefs/optional/ssh/ScpFromMessage.java", "rawCode": "  private File parseAndCreateDirectory(String serverResponse, File localFile) {\n    int start = serverResponse.indexOf(\" \");\n    // appears that the next token is not used and it's zero.\n    start = serverResponse.indexOf(\" \", start + 1);\n    String directoryName = serverResponse.substring(start + 1);\n    if (localFile.isDirectory()) {\n      File dir = new File(localFile, directoryName);\n      dir.mkdir();\n      log(\"Creating: \" + dir);\n      return dir;\n    }\n    return null;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2023, "initialization": ["File file = new File(String)"], "initializationStart": [88], "initializationEnd": [107], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 113, "focalAPIEnd": 128, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/unclebob/fitnesse/tree/master/test/fitnesse/responders/run/TestResponderTest.java", "rawCode": "  @Before\n  public void setUp() throws Exception {\n    debug = true;\n    File testDir = new File(\"TestDir\");\n    testDir.mkdir();\n    Properties properties = new Properties();\n    context = FitNesseUtil.makeTestContext();\n    root = context.getRootPage();\n    request = new MockRequest();\n    responder = new TestResponder();\n    properties.setProperty(\"FITNESSE_PORT\", String.valueOf(context.port));\n    new DateAlteringClock(DateTimeUtil.getDateFromString(TEST_TIME)).advanceMillisOnEachQuery();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2024, "initialization": ["File file = new File(String,String)"], "initializationStart": [59], "initializationEnd": [92], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 98, "focalAPIEnd": 109, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)", "new File(file,String)", "new PropertyDataStore(file)"], "useStart": [128, 585, 1036], "useEnd": [160, 625, 1062], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geotools-2.7.x/tree/master/modules/plugin/property/src/test/java/org/geotools/data/property/PropertyDataStoreTest.java", "rawCode": "  protected void setUp() throws Exception {\n    File dir = new File(\".\", \"propertyTestData\");\n    dir.mkdir();\n\n    File file = new File(dir, \"road.properties\");\n    if (file.exists()) {\n      file.delete();\n    }\n    BufferedWriter writer = new BufferedWriter(new FileWriter(file));\n    writer.write(\"_=id:Integer,name:String\");\n    writer.newLine();\n    writer.write(\"fid1=1|jody\");\n    writer.newLine();\n    writer.write(\"fid2=2|brent\");\n    writer.newLine();\n    writer.write(\"fid3=3|dave\");\n    writer.newLine();\n    writer.write(\"fid4=4|justin\");\n    writer.close();\n\n    file = new File(dir, \"dots.in.name.properties\");\n    if (file.exists()) {\n      file.delete();\n    }\n    writer = new BufferedWriter(new FileWriter(file));\n    writer.write(\"_=id:Integer,name:String\");\n    writer.newLine();\n    writer.write(\"fid1=1|jody\");\n    writer.newLine();\n    writer.write(\"fid2=2|brent\");\n    writer.newLine();\n    writer.write(\"fid3=3|dave\");\n    writer.newLine();\n    writer.write(\"fid4=4|justin\");\n    writer.close();\n\n    store = new PropertyDataStore(dir);\n    super.setUp();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2025, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1751, "focalAPIEnd": 1763, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["opCopyDir(file,*,long,*,*,File,*,*,long,*,*,*,*)", "opAddDirectory(file,*)", "opCopyDir(file,*,long,*,*,File,*,*,long,*,*,*,*)", "opAddDirectory(file,*)", "setAddedPath(file)", "treeConflictOnAdd(file,*,*,*)", "treeConflictOnAdd(file,*,*,*)"], "useStart": [2019, 2517, 3011, 3543, 3631, 3856, 4302], "useEnd": [2488, 2564, 3510, 3590, 3649, 3944, 4408], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/svnkit/tree/master/svnkit/src/main/java/org/tmatesoft/svn/core/internal/wc2/ng/SvnNgMergeCallback.java", "rawCode": "  public void dirAdded(\n      SvnDiffCallbackResult result,\n      File path,\n      long revision,\n      String copyFromPath,\n      long copyFromRevision)\n      throws SVNException {\n    if (isRecordOnly()) {\n      result.contentState = SVNStatusType.UNCHANGED;\n      return;\n    }\n    File parentPath = SVNFileUtil.getParentFile(path);\n    String child = SVNWCUtils.getPathAsChild(getTargetPath(), path);\n    SVNURL copyFromUrl = null;\n    long copyFromRev = -1;\n    if (isSameRepos()) {\n      copyFromUrl = getSource2URL().appendPath(child, false);\n      copyFromRev = revision;\n      checkReposMatch(parentPath, copyFromUrl);\n    }\n    ObstructionState os = driver.performObstructionCheck(path, SVNNodeKind.UNKNOWN);\n    boolean isVersioned = os.kind == SVNNodeKind.DIR || os.kind == SVNNodeKind.FILE;\n    if (os.obstructionState == SVNStatusType.OBSTRUCTED\n        && (os.deleted || os.kind == SVNNodeKind.NONE)) {\n      SVNFileType diskKind = SVNFileType.getType(path);\n      if (diskKind == SVNFileType.DIRECTORY) {\n        os.obstructionState = SVNStatusType.INAPPLICABLE;\n        os.kind = SVNNodeKind.DIR;\n      }\n    }\n    if (os.obstructionState != SVNStatusType.INAPPLICABLE) {\n      if (isDryRun() && getAddedPath() != null && SVNWCUtils.isChild(getAddedPath(), path)) {\n        result.contentState = SVNStatusType.CHANGED;\n      } else {\n        result.contentState = os.obstructionState;\n      }\n      return;\n    }\n    if (os.deleted) {\n      os.kind = SVNNodeKind.NONE;\n    }\n\n    if (os.kind == SVNNodeKind.NONE) {\n      if (isDryRun()) {\n        if (getDryRunAdditions() == null) {\n          setDryRunAddtions(new HashSet<File>());\n        }\n        getDryRunAdditions().add(path);\n        setAddedPath(path);\n      } else {\n        path.mkdir();\n        if (copyFromUrl != null) {\n          SVNWCNodeReposInfo reposInfo = getContext().getNodeReposInfo(parentPath);\n          File reposRelPath =\n              new File(SVNURLUtil.getRelativeURL(reposInfo.reposRootUrl, copyFromUrl, false));\n          getContext()\n              .getDb()\n              .opCopyDir(\n                  path,\n                  new SVNProperties(),\n                  copyFromRev,\n                  new SVNDate(0, 0),\n                  null,\n                  reposRelPath,\n                  reposInfo.reposRootUrl,\n                  reposInfo.reposUuid,\n                  copyFromRev,\n                  null,\n                  SVNDepth.INFINITY,\n                  null,\n                  null);\n        } else {\n          getContext().getDb().opAddDirectory(path, null);\n        }\n      }\n      result.contentState = SVNStatusType.CHANGED;\n    } else if (os.kind == SVNNodeKind.DIR) {\n      if (!isVersioned || os.deleted) {\n        if (!isDryRun()) {\n          if (copyFromUrl != null) {\n            SVNWCNodeReposInfo reposInfo = getContext().getNodeReposInfo(parentPath);\n            File reposRelPath =\n                new File(SVNURLUtil.getRelativeURL(reposInfo.reposRootUrl, copyFromUrl, false));\n            getContext()\n                .getDb()\n                .opCopyDir(\n                    path,\n                    new SVNProperties(),\n                    copyFromRev,\n                    new SVNDate(0, 0),\n                    null,\n                    reposRelPath,\n                    reposInfo.reposRootUrl,\n                    reposInfo.reposUuid,\n                    copyFromRev,\n                    null,\n                    SVNDepth.INFINITY,\n                    null,\n                    null);\n          } else {\n            getContext().getDb().opAddDirectory(path, null);\n          }\n        } else {\n          setAddedPath(path);\n        }\n        result.contentState = SVNStatusType.CHANGED;\n      } else {\n        if (driver.isDryRunDeletion(path)) {\n          result.contentState = SVNStatusType.CHANGED;\n        } else {\n          treeConflictOnAdd(path, SVNNodeKind.DIR, SVNConflictAction.ADD, SVNConflictReason.ADDED);\n          result.treeConflicted = true;\n          result.contentState = SVNStatusType.OBSTRUCTED;\n        }\n      }\n    } else if (os.kind == SVNNodeKind.FILE) {\n      if (isDryRun()) {\n        setAddedPath(null);\n      }\n      if (isVersioned && driver.isDryRunDeletion(path)) {\n        result.contentState = SVNStatusType.CHANGED;\n      } else {\n        treeConflictOnAdd(\n            path, SVNNodeKind.DIR, SVNConflictAction.ADD, SVNConflictReason.OBSTRUCTED);\n        result.treeConflicted = true;\n        result.contentState = SVNStatusType.OBSTRUCTED;\n      }\n    } else {\n      if (isDryRun()) {\n        setAddedPath(null);\n      }\n      result.contentState = SVNStatusType.UNKNOWN;\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2026, "initialization": ["File file = createTempFile(String,String)"], "initializationStart": [7622], "initializationEnd": [7657], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.delete()"], "configurationStart": [7663], "configurationEnd": [7684], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 7734, "focalAPIEnd": 7754, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getAbsolutePath()", "new File(file,String)", "file.delete()"], "useStart": [8859, 9182, 9413], "useEnd": [8889, 9226, 9434], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Vanuan/sweethome3d/tree/master/test/com/eteks/sweethome3d/junit/PrintTest.java", "rawCode": "  public void testPageSetupAndPrintPreview()\n      throws ComponentSearchException, InterruptedException, NoSuchFieldException,\n          IllegalAccessException, InvocationTargetException, IOException {\n    UserPreferences preferences = new DefaultUserPreferences();\n    ViewFactory viewFactory = new SwingViewFactory();\n    Home home = new Home();\n    ContentManager contentManager =\n        new FileContentManager(preferences) {\n          @Override\n          public String showSaveDialog(\n              View parentView, String dialogTitle, ContentType contentType, String name) {\n            String os = System.getProperty(\"os.name\");\n            if (OperatingSystem.isMacOSX()) {\n              // Let's pretend the OS isn't Mac OS X to get a JFileChooser instance that works\n              // better in test\n              System.setProperty(\"os.name\", \"dummy\");\n            }\n            try {\n              return super.showSaveDialog(parentView, dialogTitle, contentType, name);\n            } finally {\n              System.setProperty(\"os.name\", os);\n            }\n          }\n        };\n    final HomeController controller =\n        new HomeController(home, preferences, viewFactory, contentManager);\n\n    // 1. Create a frame that displays a home view\n    JFrame frame = new JFrame(\"Home Print Test\");\n    frame.add((JComponent) controller.getView());\n    frame.pack();\n\n    // Show home frame\n    showWindow(frame);\n    JComponentTester tester = new JComponentTester();\n    tester.waitForIdle();\n    // Add a piece of furniture to home\n    List<CatalogPieceOfFurniture> selectedPieces =\n        Arrays.asList(\n            new CatalogPieceOfFurniture[] {\n              preferences.getFurnitureCatalog().getCategories().get(0).getFurniture().get(0)\n            });\n    controller.getFurnitureCatalogController().setSelectedFurniture(selectedPieces);\n    tester.invokeAndWait(\n        new Runnable() {\n          public void run() {\n            runAction(controller, HomePane.ActionType.ADD_HOME_FURNITURE);\n          }\n        });\n    // Check home contains one piece\n    assertEquals(\"Home doesn't contain any furniture\", 1, home.getFurniture().size());\n\n    // 2. Edit page setup dialog box\n    tester.invokeLater(\n        new Runnable() {\n          public void run() {\n            // Display dialog box later in Event Dispatch Thread to avoid blocking test thread\n            runAction(controller, HomePane.ActionType.PAGE_SETUP);\n          }\n        });\n    // Wait for page setup to be shown\n    tester.waitForFrameShowing(\n        new AWTHierarchy(),\n        preferences.getLocalizedString(PageSetupPanel.class, \"pageSetup.title\"));\n    // Check dialog box is displayed\n    JDialog pageSetupDialog = (JDialog) TestUtilities.findComponent(frame, JDialog.class);\n    assertTrue(\"Page setup dialog not showing\", pageSetupDialog.isShowing());\n    // Retrieve PageSetupPanel components\n    PageSetupPanel pageSetupPanel =\n        (PageSetupPanel) TestUtilities.findComponent(frame, PageSetupPanel.class);\n    JCheckBox furniturePrintedCheckBox =\n        (JCheckBox) TestUtilities.getField(pageSetupPanel, \"furniturePrintedCheckBox\");\n    JCheckBox planPrintedCheckBox =\n        (JCheckBox) TestUtilities.getField(pageSetupPanel, \"planPrintedCheckBox\");\n    ;\n    JCheckBox view3DPrintedCheckBox =\n        (JCheckBox) TestUtilities.getField(pageSetupPanel, \"view3DPrintedCheckBox\");\n    // Check default edited values\n    assertTrue(\"Furniture printed not checked\", furniturePrintedCheckBox.isSelected());\n    assertTrue(\"Plan printed not checked\", planPrintedCheckBox.isSelected());\n    assertTrue(\"View 3D printed not checked\", view3DPrintedCheckBox.isSelected());\n\n    // 3. Change dialog box values\n    planPrintedCheckBox.setSelected(false);\n    // Click on Ok in dialog box\n    final JOptionPane pageSetupOptionPane =\n        (JOptionPane) TestUtilities.findComponent(pageSetupDialog, JOptionPane.class);\n    tester.invokeAndWait(\n        new Runnable() {\n          public void run() {\n            // Select Ok option to hide dialog box in Event Dispatch Thread\n            pageSetupOptionPane.setValue(JOptionPane.OK_OPTION);\n          }\n        });\n    assertFalse(\"Page setup dialog still showing\", pageSetupDialog.isShowing());\n    PageFormat pageFormat = PrinterJob.getPrinterJob().defaultPage();\n    // Check home print attributes are modified accordingly\n    assertHomePrintEqualPrintAttributes(pageFormat, true, false, true, home);\n\n    // 4. Undo changes\n    runAction(controller, HomePane.ActionType.UNDO);\n    // Check home attributes have previous values\n    assertEquals(\"Home print set\", null, home.getPrint());\n    // Redo\n    runAction(controller, HomePane.ActionType.REDO);\n    // Check home attributes are modified accordingly\n    assertHomePrintEqualPrintAttributes(pageFormat, true, false, true, home);\n\n    // 5. Show print preview dialog box\n    tester.invokeLater(\n        new Runnable() {\n          public void run() {\n            // Display dialog box later in Event Dispatch Thread to avoid blocking test thread\n            runAction(controller, HomePane.ActionType.PRINT_PREVIEW);\n          }\n        });\n    // Wait for print preview to be shown\n    tester.waitForFrameShowing(\n        new AWTHierarchy(),\n        preferences.getLocalizedString(PrintPreviewPanel.class, \"printPreview.title\"));\n    // Check dialog box is displayed\n    JDialog printPreviewDialog =\n        (JDialog) new BasicFinder().find(frame, new ClassMatcher(JDialog.class, true));\n    assertTrue(\"Print preview dialog not showing\", printPreviewDialog.isShowing());\n    // Retrieve PageSetupPanel components\n    PrintPreviewPanel printPreviewPanel =\n        (PrintPreviewPanel) TestUtilities.findComponent(frame, PrintPreviewPanel.class);\n    JToolBar toolBar = (JToolBar) TestUtilities.getField(printPreviewPanel, \"toolBar\");\n    JButton previousButton = (JButton) toolBar.getComponent(0);\n    final JButton nextButton = (JButton) toolBar.getComponent(1);\n    HomePrintableComponent printableComponent =\n        (HomePrintableComponent) TestUtilities.getField(printPreviewPanel, \"printableComponent\");\n    ;\n    // Check if buttons are enabled and if printable component displays the first page\n    assertFalse(\"Previous button is enabled\", previousButton.isEnabled());\n    assertTrue(\"Next button is disabled\", nextButton.isEnabled());\n    assertEquals(\"Printable component doesn't display first page\", 0, printableComponent.getPage());\n    assertEquals(\"Wrong printable component page count\", 2, printableComponent.getPageCount());\n\n    // 6. Click on next page button\n    tester.invokeAndWait(\n        new Runnable() {\n          public void run() {\n            nextButton.doClick();\n          }\n        });\n    // Check if buttons are enabled and if printable component displays the second page\n    assertTrue(\"Previous button is enabled\", previousButton.isEnabled());\n    assertFalse(\"Next button is disabled\", nextButton.isEnabled());\n    assertEquals(\n        \"Printable component doesn't display second page\", 1, printableComponent.getPage());\n\n    // Click on Ok in dialog box\n    final JOptionPane printPreviewOptionPane =\n        (JOptionPane) TestUtilities.findComponent(printPreviewDialog, JOptionPane.class);\n    tester.invokeAndWait(\n        new Runnable() {\n          public void run() {\n            // Select Ok option to hide dialog box in Event Dispatch Thread\n            printPreviewOptionPane.setValue(JOptionPane.OK_OPTION);\n          }\n        });\n    assertFalse(\"Print preview dialog still showing\", printPreviewDialog.isShowing());\n\n    // 7. Check PDF creation\n    File tmpDirectory = File.createTempFile(\"print\", \"dir\");\n    tmpDirectory.delete();\n    assertTrue(\"Couldn't create tmp directory\", tmpDirectory.mkdir());\n    String pdfFileBase = \"test\";\n    // Show print to PDF dialog box\n    tester.invokeLater(\n        new Runnable() {\n          public void run() {\n            // Display dialog box later in Event Dispatch Thread to avoid blocking test thread\n            runAction(controller, HomePane.ActionType.PRINT_TO_PDF);\n          }\n        });\n    // Wait for print to PDF file chooser to be shown\n    tester.waitForFrameShowing(\n        new AWTHierarchy(),\n        preferences.getLocalizedString(HomePane.class, \"printToPDFDialog.title\"));\n    // Check dialog box is displayed\n    final Dialog printToPdfDialog =\n        (Dialog) new BasicFinder().find(frame, new ClassMatcher(Dialog.class, true));\n    assertTrue(\"Print to pdf dialog not showing\", printToPdfDialog.isShowing());\n    // Change file in print to PDF file chooser\n    final JFileChooserTester fileChooserTester = new JFileChooserTester();\n    final JFileChooser fileChooser =\n        (JFileChooser)\n            new BasicFinder().find(printToPdfDialog, new ClassMatcher(JFileChooser.class));\n    fileChooserTester.actionSetDirectory(fileChooser, tmpDirectory.getAbsolutePath());\n    fileChooserTester.actionSetFilename(fileChooser, pdfFileBase);\n    // Select Ok option to hide dialog box\n    fileChooserTester.actionApprove(fileChooser);\n    assertFalse(\"Print to pdf dialog still showing\", printToPdfDialog.isShowing());\n    // Wait PDF generation\n    File pdfFile = new File(tmpDirectory, pdfFileBase + \".pdf\");\n    Thread.sleep(2000);\n    assertTrue(\"PDF file \" + pdfFile + \" doesn't exist\", pdfFile.exists());\n    assertTrue(\"PDF file is empty\", pdfFile.length() > 0);\n    pdfFile.delete();\n    tmpDirectory.delete();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2027, "initialization": ["File file = getTempFileAt(*,String)", "File file = File.getAbsoluteFile()"], "initializationStart": [473, 623], "initializationEnd": [527, 648], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.getAbsoluteFile()"], "configurationStart": [623], "configurationEnd": [648], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 654, "focalAPIEnd": 669, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.toString()"], "useStart": [909], "useEnd": [927], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aptana/Pydev/tree/master/plugins/org.python.pydev.debug/tests/org/python/pydev/debug/newconsole/PydevConsoleDebugCommsTest.java", "rawCode": "  @Override\n  protected void setUp() throws Exception {\n    String consoleFile =\n        FileUtils.createFileFromParts(\n                TestDependent.TEST_PYDEV_PLUGIN_LOC, \"pysrc\", \"pydevconsole.py\")\n            .getAbsolutePath();\n    String pydevdDir =\n        new File(TestDependent.TEST_PYDEV_DEBUG_PLUGIN_LOC, \"pysrc\").getAbsolutePath();\n    Integer[] ports = SocketUtil.findUnusedLocalPorts(2);\n    int port = ports[0];\n    int clientPort = ports[1];\n\n    homeDir = FileUtils.getTempFileAt(new File(\".\"), \"fake_homedir\");\n    if (homeDir.exists()) {\n      FileUtils.deleteDirectoryTree(homeDir);\n    }\n    homeDir = homeDir.getAbsoluteFile();\n    homeDir.mkdir();\n    String[] cmdarray =\n        new String[] {\n          TestDependent.PYTHON_EXE, consoleFile, String.valueOf(port), String.valueOf(clientPort)\n        };\n\n    Map<String, String> env = new TreeMap<String, String>();\n    env.put(\"HOME\", homeDir.toString());\n    env.put(\"PYTHONPATH\", pydevdDir);\n    String sysRoot = System.getenv(\"SystemRoot\");\n    if (sysRoot != null) {\n      env.put(\n          \"SystemRoot\",\n          sysRoot); // Needed on windows boxes (random/socket. module needs it to work).\n    }\n\n    String[] envp = new String[env.size()];\n    int i = 0;\n    for (Object entry : env.entrySet()) {\n      Map.Entry e = (Entry) entry;\n      Object key = e.getKey();\n      envp[i] = key + \"=\" + e.getValue();\n      i += 1;\n    }\n\n    process = SimpleRunner.createProcess(cmdarray, envp, null);\n    pydevConsoleCommunication = new PydevConsoleCommunication(port, process, clientPort);\n    pydevConsoleCommunication.hello(new NullProgressMonitor());\n\n    ServerSocket socket = new ServerSocket(0);\n    pydevConsoleCommunication.connectToDebugger(socket.getLocalPort());\n    socket.setSoTimeout(5000);\n    Socket accept = socket.accept();\n\n    debugTarget = new DummyDebugTarget();\n    debugTarget.startTransmission(accept);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2028, "initialization": ["File file = createTempFile(String,String,*)"], "initializationStart": [77], "initializationEnd": [168], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.delete()"], "configurationStart": [174], "configurationEnd": [189], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 195, "focalAPIEnd": 209, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.deleteOnExit()"], "useStart": [215], "useEnd": [236], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cityindex/JsTestDriver/tree/master/JsTestDriver/src-test/com/google/jstestdriver/config/PathResolverTest.java", "rawCode": "  @Override\n  protected void setUp() throws Exception {\n    tmpDir =\n        File.createTempFile(\"test\", \"JsTestDriver\", new File(System.getProperty(\"java.io.tmpdir\")));\n    tmpDir.delete();\n    tmpDir.mkdir();\n    tmpDir.deleteOnExit();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2029, "initialization": ["File file = new File(*)"], "initializationStart": [1425], "initializationEnd": [1611], "hasTryCatch": 1, "exceptionType": "ConfigurationException", "exceptionHandlingCall": ["new PhrescoException(*)"], "tryExpressionStart": 135, "tryExpressionEnd": 139, "tryBlockStart": 135, "tryBlockEnd": 3064, "catchExpressionStart": 2876, "catchExpressionEnd": 2909, "catchBlockStart": 2876, "catchBlockEnd": 2953, "exceptionHandlingCallStart": [2923], "exceptionHandlingCallEnd": [2946], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1653, "focalAPIEnd": 1665, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getPath()"], "useStart": [1842], "useEnd": [1856], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/photon-infotech/commons/tree/master/src/main/java/com/photon/phresco/impl/IPhoneApplicationProcessor.java", "rawCode": "  @Override\n  public void postConfiguration(ApplicationInfo appInfo, List<Configuration> configs)\n      throws PhrescoException {\n\n    try {\n      String rootModulePath = \"\";\n      String subModuleName = \"\";\n      if (StringUtils.isNotEmpty(appInfo.getRootModule())) {\n        rootModulePath = Utility.getProjectHome() + appInfo.getRootModule();\n        subModuleName = appInfo.getAppDirName();\n      } else {\n        rootModulePath = Utility.getProjectHome() + appInfo.getAppDirName();\n      }\n      File phrescoPomFile = Utility.getPomFileLocation(rootModulePath, subModuleName);\n      ProjectInfo projectInfo = Utility.getProjectInfo(rootModulePath, subModuleName);\n      File sourceFolderLocation =\n          Utility.getSourceFolderLocation(projectInfo, rootModulePath, subModuleName);\n      String dotPhrescoFolderPath = Utility.getDotPhrescoFolderPath(rootModulePath, subModuleName);\n      File ConfigFilePath =\n          new File(dotPhrescoFolderPath + File.separator + Constants.CONFIGURATION_INFO_FILE);\n      ConfigManager configManager = new ConfigManagerImpl(ConfigFilePath);\n      List<Environment> environments = configManager.getEnvironments();\n      for (Environment environment : environments) {\n        String environmenName = \"\";\n        Map<String, List<Properties>> values = new HashMap<String, List<Properties>>();\n        String environmentName = environment.getName();\n        File file =\n            new File(\n                sourceFolderLocation\n                    + getThirdPartyModuleFolder(phrescoPomFile)\n                    + File.separator\n                    + environmentName);\n        if (!file.exists()) {\n          file.mkdir();\n        }\n        List<Configuration> configurations = environment.getConfigurations();\n        if (CollectionUtils.isNotEmpty(configurations)) {\n          String plistFile = file.getPath() + File.separator + ENVIRONMENT_PLIST;\n          XMLPropertyListConfiguration plist = new XMLPropertyListConfiguration();\n          for (Configuration configuration : configurations) {\n            if (configuration != null) {\n              String configType = configuration.getType();\n              environmenName = environment.getName();\n              Properties properties = configuration.getProperties();\n              properties.setProperty(NAME, configuration.getName());\n              if (values.containsKey(configType)) {\n                List<Properties> list = values.get(configType);\n                list.add(properties);\n                values.put(configType, list);\n              } else {\n                List<Properties> listProps = new ArrayList<Properties>();\n                listProps.add(properties);\n                values.put(configType, listProps);\n              }\n            }\n          }\n          plist.addProperty(environmenName, values);\n          plist.save(plistFile);\n        }\n      }\n    } catch (ConfigurationException e) {\n      throw new PhrescoException(e);\n    } catch (org.apache.commons.configuration.ConfigurationException e) {\n      throw new PhrescoException(e);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2030, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 184, "focalAPIEnd": 196, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,*)", "new FileOutputStream(file)", "file.setExecutable(boolean,boolean)", "file.setWritable(boolean)"], "useStart": [439, 705, 1049, 1100], "useEnd": [459, 731, 1092, 1132], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/photon-infotech/plugins/tree/master/xcode-maven-plugin/src/main/java/com/photon/phresco/plugins/xcode/XcodeUtil.java", "rawCode": "  public static void copyFolder(File src, File dest) throws IOException {\n\n    if (src.isDirectory()) {\n      // if directory not exists, create it\n      if (!dest.exists()) {\n        dest.mkdir();\n      }\n\n      // list all the directory contents\n      String files[] = src.list();\n\n      for (String file : files) {\n        // construct the src and dest file structure\n        File srcFile = new File(src, file);\n        File destFile = new File(dest, file);\n        // recursive copy\n        copyFolder(srcFile, destFile);\n      }\n\n    } else {\n      // if file, then copy it\n      // Use bytes stream to support all file types\n      InputStream in = new FileInputStream(src);\n      OutputStream out = new FileOutputStream(dest);\n\n      byte[] buffer = new byte[1024];\n\n      int length;\n      // copy the file content in bytes\n      while ((length = in.read(buffer)) > 0) {\n        out.write(buffer, 0, length);\n      }\n      // copy metadata information. otherwise the copied output is not executable by ios simulator\n      // or device.\n      dest.setExecutable(src.canExecute(), false);\n      dest.setWritable(src.canWrite());\n\n      in.close();\n      out.close();\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2031, "initialization": ["File file = new File(String)"], "initializationStart": [323], "initializationEnd": [348], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 381, "focalAPIEnd": 392, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,*)"], "useStart": [423], "useEnd": [463], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JCERTIFLab/jcertif-backend-2012/tree/master/jcertif-services/src/main/java/com/jcertif/service/impl/participant/ParticipantServiceImpl.java", "rawCode": "  /**\n   * @param fileStream\n   * @param idParticipant\n   * @param codeRole\n   * @param ext\n   * @throws FileNotFoundException\n   * @throws IOException\n   */\n  @Override\n  public void saveInFile(\n      final InputStream fileStream, Long idParticipant, String codeRole, String ext)\n      throws IOException {\n    File dir = new File(\"./\" + codeRole);\n    if (!dir.exists()) {\n      dir.mkdir();\n    }\n\n    File outputFile = new File(dir, idParticipant + \".\" + ext);\n\n    OutputStream out;\n\n    out = new FileOutputStream(outputFile);\n\n    byte buf[] = new byte[1024];\n    int len;\n\n    while ((len = fileStream.read(buf)) > 0) {\n      out.write(buf, 0, len);\n    }\n    out.close();\n    fileStream.close();\n\n    LOGGER.info(\"File {} saved for idParticipant={}\", outputFile.getAbsolutePath(), idParticipant);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2032, "initialization": ["File file = new File(File,String)"], "initializationStart": [792], "initializationEnd": [840], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 848, "focalAPIEnd": 872, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["InputStream.close()"], "finallyExpressionStart": 3583, "finallyExpressionEnd": 3591, "finallyBlockStart": 3583, "finallyBlockEnd": 3824, "cleanUpCallStart": [3641], "cleanUpCallEnd": [3651], "url": "https://github.com/lsegal/jml4disco/tree/master/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/runtime/LocalVMLauncher.java", "rawCode": "  /**\n   * Initializes this context's target path by copying the jar file for the code snippet support and\n   * by creating the 2 directories that will contain the code snippet classes (see\n   * TARGET_HAS_FILE_SYSTEM). Add the code snipport root class to the boot path directory so that\n   * code snippets can be run in java.* packages\n   *\n   * @throws TargetException if the path could not be initialized with the code snippet support\n   */\n  protected void initTargetPath() throws TargetException {\n    // create directories\n    File directory = new File(this.evalTargetPath);\n    directory.mkdirs();\n    if (!directory.exists()) {\n      throw new TargetException(\"Could not create directory \" + this.evalTargetPath);\n    }\n    if (TARGET_HAS_FILE_SYSTEM) {\n      File classesDirectory = new File(directory, REGULAR_CLASSPATH_DIRECTORY);\n      classesDirectory.mkdir();\n      if (!classesDirectory.exists()) {\n        throw new TargetException(\"Could not create directory \" + classesDirectory.getPath());\n      }\n      File bootDirectory = new File(directory, BOOT_CLASSPATH_DIRECTORY);\n      bootDirectory.mkdir();\n      if (!bootDirectory.exists()) {\n        throw new TargetException(\"Could not create directory \" + bootDirectory.getPath());\n      }\n      /*\n      // add the code snippet root class to the boot path directory\n      InputStream in = null;\n      try {\n      in = EvaluationContext.class.getResourceAsStream(\"/\" + SUPPORT_ZIP_FILE_NAME);\n      ZipInputStream zip = new ZipInputStream(in);\n      String rootClassFileName = ROOT_FULL_CLASS_NAME.replace('.', '/') + \".class\";\n      while (true) {\n      ZipEntry entry = zip.getNextEntry();\n      if (entry.getName().equals(rootClassFileName)) {\n      // read root class file contents\n      int size = (int)entry.getSize();\n      byte[] buffer = new byte[size];\n      int totalRead = 0;\n      int read = 0;\n      while (totalRead < size) {\n      read = zip.read(buffer, totalRead, size - totalRead);\n      if (read != -1) {\n      totalRead += read;\n      }\n      }\n      // write root class file contents\n      FileOutputStream out = null;\n      try {\n      File rootFile = new File(bootDirectory, rootClassFileName.replace('/', File.separatorChar));\n      File parent = new File(rootFile.getParent());\n      parent.mkdirs();\n      out = new FileOutputStream(rootFile);\n      out.write(buffer);\n      out.close();\n      } catch (IOException e) {\n      e.printStackTrace();\n      if (out != null) {\n      try {\n      out.close();\n      } catch (IOException e2) {\n      }\n      }\n      }\n      break;\n      }\n      }\n      in.close();\n      } catch (IOException e) {\n      e.printStackTrace();\n      if (in != null) {\n      try {\n      in.close();\n      } catch (IOException e2) {\n      }\n      }\n      }*/\n    }\n\n    // copy jar file\n    InputStream in = null;\n    FileOutputStream out = null;\n    try {\n      in = this.getClass().getResourceAsStream(\"/\" + SUPPORT_ZIP_FILE_NAME);\n      if (in == null) {\n        throw new TargetException(\"Could not find resource /\" + SUPPORT_ZIP_FILE_NAME);\n      }\n      int bufferLength = 1024;\n      byte[] buffer = new byte[bufferLength];\n      File file = new File(directory, SUPPORT_ZIP_FILE_NAME);\n      out = new FileOutputStream(file);\n      int read = 0;\n      while (read != -1) {\n        read = in.read(buffer, 0, bufferLength);\n        if (read != -1) {\n          out.write(buffer, 0, read);\n        }\n      }\n    } catch (IOException e) {\n      throw new TargetException(\n          \"IOException while copying \" + SUPPORT_ZIP_FILE_NAME + \": \" + e.getMessage());\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (IOException e) {\n        }\n      }\n      if (out != null) {\n        try {\n          out.close();\n        } catch (IOException e) {\n        }\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2033, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 550, "focalAPIEnd": 568, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ekirkilevics/TestSSQL/tree/master/archive/squirrel-sql/plugins/laf/src/net/sourceforge/squirrel_sql/plugins/laf/LAFPlugin.java", "rawCode": "  /**\n   * Load this plugin.\n   *\n   * @param app Application API.\n   */\n  public synchronized void load(IApplication app) throws PluginException {\n    super.load(app);\n\n    // Folder within plugins folder that belongs to this\n    // plugin.\n    File pluginAppFolder = null;\n    try {\n      pluginAppFolder = getPluginAppSettingsFolder();\n    } catch (IOException ex) {\n      throw new PluginException(ex);\n    }\n\n    // Folder that stores Look and Feel jars.\n    _lafFolder = new File(pluginAppFolder, \"lafs\");\n    if (!_lafFolder.exists()) {\n      _lafFolder.mkdir();\n    }\n\n    // Folder to store user settings.\n    try {\n      _userSettingsFolder = getPluginUserSettingsFolder();\n    } catch (IOException ex) {\n      throw new PluginException(ex);\n    }\n\n    // Load plugin preferences.\n    loadPrefs();\n\n    // Create the Look and Feel register.\n    _lafRegister = new LAFRegister(app, this);\n\n    // Update font used for status bars.\n    _lafRegister.updateStatusBarFont();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2034, "initialization": ["File file = new File(String)", "File file = new File(String)"], "initializationStart": [687, 1329], "initializationEnd": [701, 1342], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.getName()"], "configurationStart": [716], "configurationEnd": [727], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1390, "focalAPIEnd": 1399, "followUpCheck": "!var", "checkType": "IF", "followUpCheckExpressionStart": 1409, "followUpCheckExpressionEnd": 1417, "followUpCheckBlockStart": 1409, "followUpCheckBlockEnd": 1447, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fiji/ImageJA/tree/master/src/main/java/ij/plugin/PluginInstaller.java", "rawCode": "  public boolean install(String path) {\n    boolean isURL = path.contains(\"://\");\n    String lcPath = path.toLowerCase();\n    if (isURL) path = Opener.updateUrl(path);\n    boolean isTool =\n        lcPath.endsWith(\"tool.ijm\")\n            || lcPath.endsWith(\"tool.txt\")\n            || lcPath.endsWith(\"tool.class\")\n            || lcPath.endsWith(\"tool.jar\");\n    boolean isMacro = lcPath.endsWith(\".txt\") || lcPath.endsWith(\".ijm\");\n    byte[] data = null;\n    String name = path;\n    if (isURL) {\n      int index = path.lastIndexOf(\"/\");\n      if (index != -1 && index <= path.length() - 1) name = path.substring(index + 1);\n      data = download(path, name);\n    } else {\n      File f = new File(path);\n      name = f.getName();\n      data = download(f);\n    }\n    if (data == null) return false;\n    if (name.endsWith(\".txt\") && !name.contains(\"_\"))\n      name = name.substring(0, name.length() - 4) + \".ijm\";\n    if (name.endsWith(\".zip\")) {\n      if (!name.contains(\"_\")) {\n        IJ.error(\"Plugin Installer\", \"No underscore in file name:\\n \\n \" + name);\n        return false;\n      }\n      name = name.substring(0, name.length() - 4) + \".jar\";\n    }\n    String dir = null;\n    boolean isLibrary = name.endsWith(\".jar\") && !name.contains(\"_\");\n    if (isLibrary) {\n      dir = Menus.getPlugInsPath() + \"jars\";\n      File f = new File(dir);\n      if (!f.exists()) {\n        boolean ok = f.mkdir();\n        if (!ok) dir = Menus.getPlugInsPath();\n      }\n    }\n    if (isTool) {\n      dir = Menus.getPlugInsPath() + \"Tools\" + File.separator;\n      File f = new File(dir);\n      if (!f.exists()) {\n        boolean ok = f.mkdir();\n        if (!ok) dir = null;\n      }\n      if (dir != null && isMacro) {\n        String name2 = getToolName(data);\n        if (name2 != null) name = name2;\n      }\n    }\n    if (dir == null) {\n      SaveDialog sd =\n          new SaveDialog(\"Save Plugin, Macro or Script...\", Menus.getPlugInsPath(), name, null);\n      String name2 = sd.getFileName();\n      if (name2 == null) return false;\n      dir = sd.getDirectory();\n    }\n    // IJ.log(dir+\" \"+Menus.getPlugInsPath());\n    if (!savePlugin(new File(dir, name), data)) return false;\n    if (name.endsWith(\".java\")) IJ.runPlugIn(\"ij.plugin.Compiler\", dir + name);\n    Menus.updateImageJMenus();\n    if (isTool) {\n      if (isMacro) IJ.runPlugIn(\"ij.plugin.Macro_Runner\", \"Tools/\" + name);\n      else if (name.endsWith(\".class\")) {\n        name = name.replaceAll(\"_\", \" \");\n        name = name.substring(0, name.length() - 6);\n        IJ.run(name);\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2035, "initialization": ["File file = new File(*)"], "initializationStart": [112], "initializationEnd": [172], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 210, "focalAPIEnd": 226, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zendtech/zendserver-sdk-java/tree/master/zendserver-sdk-java/org.zend.sdk/sdklib/org/zend/sdklib/internal/monitor/ZendIssue.java", "rawCode": "  private File getTempFolder() {\n    String tempDir = System.getProperty(\"java.io.tmpdir\");\n    File tempFile = new File(tempDir + File.separator + new Random().nextLong());\n    if (!tempFile.exists()) {\n      tempFile.mkdir();\n    }\n    return tempFile;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2036, "initialization": ["File file = new File(String)"], "initializationStart": [68], "initializationEnd": [88], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 94, "focalAPIEnd": 108, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["createTempFile(String,String,file)"], "useStart": [127], "useEnd": [171], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ops4j/org.ops4j.pax.url/tree/master/pax-url-aether/src/test/java/org/ops4j/pax/url/mvn/s3mock/Util.java", "rawCode": "  static File getTestRepo() throws IOException {\n\n    File folder = new File(\"./target\");\n    folder.mkdir();\n\n    File file = File.createTempFile(\"test\", \".repo\", folder);\n    file.delete();\n    file.mkdirs();\n\n    LOG.info(\"test repo : \" + file.getAbsolutePath());\n\n    return file;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2037, "initialization": ["File file = new File(String)"], "initializationStart": [320], "initializationEnd": [355], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 361, "focalAPIEnd": 378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.deleteOnExit()"], "useStart": [2467], "useEnd": [2491], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wtsi-npg/illumina2bam/tree/master/test/uk/ac/sanger/npg/picard/AlignmentFilterTest.java", "rawCode": "  /** Test of instanceMain method and program record to separate unmapped reads into one file. */\n  @Test\n  public void testMainUnMappedFile() throws FileNotFoundException, IOException {\n\n    System.out.println(\"instanceMain with unmapped file\");\n    String outputName = \"testdata/986_1_unmapped\";\n\n    File outputDir = new File(\"testdata/986_1_unmapped\");\n    outputDir.mkdir();\n\n    String[] args = {\n      \"IN=testdata/bam/986_1.sam\",\n      \"IN=testdata/bam/986_1_human_unmapped_with_ref.sam\",\n      \"OUT=\" + outputName + \"/986_1.bam\",\n      \"OUT=\" + outputName + \"/986_1_human.bam\",\n      \"OUTPUT_UNALIGNED=\" + outputName + \"/986_1_unaligned.bam\",\n      \"CREATE_MD5_FILE=true\",\n      \"TMP_DIR=\" + outputName + \"/\",\n      \"VALIDATION_STRINGENCY=SILENT\"\n    };\n\n    filter.instanceMain(args);\n    assertEquals(\n        filter.getCommandLine(),\n        \"uk.ac.sanger.npg.picard.AlignmentFilter INPUT_ALIGNMENT=[testdata/bam/986_1.sam, testdata/bam/986_1_human_unmapped_with_ref.sam] \"\n            + \"OUTPUT_ALIGNMENT=[\"\n            + outputName\n            + \"/986_1.bam, \"\n            + outputName\n            + \"/986_1_human.bam] OUTPUT_UNALIGNED=\"\n            + outputName\n            + \"/986_1_unaligned.bam \"\n            + \"TMP_DIR=[\"\n            + outputName\n            + \"] VALIDATION_STRINGENCY=SILENT CREATE_MD5_FILE=true VERBOSITY=INFO QUIET=false COMPRESSION_LEVEL=5 MAX_RECORDS_IN_RAM=500000 CREATE_INDEX=false\");\n\n    File filteredBamFile = new File(outputName + \"/986_1.bam\");\n\n    File md5File = new File(outputName + \"/986_1.bam.md5\");\n\n    assertEquals(\n        \"77f2212b089c0d848f7406ffc37faeb2\",\n        CheckMd5.getBamMd5AfterRemovePGVersion(filteredBamFile, \"AlignmentFilter\"));\n\n    File filteredHumanBamFile = new File(outputName + \"/986_1_human.bam\");\n\n    File humanMd5File = new File(outputName + \"/986_1_human.bam.md5\");\n\n    assertEquals(\n        \"d2447853ffacffff1ad9ea4d28511f92\",\n        CheckMd5.getBamMd5AfterRemovePGVersion(filteredHumanBamFile, \"AlignmentFilter\"));\n\n    File unalignedBamFile = new File(outputName + \"/986_1_unaligned.bam\");\n\n    File unalignedMd5File = new File(outputName + \"/986_1_unaligned.bam.md5\");\n\n    File metricsFile = new File(outputName + \"/986_1_unaligned.bam_alignment_filter_metrics.json\");\n\n    metricsFile.delete();\n    filteredBamFile.delete();\n    md5File.delete();\n    filteredHumanBamFile.delete();\n    humanMd5File.delete();\n    unalignedBamFile.delete();\n    unalignedMd5File.delete();\n    outputDir.deleteOnExit();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2038, "initialization": ["File file = new File(*,String)"], "initializationStart": [156], "initializationEnd": [191], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 222, "focalAPIEnd": 231, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Equinox-/Equinox-MMORPG-Maker/tree/master/Server/src/com/pi/server/database/Paths.java", "rawCode": "  /**\n   * Gets the directory the log files are created in.\n   *\n   * @return the log directory\n   */\n  public static File getLogDirectory() {\n    File f = new File(getHomeDirectory(), \"log\");\n    if (!f.exists()) {\n      f.mkdir();\n    }\n    return f;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2039, "initialization": ["File file = new File(String)"], "initializationStart": [898], "initializationEnd": [969], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1068, "focalAPIEnd": 1081, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mturley/luper/tree/master/luper-android/src/com/teamluper/luper/LuperMainActivity.java", "rawCode": "  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\n    final ActionBar bar = getSupportActionBar();\n    bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS); // Gives us Tabs!\n    bar.setDisplayShowTitleEnabled(false);\n    bar.setDisplayHomeAsUpEnabled(false);\n\n    // set up the ViewPager, which we will use in conjunction with tabs.\n    // this makes it possible to swipe left and right between the tabs.\n    mViewPager = new ViewPager(this);\n    mViewPager.setId(R.id.tabcontentpager);\n    setContentView(mViewPager);\n\n    dataSource = new SQLiteDataSource(this);\n    dataSource.open();\n\n    // FIXME this is slowing down the app launch dramatically. Perhaps do it in background?\n    // Creates a folder for Luper and associated clips and projects\n    File nfile = new File(Environment.getExternalStorageDirectory() + \"/LuperApp/Clips\");\n    File mfile = new File(Environment.getExternalStorageDirectory() + \"/LuperApp/Projects\");\n    nfile.mkdir();\n    mfile.mkdir();\n\n    // now we set up the TabsAdapter, which is a special class borrowed from Google.\n    // TabsAdapter.java takes care of all the guts of the Tab interactions, and\n    // links it with our ViewPager for us. The code below is all we need to\n    // add some fragment content as tabs in the ActionBar!\n    mTabsAdapter = new TabsAdapter(this, mViewPager);\n    mTabsAdapter.addTab(bar.newTab().setText(\"\" + \"Home\"), TabHomeFragment_.class, null);\n    mTabsAdapter.addTab(bar.newTab().setText(\"\" + \"Projects\"), TabProjectsFragment_.class, null);\n    mTabsAdapter.addTab(bar.newTab().setText(\"\" + \"Friends\"), TabFriendsFragment_.class, null);\n\n    // create a directory to save in\n    File testdir =\n        new File(Environment.getExternalStorageDirectory().getAbsolutePath() + \"/LuperApp/\");\n    testdir.mkdirs();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2040, "initialization": ["File file = new File(*,String)"], "initializationStart": [90], "initializationEnd": [144], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 161, "focalAPIEnd": 174, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(var)", "file.getAbsolutePath()", "file.delete()"], "useStart": [150, 281, 654], "useEnd": [175, 304, 668], "hasFinally": 1, "cleanUpCall": ["File.delete()", "assertTrue(*)"], "finallyExpressionStart": 627, "finallyExpressionEnd": 635, "finallyBlockStart": 627, "finallyBlockEnd": 676, "cleanUpCallStart": [654, 643], "cleanUpCallEnd": [668, 669], "url": "https://github.com/MIPS/cts/tree/master/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java", "rawCode": "  public void testCreateDirectoryHasSanePermissions() throws Exception {\n    File myDir = new File(getContext().getFilesDir(), \"helloDirectory\");\n    assertTrue(myDir.mkdir());\n    try {\n      FileUtils.FileStatus status = new FileUtils.FileStatus();\n      FileUtils.getFileStatus(myDir.getAbsolutePath(), status, false);\n      int expectedPerms =\n          FileUtils.S_IFDIR | FileUtils.S_IWUSR | FileUtils.S_IRUSR | FileUtils.S_IXUSR;\n      assertEquals(\n          \"Newly created directories should have 0700 permissions\",\n          Integer.toOctalString(expectedPerms),\n          Integer.toOctalString(status.mode));\n\n    } finally {\n      assertTrue(myDir.delete());\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2041, "initialization": ["File file = new File(File,String)"], "initializationStart": [588], "initializationEnd": [614], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 620, "focalAPIEnd": 634, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [658], "useEnd": [688], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/skaegi/orion.server/tree/master/tests/org.eclipse.orion.server.tests/src/org/eclipse/orion/server/tests/servlets/git/GitTest.java", "rawCode": "  protected void createRepository() throws IOException, GitAPIException, CoreException {\n    IPath randomLocation = AllGitTests.getRandomLocation();\n    gitDir = randomLocation.toFile();\n    randomLocation = randomLocation.addTrailingSeparator().append(Constants.DOT_GIT);\n    File dotGitDir = randomLocation.toFile().getCanonicalFile();\n    db = new FileRepository(dotGitDir);\n    assertFalse(dotGitDir.exists());\n    db.create(false /* non bare */);\n\n    testFile = new File(gitDir, \"test.txt\");\n    testFile.createNewFile();\n    createFile(testFile.toURI(), \"test\");\n    File folder = new File(gitDir, \"folder\");\n    folder.mkdir();\n    File folderFile = new File(folder, \"folder.txt\");\n    folderFile.createNewFile();\n    createFile(folderFile.toURI(), \"folder\");\n\n    Git git = new Git(db);\n    git.add().addFilepattern(\".\").call();\n    git.commit().setMessage(\"Initial commit\").call();\n\n    // The system settings on eclipse.org was changed to receive.denyNonFastForward=true, see bug\n    // 343150.\n    // Imitate the same setup when running tests locally, see bug 371881.\n    FileBasedConfig cfg = db.getConfig();\n    cfg.setBoolean(\"receive\", null, \"denyNonFastforwards\", true);\n    cfg.save();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2042, "initialization": ["File file = new File(File,String)"], "initializationStart": [289], "initializationEnd": [312], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 322, "focalAPIEnd": 333, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["unzip(*,file)"], "useStart": [343], "useEnd": [356], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chenopodium/IGV/tree/master/src/org/broad/igv/util/UnzipGenomes.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    File root = new File(\"/Users/jrobinso/projects/genomes\");\n\n    for (File f : root.listFiles()) {\n\n      if (f.getName().endsWith(\".genome\")) {\n        String dirName = f.getName().replace(\".genome\", \"\");\n        File dir = new File(root, dirName);\n        dir.mkdir();\n        unzip(f, dir);\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2043, "initialization": ["File file = new File(*)"], "initializationStart": [65], "initializationEnd": [137], "hasTryCatch": 1, "exceptionType": "SecurityException", "exceptionHandlingCall": ["e(*,String,*)"], "tryExpressionStart": 183, "tryExpressionEnd": 187, "tryBlockStart": 183, "tryBlockEnd": 330, "catchExpressionStart": 226, "catchExpressionEnd": 254, "catchBlockStart": 226, "catchBlockEnd": 330, "exceptionHandlingCallStart": [264], "exceptionHandlingCallEnd": [299], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 197, "focalAPIEnd": 216, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/damonkohler/sl4a/tree/master/android/JRubyForAndroid/src/com/googlecode/jrubyforandroid/JRubyInstaller.java", "rawCode": "  @Override\n  protected boolean setup() {\n    File dalvikCache = new File(mInterpreterRoot + InterpreterConstants.SL4A_DALVIK_CACHE_ROOT);\n    if (!dalvikCache.isDirectory()) {\n      try {\n        dalvikCache.mkdir();\n      } catch (SecurityException e) {\n        Log.e(mContext, \"Setup failed.\", e);\n        return false;\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2044, "initialization": ["File file = new File(*)"], "initializationStart": [724], "initializationEnd": [749], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getMainFrame()", "showMessageDialog(*,String,String,*)"], "tryExpressionStart": 755, "tryExpressionEnd": 759, "tryBlockStart": 755, "tryBlockEnd": 1372, "catchExpressionStart": 1203, "catchExpressionEnd": 1227, "catchBlockStart": 1203, "catchBlockEnd": 1372, "exceptionHandlingCallStart": [1276, 1235], "exceptionHandlingCallEnd": [1300, 1365], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 815, "focalAPIEnd": 836, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getPath()", "copyStructures(file)"], "useStart": [910, 1127], "useEnd": [933, 1187], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/soartech/soar/tree/master/Deprecated/SoarPre8.6/visualsoar/Source/edu/umich/visualsoar/operatorwindow/OperatorRootNode.java", "rawCode": "  public void renameAndBackup(OperatorWindow operatorWindow, String newName, String newPath) {\n\n    String oldFullPathStart = fullPathStart;\n    String oldFolder = folderName;\n\n    if (new File(newPath + File.separator + newName + \".vsa\").exists()) {\n      JOptionPane.showMessageDialog(\n          MainFrame.getMainFrame(),\n          \"An agent with this name already exists at this location.\",\n          \"Naming Error\",\n          JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n    /*\n    if(name.equals(newName)) {\n    JOptionPane.showMessageDialog(MainFrame.getMainFrame(),\"The new name must be different from the current name.\",\"Naming Error\",JOptionPane.ERROR_MESSAGE);\n    return;\n    }\n    */\n    File oldFolderName = new File(getFolderName());\n    try {\n      rename(operatorWindow, newName, newPath);\n      oldFolderName.mkdir();\n\n      FileWriter graphWriter =\n          new FileWriter(\n              oldFolderName.getPath() + File.separator + oldFolderName.getName() + \".dm\");\n      operatorWindow.getDatamap().write(graphWriter);\n      graphWriter.close();\n\n      for (int i = 0; i < getChildCount(); ++i) {\n        ((OperatorNode) getChildAt(i)).copyStructures(oldFolderName);\n      }\n    } catch (IOException ioe) {\n      JOptionPane.showMessageDialog(\n          MainFrame.getMainFrame(), \"Save As Failed!\", \"Save As Failed\", JOptionPane.ERROR_MESSAGE);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2045, "initialization": ["File file = new File(String)"], "initializationStart": [877], "initializationEnd": [922], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 972, "focalAPIEnd": 987, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getAbsolutePath()", "file.mkdir()", "file.getAbsolutePath()"], "useStart": [1155, 1925, 2144], "useEnd": [1180, 1940, 2169], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/molgenis_apps-legacy/tree/master/modules/xgap/plugins/archiveexportimport/XgapMatrixExport.java", "rawCode": "  public static void exportMatrix(\n      List<Data> dataList, String investigationName, Database db, File directory)\n      throws IllegalArgumentException, DatabaseException, IOException, Exception {\n\n    DataMatrixHandler dmh = new DataMatrixHandler(db);\n\n    // Data matrices\n    if (dataList.size() > 0) {\n      // null indicates all investigations, but only do this if there are\n      // actually more than 1 investigation in the db\n      if (investigationName == null && db.find(Investigation.class).size() > 1) {\n        for (Data data : dataList) {\n          // Investigation inv = db.find(Investigation.class, new\n          // QueryRule(\"id\", Operator.EQUALS,\n          // data.getInvestigation())).get(0);\n\n          // File dataDir = new File(directory + File.separator +\n          // NameConvention.escapeFileName(inv.getName())+ \"_data\");\n\n          File dataDir = new File(directory + File.separator + \"data\");\n\n          if (!dataDir.exists()) {\n            dataDir.mkdir();\n          }\n\n          DataMatrixInstance instance = dmh.createInstance(data, db);\n          File matrixFile = instance.getAsFile();\n          File newLoc = new File(dataDir.getAbsolutePath() + File.separator + matrixFile.getName());\n          // boolean createDestSuccess = newLoc.createNewFile();\n          // if(!createDestSuccess){\n          // throw new Exception(\"Creation if destination file \" +\n          // newLoc.getAbsolutePath() + \" failed.\");\n          // }\n          TarGz.fileCopy(matrixFile, newLoc, false);\n\n          // File f = new File(dataDir.getAbsolutePath() +\n          // File.separator + data.getName() + \".txt\");\n          // PrintWriter out = new PrintWriter(new\n          // FileOutputStream(f));\n          // MatrixViewPlugin.downloadAll(db, data, BATCH_SIZE, out);\n\n        }\n      } else {\n        File dataDir = new File(directory + File.separator + \"data\");\n\n        if (!dataDir.exists()) {\n          dataDir.mkdir();\n        }\n\n        for (Data data : dataList) {\n\n          DataMatrixInstance instance = dmh.createInstance(data, db);\n          File matrixFile = instance.getAsFile();\n          File newLoc = new File(dataDir.getAbsolutePath() + File.separator + matrixFile.getName());\n          TarGz.fileCopy(matrixFile, newLoc, false);\n\n          // File f = new File(dataDir + File.separator +\n          // data.getName() + \".txt\");\n          // PrintWriter out = new PrintWriter(new\n          // FileOutputStream(f));\n          // MatrixViewPlugin.downloadAll(db, data, BATCH_SIZE, out);\n\n        }\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2046, "initialization": ["File file = new File(String)"], "initializationStart": [1100], "initializationEnd": [1118], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1155, "focalAPIEnd": 1166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.createNewFile()", "new Scanner(file)"], "useStart": [1241, 1485], "useEnd": [1260, 1501], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NSolberg/Project-Galvatron/tree/master/src/bteam/capstone/server/RiskServer.java", "rawCode": "  private String list(String Options, String ClientID) {\n    boolean saved = false;\n    boolean byUser = false;\n    String user = \"\";\n    Scanner scan = new Scanner(Options);\n    while (scan.hasNext()) {\n      String temp = scan.next();\n      if (temp.equals(\"s\")) {\n        saved = true;\n      } else if (temp.equals(\"u\") && scan.hasNext()) {\n        byUser = true;\n        user = scan.next();\n      }\n    }\n    String out = \"\";\n    if (!saved) {\n      // \"GameID WorldName Creator Legacy Password\"\n      out = \"<list>\";\n      for (RiskCore core : Instances) {\n        if (!byUser || byUser && core.getWorldCreator().equals(user)) {\n          out +=\n              \"\\n\"\n                  + core.getWorldID()\n                  + \" \"\n                  + core.getGameFile()\n                  + \" \"\n                  + core.getWorldCreator()\n                  + \" \"\n                  + core.isLegacy()\n                  + \" \"\n                  + core.hasPassword()\n                  + \" \"\n                  + core.getWorldName();\n        }\n      }\n      out += \"\\n</list>\";\n    } else {\n      File dir = new File(ClientID);\n      if (!dir.exists()) {\n        dir.mkdir();\n        dir = new File(ClientID + \"/games.txt\");\n        try {\n          dir.createNewFile();\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      } else {\n        dir = new File(ClientID + \"/games.txt\");\n      }\n      out = \"WorldName Creator Legacy Password\";\n      try {\n        scan = new Scanner(dir);\n        while (scan.hasNext()) {\n          String temp = scan.nextLine();\n          out += \"\\n\" + temp;\n        }\n      } catch (FileNotFoundException e) {\n        e.printStackTrace();\n      }\n    }\n    return out;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2047, "initialization": ["File file = new File(*)"], "initializationStart": [422], "initializationEnd": [463], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 471, "focalAPIEnd": 490, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/avionik/AirSwimmer/tree/master/TeamIR_Sender/AirSwimmer/src/de/airswimmer/gui/MovementFunc.java", "rawCode": "  /**\n   * parses the lirc file\n   *\n   * @param filepath\n   * @return true if lirc file parsed successfully else return false\n   */\n  public String importLircfile() {\n    String newFolder = \"/AirSwimmer\";\n    String extStorageDirectory = Environment.getExternalStorageDirectory().toString();\n\n    File dir = new File(extStorageDirectory + newFolder + \"/Lirc.txt\");\n    if (!dir.isDirectory()) {\n\n      File myNewFolder = new File(extStorageDirectory + newFolder);\n      myNewFolder.mkdir();\n      File f = new File(extStorageDirectory + newFolder + \"/Lirc.txt\");\n      try {\n        final InputStream is = getResources().getAssets().open(nameOfLirc);\n        BufferedReader br = null;\n        try {\n          br = new BufferedReader(new InputStreamReader(is));\n          StringBuilder sb = new StringBuilder();\n          String line;\n          while ((line = br.readLine()) != null) {\n            sb.append(line + '\\n');\n          }\n          FileWriter fwriter = new FileWriter(f);\n          BufferedWriter bwriter = new BufferedWriter(fwriter);\n          bwriter.write(sb.toString());\n          bwriter.close();\n        } catch (IOException e) {\n          Toast.makeText(getApplicationContext(), \"Failed to parse Lirc-File\", Toast.LENGTH_SHORT)\n              .show();\n          System.err.println(\"IOException when parsing and writing file: \" + e);\n        } finally {\n\n          if (is != null) {\n            try {\n              is.close();\n            } catch (IOException e) {\n              System.err.println(\"IOException when closing input stream: \" + e);\n              Toast.makeText(\n                      getApplicationContext(), \"Failed to parse Lirc-File\", Toast.LENGTH_SHORT)\n                  .show();\n            }\n          }\n          if (br != null) {\n            try {\n              br.close();\n            } catch (IOException e) {\n              System.err.println(\"IOException when closing buffered reader: \" + e);\n              Toast.makeText(\n                      getApplicationContext(), \"Failed to parse Lirc-File\", Toast.LENGTH_SHORT)\n                  .show();\n            }\n          }\n        }\n\n      } catch (IOException e) {\n        System.err.println(\"Lirc File could not be opened!\");\n        e.printStackTrace();\n        Toast.makeText(getApplicationContext(), \"Failed to parse Lirc-File\", Toast.LENGTH_SHORT)\n            .show();\n      }\n    }\n    return dir.getAbsolutePath();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2048, "initialization": ["File file = new File(String)"], "initializationStart": [56], "initializationEnd": [70], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 76, "focalAPIEnd": 88, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jalian-systems/Marathon/tree/master/marathon-unit-tests/test/net/sourceforge/marathon/action/TestAssertText.java", "rawCode": "  private File createDir(String name) {\n    File file = new File(name);\n    file.mkdir();\n    return file;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2049, "initialization": ["File file = new File(File,String)"], "initializationStart": [149], "initializationEnd": [198], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 241, "focalAPIEnd": 258, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/QADM/SCG/tree/master/opentaps-1.5/applications/content/src/org/ofbiz/content/data/DataResourceWorker.java", "rawCode": "  private static File makeNewDirectory(File parent) {\n    File latestDir = null;\n    boolean newDir = false;\n    while (!newDir) {\n      latestDir = new File(parent, \"\" + System.currentTimeMillis());\n      if (!latestDir.exists()) {\n        latestDir.mkdir();\n        newDir = true;\n      }\n    }\n    return latestDir;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2050, "initialization": ["File file = new File(*)"], "initializationStart": [2237], "initializationEnd": [2382], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 2388, "focalAPIEnd": 2403, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SITools2/core-v2/tree/master/workspace/fr.cnes.sitools.extensions/src/fr/cnes/sitools/resources/order/cart/common/AbstractCartOrderResource.java", "rawCode": "  @Override\n  public void doInitialiseOrder() throws SitoolsException {\n\n    String cartFileUrl = getRequest().getResourceRef().getQueryAsForm().getFirstValue(\"cartFile\");\n    if (cartFileUrl == null || cartFileUrl.isEmpty()) {\n      throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST, \"Missing cartFile parameter\");\n    }\n\n    clientInfo = this.getRequest().getClientInfo();\n\n    cartFileReference = new Reference(RIAPUtils.getRiapBase() + cartFileUrl);\n    Representation repr = OrderResourceUtils.getFile(cartFileReference, clientInfo, getContext());\n\n    cartSelections = getObject(repr, new Variant(MediaType.APPLICATION_JSON));\n\n    if (cartSelections == null) {\n      throw new ResourceException(\n          Status.CLIENT_ERROR_BAD_REQUEST, \"Cannot find cartSelections file\");\n    }\n    getContext().getAttributes().put(TaskUtils.PARENT_APPLICATION, getApplication());\n\n    // control if the dataset is activated\n    for (CartSelection sel : cartSelections.getSelections()) {\n      // String dsReq = sel.getDataUrl();\n      String dsReq = \"/datasets\";\n\n      Response resp =\n          RIAPUtils.handleParseResponse(\n              dsReq, Method.GET, MediaType.APPLICATION_JAVA_OBJECT, getContext());\n      for (Object obj : resp.getData()) {\n        DataSet dataset = (DataSet) obj;\n        if (dataset.getId().equals(sel.getDatasetId())) {\n          if (!dataset.getStatus().equals(\"ACTIVE\"))\n            throw new ResourceException(\n                Status.CLIENT_ERROR_BAD_REQUEST,\n                \"Dataset [\" + sel.getDatasetName() + \"] is inactive\");\n        }\n      }\n    }\n\n    super.doInitialiseOrder();\n\n    String folderName = \"/resources_orders/\" + getOrderName();\n\n    // use no user to get a directory in the temporary folder\n    userStorageRef = OrderResourceUtils.getUserAvailableFolderPath(null, folderName, getContext());\n    userStorageUrl = OrderResourceUtils.getUserAvailableFolderUrl(null, folderName, getContext());\n\n    // use a temporary folder to manage concurrent access\n    String date = DateUtils.format(new Date(), TaskUtils.getTimestampPattern());\n    tempDateStorageUrl = userStorageUrl + \"/\" + date;\n    tempDateStorageRef = new Reference(userStorageRef + \"/\" + date);\n\n    tempdir =\n        new File(\n            settings.getString(\"Starter.ROOT_DIRECTORY\")\n                + settings.getStoreDIR()\n                + tempDateStorageUrl);\n    tempdir.mkdir();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2051, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 160, "focalAPIEnd": 174, "followUpCheck": "var", "checkType": "IF", "followUpCheckExpressionStart": 181, "followUpCheckExpressionEnd": 249, "followUpCheckBlockStart": 181, "followUpCheckBlockEnd": 517, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mmalina/jbosstools-integration-tests-non-soa/tree/master/tests/org.jboss.tools.openshift.ui.bot.test/src/org/jboss/tools/openshift/ui/bot/test/app/ImportApp.java", "rawCode": "  @Before\n  public void cleanUpProject() {\n    File gitDir = new File(System.getProperty(\"user.home\") + \"/git\");\n\n    boolean exists = gitDir.exists() ? true : gitDir.mkdir();\n\n    if (exists && gitDir.isDirectory() && gitDir.listFiles().length > 0) {\n      for (File file : gitDir.listFiles()) {\n        if (file.getName().contains(TestProperties.get(\"openshift.jbossapp.name\")))\n          try {\n            delete(file);\n          } catch (IOException e) {\n            e.printStackTrace();\n          }\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2052, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 279, "focalAPIEnd": 308, "followUpCheck": "var", "checkType": "IF", "followUpCheckExpressionStart": 316, "followUpCheckExpressionEnd": 328, "followUpCheckBlockStart": 316, "followUpCheckBlockEnd": 406, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/molgenis_apps-legacy/tree/master/apps/bbmri/plugins/LuceneIndex/AdminIndexes.java", "rawCode": "  public boolean DirectoryhasContents(String directory) {\n    File dir = new File(directory);\n    boolean exists = dir.exists();\n\n    if (exists == false) {\n      System.out.println(\"The directory \" + directory + \"does not exists. Creating directory. \");\n      boolean success = (new File(directory)).mkdir();\n      if (success) {\n        System.out.println(\"Directory: \" + directory + \" created\");\n      }\n    }\n\n    boolean isEmpty = false;\n\n    System.out.println(\"checking \" + dir.getAbsolutePath());\n    System.out.println(\"isEmpty: \" + isEmpty);\n    if (dir.exists() && dir.isDirectory()) {\n      if (dir.list().length == 0) {\n        this.setStatus(\"<h4> The directory is empty</h4> \");\n        System.out.println(\"The directory is empty.\");\n        return true;\n      } else {\n        // File[] files = dir.listFiles();\n        this.setStatus(\"<h4> The directory is NOT empty or does not exists .</h4> \");\n        System.out.println(\"The directory is NOT empty or does not exists .\");\n      }\n    } else {\n      return false;\n    }\n    return false;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2053, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.delete()"], "configurationStart": [229], "configurationEnd": [244], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 257, "focalAPIEnd": 271, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["FileUtils.deleteDirectoryQuietly(File)"], "finallyExpressionStart": 392, "finallyExpressionEnd": 400, "finallyBlockStart": 392, "finallyBlockEnd": 455, "cleanUpCallStart": [408], "cleanUpCallEnd": [448], "url": "https://github.com/jmchilton/TINT/tree/master/projects/TropixCommons/src/test/edu/umn/msi/tropix/common/test/FileUtilsTest.java", "rawCode": "  @Test(groups = \"unit\", expectedExceptions = IORuntimeException.class)\n  public void moveException() {\n    fileUtils.writeStringToFile(file, \"Moo Cow\");\n    final File toFile = fileUtils.createTempFile(\"tpxtst\", \"\");\n    assert toFile.delete();\n    assert toFile.mkdir();\n    try {\n      // Shouldn't be able to copy to result, its a directoory\n      fileUtils.moveFile(file, toFile);\n    } finally {\n      fileUtils.deleteDirectoryQuietly(toFile);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2054, "initialization": ["File file = new File(String)"], "initializationStart": [133], "initializationEnd": [147], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 268, "focalAPIEnd": 280, "followUpCheck": "!var", "checkType": "IF", "followUpCheckExpressionStart": 352, "followUpCheckExpressionEnd": 365, "followUpCheckBlockStart": 352, "followUpCheckBlockEnd": 397, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Praqma/praqmajutils/tree/master/src/main/java/net/praqma/util/debug/PraqmaLogger.java", "rawCode": "  public boolean setPathHomeLogs() {\n    String path = System.getProperty(\"user.home\") + filesep + \"logs\" + filesep;\n    File file = new File(path);\n\n    /* Existence + creation */\n    if (!file.exists()) {\n      boolean created = false;\n      try {\n        created = file.mkdir();\n      } catch (Exception e) {\n        created = false;\n      }\n\n      if (!created) {\n        return false;\n      }\n    }\n\n    PraqmaLogger.path = path;\n\n    newDate(nowDate);\n\n    return true;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2055, "initialization": ["File file = new File(*)", "File file = new File(*,String)"], "initializationStart": [22292, 23179], "initializationEnd": [22306, 23257], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["unexpected(*)"], "tryExpressionStart": 23267, "tryExpressionEnd": 23271, "tryBlockStart": 23267, "tryBlockEnd": 23583, "catchExpressionStart": 23598, "catchExpressionEnd": 23618, "catchBlockStart": 23598, "catchBlockEnd": 23646, "exceptionHandlingCallStart": [23626], "exceptionHandlingCallEnd": [23639], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 23302, "focalAPIEnd": 23313, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ProcessBuilder.directory(file)", "file.delete()"], "useStart": [23436, 23560], "useEnd": [23453, 23572], "hasFinally": 1, "cleanUpCall": ["File.delete()"], "finallyExpressionStart": 23522, "finallyExpressionEnd": 23530, "finallyBlockStart": 23522, "finallyBlockEnd": 23583, "cleanUpCallStart": [23560], "cleanUpCallEnd": [23572], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/lang/ProcessBuilder/Basic.java", "rawCode": "  private static void realMain(String[] args) throws Throwable {\n    if (Windows.is()) System.out.println(\"This appears to be a Windows system.\");\n    if (Unix.is()) System.out.println(\"This appears to be a Unix system.\");\n    if (UnicodeOS.is()) System.out.println(\"This appears to be a Unicode-based OS.\");\n\n    try {\n      testIORedirection();\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Basic tests for setting, replacing and deleting envvars\n    // ----------------------------------------------------------------\n    try {\n      ProcessBuilder pb = new ProcessBuilder();\n      Map<String, String> environ = pb.environment();\n\n      // New env var\n      environ.put(\"QUUX\", \"BAR\");\n      equal(environ.get(\"QUUX\"), \"BAR\");\n      equal(getenvInChild(pb, \"QUUX\"), \"BAR\");\n\n      // Modify env var\n      environ.put(\"QUUX\", \"bear\");\n      equal(environ.get(\"QUUX\"), \"bear\");\n      equal(getenvInChild(pb, \"QUUX\"), \"bear\");\n      checkMapSanity(environ);\n\n      // Remove env var\n      environ.remove(\"QUUX\");\n      equal(environ.get(\"QUUX\"), null);\n      equal(getenvInChild(pb, \"QUUX\"), \"null\");\n      checkMapSanity(environ);\n\n      // Remove non-existent env var\n      environ.remove(\"QUUX\");\n      equal(environ.get(\"QUUX\"), null);\n      equal(getenvInChild(pb, \"QUUX\"), \"null\");\n      checkMapSanity(environ);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Pass Empty environment to child\n    // ----------------------------------------------------------------\n    try {\n      ProcessBuilder pb = new ProcessBuilder();\n      pb.environment().clear();\n      String expected = Windows.is() ? \"SystemRoot=\" + systemRoot + \",\" : \"\";\n      if (Windows.is()) {\n        pb.environment().put(\"SystemRoot\", systemRoot);\n      }\n      equal(getenvInChild(pb), expected);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // System.getenv() is read-only.\n    // ----------------------------------------------------------------\n    THROWS(\n        UnsupportedOperationException.class,\n        new Fun() {\n          void f() {\n            getenv().put(\"FOO\", \"BAR\");\n          }\n        },\n        new Fun() {\n          void f() {\n            getenv().remove(\"PATH\");\n          }\n        },\n        new Fun() {\n          void f() {\n            getenv().keySet().remove(\"PATH\");\n          }\n        },\n        new Fun() {\n          void f() {\n            getenv().values().remove(\"someValue\");\n          }\n        });\n\n    try {\n      Collection<Map.Entry<String, String>> c = getenv().entrySet();\n      if (!c.isEmpty())\n        try {\n          c.iterator().next().setValue(\"foo\");\n          fail(\"Expected UnsupportedOperationException not thrown\");\n        } catch (UnsupportedOperationException e) {\n        } // OK\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // System.getenv() always returns the same object in our implementation.\n    // ----------------------------------------------------------------\n    try {\n      check(System.getenv() == System.getenv());\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // You can't create an env var name containing \"=\",\n    // or an env var name or value containing NUL.\n    // ----------------------------------------------------------------\n    {\n      final Map<String, String> m = new ProcessBuilder().environment();\n      THROWS(\n          IllegalArgumentException.class,\n          new Fun() {\n            void f() {\n              m.put(\"FOO=\", \"BAR\");\n            }\n          },\n          new Fun() {\n            void f() {\n              m.put(\"FOO\\u0000\", \"BAR\");\n            }\n          },\n          new Fun() {\n            void f() {\n              m.put(\"FOO\", \"BAR\\u0000\");\n            }\n          });\n    }\n\n    // ----------------------------------------------------------------\n    // Commands must never be null.\n    // ----------------------------------------------------------------\n    THROWS(\n        NullPointerException.class,\n        new Fun() {\n          void f() {\n            new ProcessBuilder((List<String>) null);\n          }\n        },\n        new Fun() {\n          void f() {\n            new ProcessBuilder().command((List<String>) null);\n          }\n        });\n\n    // ----------------------------------------------------------------\n    // Put in a command; get the same one back out.\n    // ----------------------------------------------------------------\n    try {\n      List<String> command = new ArrayList<String>();\n      ProcessBuilder pb = new ProcessBuilder(command);\n      check(pb.command() == command);\n      List<String> command2 = new ArrayList<String>(2);\n      command2.add(\"foo\");\n      command2.add(\"bar\");\n      pb.command(command2);\n      check(pb.command() == command2);\n      pb.command(\"foo\", \"bar\");\n      check(pb.command() != command2 && pb.command().equals(command2));\n      pb.command(command2);\n      command2.add(\"baz\");\n      equal(pb.command().get(2), \"baz\");\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Commands must contain at least one element.\n    // ----------------------------------------------------------------\n    THROWS(\n        IndexOutOfBoundsException.class,\n        new Fun() {\n          void f() throws IOException {\n            new ProcessBuilder().start();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            new ProcessBuilder(new ArrayList<String>()).start();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            Runtime.getRuntime().exec(new String[] {});\n          }\n        });\n\n    // ----------------------------------------------------------------\n    // Commands must not contain null elements at start() time.\n    // ----------------------------------------------------------------\n    THROWS(\n        NullPointerException.class,\n        new Fun() {\n          void f() throws IOException {\n            new ProcessBuilder(\"foo\", null, \"bar\").start();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            new ProcessBuilder((String) null).start();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            new ProcessBuilder(new String[] {null}).start();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            new ProcessBuilder(new String[] {\"foo\", null, \"bar\"}).start();\n          }\n        });\n\n    // ----------------------------------------------------------------\n    // Command lists are growable.\n    // ----------------------------------------------------------------\n    try {\n      new ProcessBuilder().command().add(\"foo\");\n      new ProcessBuilder(\"bar\").command().add(\"foo\");\n      new ProcessBuilder(new String[] {\"1\", \"2\"}).command().add(\"3\");\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Nulls in environment updates generate NullPointerException\n    // ----------------------------------------------------------------\n    try {\n      final Map<String, String> env = new ProcessBuilder().environment();\n      THROWS(\n          NullPointerException.class,\n          new Fun() {\n            void f() {\n              env.put(\"foo\", null);\n            }\n          },\n          new Fun() {\n            void f() {\n              env.put(null, \"foo\");\n            }\n          },\n          new Fun() {\n            void f() {\n              env.remove(null);\n            }\n          },\n          new Fun() {\n            void f() {\n              for (Map.Entry<String, String> e : env.entrySet()) e.setValue(null);\n            }\n          },\n          new Fun() {\n            void f() throws IOException {\n              Runtime.getRuntime().exec(new String[] {\"foo\"}, new String[] {null});\n            }\n          });\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Non-String types in environment updates generate ClassCastException\n    // ----------------------------------------------------------------\n    try {\n      final Map<String, String> env = new ProcessBuilder().environment();\n      THROWS(\n          ClassCastException.class,\n          new Fun() {\n            void f() {\n              env.remove(TRUE);\n            }\n          },\n          new Fun() {\n            void f() {\n              env.keySet().remove(TRUE);\n            }\n          },\n          new Fun() {\n            void f() {\n              env.values().remove(TRUE);\n            }\n          },\n          new Fun() {\n            void f() {\n              env.entrySet().remove(TRUE);\n            }\n          });\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Check query operations on environment maps\n    // ----------------------------------------------------------------\n    try {\n      List<Map<String, String>> envs = new ArrayList<Map<String, String>>(2);\n      envs.add(System.getenv());\n      envs.add(new ProcessBuilder().environment());\n      for (final Map<String, String> env : envs) {\n        // ----------------------------------------------------------------\n        // Nulls in environment queries are forbidden.\n        // ----------------------------------------------------------------\n        THROWS(\n            NullPointerException.class,\n            new Fun() {\n              void f() {\n                getenv(null);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.get(null);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.containsKey(null);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.containsValue(null);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.keySet().contains(null);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.values().contains(null);\n              }\n            });\n\n        // ----------------------------------------------------------------\n        // Non-String types in environment queries are forbidden.\n        // ----------------------------------------------------------------\n        THROWS(\n            ClassCastException.class,\n            new Fun() {\n              void f() {\n                env.get(TRUE);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.containsKey(TRUE);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.containsValue(TRUE);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.keySet().contains(TRUE);\n              }\n            },\n            new Fun() {\n              void f() {\n                env.values().contains(TRUE);\n              }\n            });\n\n        // ----------------------------------------------------------------\n        // Illegal String values in environment queries are (grumble) OK\n        // ----------------------------------------------------------------\n        equal(env.get(\"\\u0000\"), null);\n        check(!env.containsKey(\"\\u0000\"));\n        check(!env.containsValue(\"\\u0000\"));\n        check(!env.keySet().contains(\"\\u0000\"));\n        check(!env.values().contains(\"\\u0000\"));\n      }\n\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    try {\n      final Set<Map.Entry<String, String>> entrySet = new ProcessBuilder().environment().entrySet();\n      THROWS(\n          NullPointerException.class,\n          new Fun() {\n            void f() {\n              entrySet.contains(null);\n            }\n          });\n      THROWS(\n          ClassCastException.class,\n          new Fun() {\n            void f() {\n              entrySet.contains(TRUE);\n            }\n          },\n          new Fun() {\n            void f() {\n              entrySet.contains(new SimpleImmutableEntry<Boolean, String>(TRUE, \"\"));\n            }\n          });\n\n      check(!entrySet.contains(new SimpleImmutableEntry<String, String>(\"\", \"\")));\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Put in a directory; get the same one back out.\n    // ----------------------------------------------------------------\n    try {\n      ProcessBuilder pb = new ProcessBuilder();\n      File foo = new File(\"foo\");\n      equal(pb.directory(), null);\n      equal(pb.directory(foo).directory(), foo);\n      equal(pb.directory(null).directory(), null);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // If round-trip conversion works, check envvar pass-through to child\n    // ----------------------------------------------------------------\n    try {\n      testEncoding(\"ASCII\", \"xyzzy\");\n      testEncoding(\"Latin1\", \"\\u00f1\\u00e1\");\n      testEncoding(\"Unicode\", \"\\u22f1\\u11e1\");\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // A surprisingly large number of ways to delete an environment var.\n    // ----------------------------------------------------------------\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            environ.remove(\"Foo\");\n          }\n        });\n\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            environ.keySet().remove(\"Foo\");\n          }\n        });\n\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            environ.values().remove(\"BAAR\");\n          }\n        });\n\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            // Legally fabricate a ProcessEnvironment.StringEntry,\n            // even though it's private.\n            Map<String, String> environ2 = new ProcessBuilder().environment();\n            environ2.clear();\n            environ2.put(\"Foo\", \"BAAR\");\n            // Subtlety alert.\n            Map.Entry<String, String> e = environ2.entrySet().iterator().next();\n            environ.entrySet().remove(e);\n          }\n        });\n\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            Map.Entry<String, String> victim = null;\n            for (Map.Entry<String, String> e : environ.entrySet())\n              if (e.getKey().equals(\"Foo\")) victim = e;\n            if (victim != null) environ.entrySet().remove(victim);\n          }\n        });\n\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            Iterator<String> it = environ.keySet().iterator();\n            while (it.hasNext()) {\n              String val = it.next();\n              if (val.equals(\"Foo\")) it.remove();\n            }\n          }\n        });\n\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            Iterator<Map.Entry<String, String>> it = environ.entrySet().iterator();\n            while (it.hasNext()) {\n              Map.Entry<String, String> e = it.next();\n              if (e.getKey().equals(\"Foo\")) it.remove();\n            }\n          }\n        });\n\n    testVariableDeleter(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            Iterator<String> it = environ.values().iterator();\n            while (it.hasNext()) {\n              String val = it.next();\n              if (val.equals(\"BAAR\")) it.remove();\n            }\n          }\n        });\n\n    // ----------------------------------------------------------------\n    // A surprisingly small number of ways to add an environment var.\n    // ----------------------------------------------------------------\n    testVariableAdder(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            environ.put(\"Foo\", \"Bahrein\");\n          }\n        });\n\n    // ----------------------------------------------------------------\n    // A few ways to modify an environment var.\n    // ----------------------------------------------------------------\n    testVariableModifier(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            environ.put(\"Foo\", \"NewValue\");\n          }\n        });\n\n    testVariableModifier(\n        new EnvironmentFrobber() {\n          public void doIt(Map<String, String> environ) {\n            for (Map.Entry<String, String> e : environ.entrySet())\n              if (e.getKey().equals(\"Foo\")) e.setValue(\"NewValue\");\n          }\n        });\n\n    // ----------------------------------------------------------------\n    // Fiddle with environment sizes\n    // ----------------------------------------------------------------\n    try {\n      Map<String, String> environ = new ProcessBuilder().environment();\n      int size = environ.size();\n      checkSizes(environ, size);\n\n      environ.put(\"UnLiKeLYeNVIROmtNam\", \"someVal\");\n      checkSizes(environ, size + 1);\n\n      // Check for environment independence\n      new ProcessBuilder().environment().clear();\n\n      environ.put(\"UnLiKeLYeNVIROmtNam\", \"someOtherVal\");\n      checkSizes(environ, size + 1);\n\n      environ.remove(\"UnLiKeLYeNVIROmtNam\");\n      checkSizes(environ, size);\n\n      environ.clear();\n      checkSizes(environ, 0);\n\n      environ.clear();\n      checkSizes(environ, 0);\n\n      environ = new ProcessBuilder().environment();\n      environ.keySet().clear();\n      checkSizes(environ, 0);\n\n      environ = new ProcessBuilder().environment();\n      environ.entrySet().clear();\n      checkSizes(environ, 0);\n\n      environ = new ProcessBuilder().environment();\n      environ.values().clear();\n      checkSizes(environ, 0);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Check that various map invariants hold\n    // ----------------------------------------------------------------\n    checkMapSanity(new ProcessBuilder().environment());\n    checkMapSanity(System.getenv());\n    checkMapEquality(new ProcessBuilder().environment(), new ProcessBuilder().environment());\n\n    // ----------------------------------------------------------------\n    // Check effects on external \"env\" command.\n    // ----------------------------------------------------------------\n    try {\n      Set<String> env1 = new HashSet<String>(Arrays.asList(nativeEnv((String[]) null).split(\"\\n\")));\n\n      ProcessBuilder pb = new ProcessBuilder();\n      pb.environment().put(\"QwErTyUiOp\", \"AsDfGhJk\");\n\n      Set<String> env2 = new HashSet<String>(Arrays.asList(nativeEnv(pb).split(\"\\n\")));\n\n      check(env2.size() == env1.size() + 1);\n      env1.add(\"QwErTyUiOp=AsDfGhJk\");\n      check(env1.equals(env2));\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Test Runtime.exec(...envp...)\n    // Check for sort order of environment variables on Windows.\n    // ----------------------------------------------------------------\n    try {\n      String systemRoot = \"SystemRoot=\" + System.getenv(\"SystemRoot\");\n      // '+' < 'A' < 'Z' < '_' < 'a' < 'z' < '~'\n      String[] envp = {\"FOO=BAR\", \"BAZ=GORP\", \"QUUX=\", \"+=+\", \"_=_\", \"~=~\", systemRoot};\n      String output = nativeEnv(envp);\n      String expected = \"+=+\\nBAZ=GORP\\nFOO=BAR\\nQUUX=\\n\" + systemRoot + \"\\n_=_\\n~=~\\n\";\n      // On Windows, Java must keep the environment sorted.\n      // Order is random on Unix, so this test does the sort.\n      if (!Windows.is()) output = sortByLinesWindowsly(output);\n      equal(output, expected);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Test Runtime.exec(...envp...)\n    // and check SystemRoot gets set automatically on Windows\n    // ----------------------------------------------------------------\n    try {\n      if (Windows.is()) {\n        String systemRoot = \"SystemRoot=\" + System.getenv(\"SystemRoot\");\n        String[] envp = {\"FOO=BAR\", \"BAZ=GORP\", \"QUUX=\", \"+=+\", \"_=_\", \"~=~\"};\n        String output = nativeEnv(envp);\n        String expected = \"+=+\\nBAZ=GORP\\nFOO=BAR\\nQUUX=\\n\" + systemRoot + \"\\n_=_\\n~=~\\n\";\n        equal(output, expected);\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // System.getenv() must be consistent with System.getenv(String)\n    // ----------------------------------------------------------------\n    try {\n      for (Map.Entry<String, String> e : getenv().entrySet())\n        equal(getenv(e.getKey()), e.getValue());\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Fiddle with working directory in child\n    // ----------------------------------------------------------------\n    try {\n      String canonicalUserDir = new File(System.getProperty(\"user.dir\")).getCanonicalPath();\n      String[] sdirs =\n          new String[] {\n            \".\",\n            \"..\",\n            \"/\",\n            \"/bin\",\n            \"C:\",\n            \"c:\",\n            \"C:/\",\n            \"c:\\\\\",\n            \"\\\\\",\n            \"\\\\bin\",\n            \"c:\\\\windows \",\n            \"c:\\\\Program Files\",\n            \"c:\\\\Program Files\\\\\"\n          };\n      for (String sdir : sdirs) {\n        File dir = new File(sdir);\n        if (!(dir.isDirectory() && dir.exists())) continue;\n        out.println(\"Testing directory \" + dir);\n        // dir = new File(dir.getCanonicalPath());\n\n        ProcessBuilder pb = new ProcessBuilder();\n        equal(pb.directory(), null);\n        equal(pwdInChild(pb), canonicalUserDir);\n\n        pb.directory(dir);\n        equal(pb.directory(), dir);\n        equal(pwdInChild(pb), dir.getCanonicalPath());\n\n        pb.directory(null);\n        equal(pb.directory(), null);\n        equal(pwdInChild(pb), canonicalUserDir);\n\n        pb.directory(dir);\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Working directory with Unicode in child\n    // ----------------------------------------------------------------\n    try {\n      if (UnicodeOS.is()) {\n        File dir = new File(System.getProperty(\"test.dir\", \".\"), \"ProcessBuilderDir\\u4e00\\u4e02\");\n        try {\n          if (!dir.exists()) dir.mkdir();\n          out.println(\"Testing Unicode directory:\" + dir);\n          ProcessBuilder pb = new ProcessBuilder();\n          pb.directory(dir);\n          equal(pwdInChild(pb), dir.getCanonicalPath());\n        } finally {\n          if (dir.exists()) dir.delete();\n        }\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // OOME in child allocating maximally sized array\n    // Test for hotspot/jvmti bug 6850957\n    // ----------------------------------------------------------------\n    try {\n      List<String> list = new ArrayList<String>(javaChildArgs);\n      list.add(1, String.format(\"-XX:OnOutOfMemoryError=%s -version\", javaExe));\n      list.add(\"ArrayOOME\");\n      ProcessResults r = run(new ProcessBuilder(list));\n      check(r.out().contains(\"java.lang.OutOfMemoryError:\"));\n      check(r.out().contains(javaExe));\n      check(r.err().contains(System.getProperty(\"java.version\")));\n      equal(r.exitValue(), 1);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Windows has tricky semi-case-insensitive semantics\n    // ----------------------------------------------------------------\n    if (Windows.is())\n      try {\n        out.println(\"Running case insensitve variable tests\");\n        for (String[] namePair :\n            new String[][] {\n              new String[] {\"PATH\", \"PaTh\"},\n              new String[] {\"home\", \"HOME\"},\n              new String[] {\"SYSTEMROOT\", \"SystemRoot\"}\n            }) {\n          check(\n              (getenv(namePair[0]) == null && getenv(namePair[1]) == null)\n                  || getenv(namePair[0]).equals(getenv(namePair[1])),\n              \"Windows environment variables are not case insensitive\");\n        }\n      } catch (Throwable t) {\n        unexpected(t);\n      }\n\n    // ----------------------------------------------------------------\n    // Test proper Unicode child environment transfer\n    // ----------------------------------------------------------------\n    if (UnicodeOS.is())\n      try {\n        ProcessBuilder pb = new ProcessBuilder();\n        pb.environment().put(\"\\u1234\", \"\\u5678\");\n        pb.environment().remove(\"PATH\");\n        equal(getenvInChild1234(pb), \"\\u5678\");\n      } catch (Throwable t) {\n        unexpected(t);\n      }\n\n    // ----------------------------------------------------------------\n    // Test Runtime.exec(...envp...) with envstrings with initial `='\n    // ----------------------------------------------------------------\n    try {\n      List<String> childArgs = new ArrayList<String>(javaChildArgs);\n      childArgs.add(\"System.getenv()\");\n      String[] cmdp = childArgs.toArray(new String[childArgs.size()]);\n      String[] envp;\n      String[] envpWin = {\"=ExitValue=3\", \"=C:=\\\\\", \"SystemRoot=\" + systemRoot};\n      String[] envpOth = {\"=ExitValue=3\", \"=C:=\\\\\"};\n      if (Windows.is()) {\n        envp = envpWin;\n      } else {\n        envp = envpOth;\n      }\n      Process p = Runtime.getRuntime().exec(cmdp, envp);\n      String expected =\n          Windows.is() ? \"=C:=\\\\,SystemRoot=\" + systemRoot + \",=ExitValue=3,\" : \"=C:=\\\\,\";\n      equal(commandOutput(p), expected);\n      if (Windows.is()) {\n        ProcessBuilder pb = new ProcessBuilder(childArgs);\n        pb.environment().clear();\n        pb.environment().put(\"SystemRoot\", systemRoot);\n        pb.environment().put(\"=ExitValue\", \"3\");\n        pb.environment().put(\"=C:\", \"\\\\\");\n        equal(commandOutput(pb), expected);\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Test Runtime.exec(...envp...) with envstrings without any `='\n    // ----------------------------------------------------------------\n    try {\n      String[] cmdp = {\"echo\"};\n      String[] envp = {\"Hello\", \"World\"}; // Yuck!\n      Process p = Runtime.getRuntime().exec(cmdp, envp);\n      equal(commandOutput(p), \"\\n\");\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Test Runtime.exec(...envp...) with envstrings containing NULs\n    // ----------------------------------------------------------------\n    try {\n      List<String> childArgs = new ArrayList<String>(javaChildArgs);\n      childArgs.add(\"System.getenv()\");\n      String[] cmdp = childArgs.toArray(new String[childArgs.size()]);\n      String[] envpWin = {\n        \"SystemRoot=\" + systemRoot,\n        \"LC_ALL=C\\u0000\\u0000\", // Yuck!\n        \"FO\\u0000=B\\u0000R\"\n      };\n      String[] envpOth = {\n        \"LC_ALL=C\\u0000\\u0000\", // Yuck!\n        \"FO\\u0000=B\\u0000R\"\n      };\n      String[] envp;\n      if (Windows.is()) {\n        envp = envpWin;\n      } else {\n        envp = envpOth;\n      }\n      Process p = Runtime.getRuntime().exec(cmdp, envp);\n      check(\n          commandOutput(p)\n              .equals(Windows.is() ? \"SystemRoot=\" + systemRoot + \",LC_ALL=C,\" : \"LC_ALL=C,\"),\n          \"Incorrect handling of envstrings containing NULs\");\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Test the redirectErrorStream property\n    // ----------------------------------------------------------------\n    try {\n      ProcessBuilder pb = new ProcessBuilder();\n      equal(pb.redirectErrorStream(), false);\n      equal(pb.redirectErrorStream(true), pb);\n      equal(pb.redirectErrorStream(), true);\n      equal(pb.redirectErrorStream(false), pb);\n      equal(pb.redirectErrorStream(), false);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    try {\n      List<String> childArgs = new ArrayList<String>(javaChildArgs);\n      childArgs.add(\"OutErr\");\n      ProcessBuilder pb = new ProcessBuilder(childArgs);\n      {\n        ProcessResults r = run(pb);\n        equal(r.out(), \"outout\");\n        equal(r.err(), \"errerr\");\n      }\n      {\n        pb.redirectErrorStream(true);\n        ProcessResults r = run(pb);\n        equal(r.out(), \"outerrouterr\");\n        equal(r.err(), \"\");\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    if (Unix.is()) {\n      // ----------------------------------------------------------------\n      // We can find true and false when PATH is null\n      // ----------------------------------------------------------------\n      try {\n        List<String> childArgs = new ArrayList<String>(javaChildArgs);\n        childArgs.add(\"null PATH\");\n        ProcessBuilder pb = new ProcessBuilder(childArgs);\n        pb.environment().remove(\"PATH\");\n        ProcessResults r = run(pb);\n        equal(r.out(), \"\");\n        equal(r.err(), \"\");\n        equal(r.exitValue(), 0);\n      } catch (Throwable t) {\n        unexpected(t);\n      }\n\n      // ----------------------------------------------------------------\n      // PATH search algorithm on Unix\n      // ----------------------------------------------------------------\n      try {\n        List<String> childArgs = new ArrayList<String>(javaChildArgs);\n        childArgs.add(\"PATH search algorithm\");\n        ProcessBuilder pb = new ProcessBuilder(childArgs);\n        pb.environment().put(\"PATH\", \"dir1:dir2:\");\n        ProcessResults r = run(pb);\n        equal(r.out(), \"\");\n        equal(r.err(), \"\");\n        equal(r.exitValue(), True.exitValue());\n      } catch (Throwable t) {\n        unexpected(t);\n      }\n\n      // ----------------------------------------------------------------\n      // Parent's, not child's PATH is used\n      // ----------------------------------------------------------------\n      try {\n        new File(\"suBdiR\").mkdirs();\n        copy(\"/bin/true\", \"suBdiR/unliKely\");\n        final ProcessBuilder pb = new ProcessBuilder(new String[] {\"unliKely\"});\n        pb.environment().put(\"PATH\", \"suBdiR\");\n        THROWS(\n            IOException.class,\n            new Fun() {\n              void f() throws Throwable {\n                pb.start();\n              }\n            });\n      } catch (Throwable t) {\n        unexpected(t);\n      } finally {\n        new File(\"suBdiR/unliKely\").delete();\n        new File(\"suBdiR\").delete();\n      }\n    }\n\n    // ----------------------------------------------------------------\n    // Attempt to start bogus program \"\"\n    // ----------------------------------------------------------------\n    try {\n      new ProcessBuilder(\"\").start();\n      fail(\"Expected IOException not thrown\");\n    } catch (IOException e) {\n      String m = e.getMessage();\n      if (EnglishUnix.is() && !matches(m, \"No such file or directory\")) unexpected(e);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Check that attempt to execute program name with funny\n    // characters throws an exception containing those characters.\n    // ----------------------------------------------------------------\n    for (String programName : new String[] {\"\\u00f0\", \"\\u01f0\"})\n      try {\n        new ProcessBuilder(programName).start();\n        fail(\"Expected IOException not thrown\");\n      } catch (IOException e) {\n        String m = e.getMessage();\n        Pattern p = Pattern.compile(programName);\n        if (!matches(m, programName)\n            || (EnglishUnix.is() && !matches(m, \"No such file or directory\"))) unexpected(e);\n      } catch (Throwable t) {\n        unexpected(t);\n      }\n\n    // ----------------------------------------------------------------\n    // Attempt to start process in nonexistent directory fails.\n    // ----------------------------------------------------------------\n    try {\n      new ProcessBuilder(\"echo\").directory(new File(\"UnLiKeLY\")).start();\n      fail(\"Expected IOException not thrown\");\n    } catch (IOException e) {\n      String m = e.getMessage();\n      if (!matches(m, \"in directory\")\n          || (EnglishUnix.is() && !matches(m, \"No such file or directory\"))) unexpected(e);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Attempt to write 4095 bytes to the pipe buffer without a\n    // reader to drain it would deadlock, if not for the fact that\n    // interprocess pipe buffers are at least 4096 bytes.\n    //\n    // Also, check that available reports all the bytes expected\n    // in the pipe buffer, and that I/O operations do the expected\n    // things.\n    // ----------------------------------------------------------------\n    try {\n      List<String> childArgs = new ArrayList<String>(javaChildArgs);\n      childArgs.add(\"print4095\");\n      final int SIZE = 4095;\n      final Process p = new ProcessBuilder(childArgs).start();\n      print4095(p.getOutputStream(), (byte) '!'); // Might hang!\n      p.waitFor(); // Might hang!\n      equal(SIZE, p.getInputStream().available());\n      equal(SIZE, p.getErrorStream().available());\n      THROWS(\n          IOException.class,\n          new Fun() {\n            void f() throws IOException {\n              p.getOutputStream().write((byte) '!');\n              p.getOutputStream().flush();\n            }\n          });\n\n      final byte[] bytes = new byte[SIZE + 1];\n      equal(SIZE, p.getInputStream().read(bytes));\n      for (int i = 0; i < SIZE; i++) equal((byte) '!', bytes[i]);\n      equal((byte) 0, bytes[SIZE]);\n\n      equal(SIZE, p.getErrorStream().read(bytes));\n      for (int i = 0; i < SIZE; i++) equal((byte) 'E', bytes[i]);\n      equal((byte) 0, bytes[SIZE]);\n\n      equal(0, p.getInputStream().available());\n      equal(0, p.getErrorStream().available());\n      equal(-1, p.getErrorStream().read());\n      equal(-1, p.getInputStream().read());\n\n      equal(p.exitValue(), 5);\n\n      p.getInputStream().close();\n      p.getErrorStream().close();\n      p.getOutputStream().close();\n\n      InputStream[] streams = {p.getInputStream(), p.getErrorStream()};\n      for (final InputStream in : streams) {\n        Fun[] ops = {\n          new Fun() {\n            void f() throws IOException {\n              in.read();\n            }\n          },\n          new Fun() {\n            void f() throws IOException {\n              in.read(bytes);\n            }\n          },\n          new Fun() {\n            void f() throws IOException {\n              in.available();\n            }\n          }\n        };\n        for (Fun op : ops) {\n          try {\n            op.f();\n            fail();\n          } catch (IOException expected) {\n            check(expected.getMessage().matches(\"[Ss]tream [Cc]losed\"));\n          }\n        }\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Check that reads which are pending when Process.destroy is\n    // called, get EOF, not IOException(\"Stream closed\").\n    // ----------------------------------------------------------------\n    try {\n      final int cases = 4;\n      for (int i = 0; i < cases; i++) {\n        final int action = i;\n        List<String> childArgs = new ArrayList<String>(javaChildArgs);\n        childArgs.add(\"sleep\");\n        final byte[] bytes = new byte[10];\n        final Process p = new ProcessBuilder(childArgs).start();\n        final CountDownLatch latch = new CountDownLatch(1);\n        final Thread thread =\n            new Thread() {\n              public void run() {\n                try {\n                  latch.countDown();\n                  int r;\n                  switch (action) {\n                    case 0:\n                      r = p.getInputStream().read();\n                      break;\n                    case 1:\n                      r = p.getErrorStream().read();\n                      break;\n                    case 2:\n                      r = p.getInputStream().read(bytes);\n                      break;\n                    case 3:\n                      r = p.getErrorStream().read(bytes);\n                      break;\n                    default:\n                      throw new Error();\n                  }\n                  equal(-1, r);\n                } catch (Throwable t) {\n                  unexpected(t);\n                }\n              }\n            };\n\n        thread.start();\n        latch.await();\n        Thread.sleep(10);\n        p.destroy();\n        thread.join();\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Check that subprocesses which create subprocesses of their\n    // own do not cause parent to hang waiting for file\n    // descriptors to be closed.\n    // ----------------------------------------------------------------\n    try {\n      if (Unix.is() && new File(\"/bin/bash\").exists() && new File(\"/bin/sleep\").exists()) {\n        final String[] cmd = {\"/bin/bash\", \"-c\", \"(/bin/sleep 6666)\"};\n        final ProcessBuilder pb = new ProcessBuilder(cmd);\n        final Process p = pb.start();\n        final InputStream stdout = p.getInputStream();\n        final InputStream stderr = p.getErrorStream();\n        final OutputStream stdin = p.getOutputStream();\n        final Thread reader =\n            new Thread() {\n              public void run() {\n                try {\n                  stdout.read();\n                } catch (IOException e) {\n                  // Check that reader failed because stream was\n                  // asynchronously closed.\n                  // e.printStackTrace();\n                  if (EnglishUnix.is() && !(e.getMessage().matches(\".*Bad file.*\"))) unexpected(e);\n                } catch (Throwable t) {\n                  unexpected(t);\n                }\n              }\n            };\n        reader.setDaemon(true);\n        reader.start();\n        Thread.sleep(100);\n        p.destroy();\n        // Subprocess is now dead, but file descriptors remain open.\n        check(p.waitFor() != 0);\n        check(p.exitValue() != 0);\n        stdout.close();\n        stderr.close();\n        stdin.close();\n        // ----------------------------------------------------------\n        // There remain unsolved issues with asynchronous close.\n        // Here's a highly non-portable experiment to demonstrate:\n        // ----------------------------------------------------------\n        if (Boolean.getBoolean(\"wakeupJeff!\")) {\n          System.out.println(\"wakeupJeff!\");\n          // Initialize signal handler for INTERRUPT_SIGNAL.\n          new FileInputStream(\"/bin/sleep\").getChannel().close();\n          // Send INTERRUPT_SIGNAL to every thread in this java.\n          String[] wakeupJeff = {\n            \"/bin/bash\",\n            \"-c\",\n            \"/bin/ps --noheaders -Lfp $PPID | \"\n                + \"/usr/bin/perl -nale 'print $F[3]' | \"\n                +\n                // INTERRUPT_SIGNAL == 62 on my machine du jour.\n                \"/usr/bin/xargs kill -62\"\n          };\n          new ProcessBuilder(wakeupJeff).start().waitFor();\n          // If wakeupJeff worked, reader probably got EBADF.\n          reader.join();\n        }\n      }\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // ----------------------------------------------------------------\n    // Attempt to start process with insufficient permissions fails.\n    // ----------------------------------------------------------------\n    try {\n      new File(\"emptyCommand\").delete();\n      new FileOutputStream(\"emptyCommand\").close();\n      new File(\"emptyCommand\").setExecutable(false);\n      new ProcessBuilder(\"./emptyCommand\").start();\n      fail(\"Expected IOException not thrown\");\n    } catch (IOException e) {\n      new File(\"./emptyCommand\").delete();\n      String m = e.getMessage();\n      if (EnglishUnix.is() && !matches(m, \"Permission denied\")) unexpected(e);\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    new File(\"emptyCommand\").delete();\n\n    // ----------------------------------------------------------------\n    // Check for correct security permission behavior\n    // ----------------------------------------------------------------\n    final Policy policy = new Policy();\n    Policy.setPolicy(policy);\n    System.setSecurityManager(new SecurityManager());\n\n    try {\n      // No permissions required to CREATE a ProcessBuilder\n      policy.setPermissions(/* Nothing */ );\n      new ProcessBuilder(\"env\").directory(null).directory();\n      new ProcessBuilder(\"env\").directory(new File(\"dir\")).directory();\n      new ProcessBuilder(\"env\").command(\"??\").command();\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    THROWS(\n        SecurityException.class,\n        new Fun() {\n          void f() throws IOException {\n            policy.setPermissions(/* Nothing */ );\n            System.getenv(\"foo\");\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            policy.setPermissions(/* Nothing */ );\n            System.getenv();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            policy.setPermissions(/* Nothing */ );\n            new ProcessBuilder(\"echo\").start();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            policy.setPermissions(/* Nothing */ );\n            Runtime.getRuntime().exec(\"echo\");\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            policy.setPermissions(new RuntimePermission(\"getenv.bar\"));\n            System.getenv(\"foo\");\n          }\n        });\n\n    try {\n      policy.setPermissions(new RuntimePermission(\"getenv.foo\"));\n      System.getenv(\"foo\");\n\n      policy.setPermissions(new RuntimePermission(\"getenv.*\"));\n      System.getenv(\"foo\");\n      System.getenv();\n      new ProcessBuilder().environment();\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    final Permission execPermission = new FilePermission(\"<<ALL FILES>>\", \"execute\");\n\n    THROWS(\n        SecurityException.class,\n        new Fun() {\n          void f() throws IOException {\n            // environment permission by itself insufficient\n            policy.setPermissions(new RuntimePermission(\"getenv.*\"));\n            ProcessBuilder pb = new ProcessBuilder(\"env\");\n            pb.environment().put(\"foo\", \"bar\");\n            pb.start();\n          }\n        },\n        new Fun() {\n          void f() throws IOException {\n            // exec permission by itself insufficient\n            policy.setPermissions(execPermission);\n            ProcessBuilder pb = new ProcessBuilder(\"env\");\n            pb.environment().put(\"foo\", \"bar\");\n            pb.start();\n          }\n        });\n\n    try {\n      // Both permissions? OK.\n      policy.setPermissions(new RuntimePermission(\"getenv.*\"), execPermission);\n      ProcessBuilder pb = new ProcessBuilder(\"env\");\n      pb.environment().put(\"foo\", \"bar\");\n      Process p = pb.start();\n      closeStreams(p);\n    } catch (IOException e) { // OK\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    try {\n      // Don't need environment permission unless READING environment\n      policy.setPermissions(execPermission);\n      Runtime.getRuntime().exec(\"env\", new String[] {});\n    } catch (IOException e) { // OK\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    try {\n      // Don't need environment permission unless READING environment\n      policy.setPermissions(execPermission);\n      new ProcessBuilder(\"env\").start();\n    } catch (IOException e) { // OK\n    } catch (Throwable t) {\n      unexpected(t);\n    }\n\n    // Restore \"normal\" state without a security manager\n    policy.setPermissions(new RuntimePermission(\"setSecurityManager\"));\n    System.setSecurityManager(null);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2056, "initialization": ["File file = new File(String)"], "initializationStart": [72], "initializationEnd": [90], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 44, "tryExpressionEnd": 48, "tryBlockStart": 44, "tryBlockEnd": 319, "catchExpressionStart": 253, "catchExpressionEnd": 275, "catchBlockStart": 253, "catchBlockEnd": 319, "exceptionHandlingCallStart": [289], "exceptionHandlingCallEnd": [312], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 132, "focalAPIEnd": 148, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/azhur/PingPong/tree/master/core/src/main/java/com/pingpong/core/ImageResource.java", "rawCode": "  public void store(PhotoImage image) {\n    try {\n      File photoDir = new File(imageDir);\n      if (!photoDir.exists()) {\n        photoDir.mkdir();\n      }\n\n      IOUtils.write(image.getImage(), new FileOutputStream(image.getPhoto().getUrl()));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2057, "initialization": ["File file = new File(*,String)"], "initializationStart": [102], "initializationEnd": [146], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 154, "focalAPIEnd": 166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.createNewFile()", "file.exists()"], "useStart": [246, 285], "useEnd": [266, 298], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/unclebob/fitnesse/tree/master/src/fitnesse/fixtures/FileSectionFileAdder.java", "rawCode": "  public boolean valid() throws Exception {\n    File file;\n    if (\"dir\".equals(type)) {\n      file = new File(FileSection.getFileSection(), path);\n      file.mkdir();\n    } else {\n      file = new File(FileSection.getFileSection(), path);\n      file.createNewFile();\n    }\n    return file.exists();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2058, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 136, "focalAPIEnd": 146, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,*)", "copyFile(File,file)", "new File(file,*)", "new FileOutputStream(file)"], "useStart": [439, 520, 667, 788], "useEnd": [464, 535, 695, 812], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MiniSEC/adito_reload/tree/master/adito/branches/maven2/agent/src/main/java/com/adito/agent/client/util/Utils.java", "rawCode": "  public static void copyFile(File from, File to) throws IOException {\n\n    if (from.isDirectory()) {\n      if (!to.exists()) {\n        to.mkdir();\n      }\n      String[] children = from.list();\n      for (int i = 0; i < children.length; i++) {\n        File f = new File(from, children[i]);\n        if (f.getName().equals(\".\") || f.getName().equals(\"..\")) {\n          continue;\n        }\n        if (f.isDirectory()) {\n          File f2 = new File(to, f.getName());\n          copyFile(f, f2);\n        } else {\n          copyFile(f, to);\n        }\n      }\n    } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n      if (to.isDirectory()) {\n        to = new File(to, from.getName());\n      }\n      FileInputStream in = new FileInputStream(from);\n      FileOutputStream out = new FileOutputStream(to);\n      byte[] buf = new byte[32678];\n      int read;\n      while ((read = in.read(buf)) > -1) {\n        out.write(buf, 0, read);\n      }\n      closeStream(in);\n      closeStream(out);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2059, "initialization": ["File file = new File(String)"], "initializationStart": [674], "initializationEnd": [691], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 845, "focalAPIEnd": 865, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/geosolutions-it/IntersectionEngine/tree/master/src/gb-actions-figis/intersection/src/main/java/it/geosolutions/geobatch/figis/intersection/Utilities.java", "rawCode": "  /**\n   * *** This method takes a wfs url, download the layername features, save it in the figisTmpDir\n   * directory and return its SimpleFEatureCollection\n   *\n   * @param textUrl\n   * @param filename\n   * @param destDir\n   * @throws IOException\n   * @throws MalformedURLException\n   */\n  static String getShapeFileFromURLbyZIP(String textUrl, String figisTmpDir, String layername)\n      throws MalformedURLException, IOException {\n    // init the folder name where to save and uncompress the zip file\n    String destDir = figisTmpDir + \"/\" + layername;\n\n    if (LOGGER.isTraceEnabled()) {\n      LOGGER.trace(\"Destination dir \" + destDir);\n    }\n\n    File finalDestDir = new File(destDir);\n\n    if (!finalDestDir.exists()) // check if the temp dir exist, if not:\n    // create it, download the zip and\n    // uncompress the files\n    {\n      finalDestDir.mkdir();\n      try {\n        if (LOGGER.isTraceEnabled()) {\n          LOGGER.trace(\"downloading from : \" + textUrl);\n        }\n        saveZipToLocal(textUrl, destDir, layername);\n        if (LOGGER.isTraceEnabled()) {\n          LOGGER.trace(\"download completed successfully\");\n        }\n      } catch (Exception e) {\n        LOGGER.error(\"Error downloading the zip file\", e);\n        throw new IOException(\"Error downloading the zip file\", e);\n      }\n      try {\n        if (LOGGER.isTraceEnabled()) {\n          LOGGER.trace(\"Extracting the zip file \" + destDir + \"/\" + layername + \".zip\");\n        }\n        Extract.extract(destDir + \"/\" + layername + \".zip\");\n        if (LOGGER.isTraceEnabled()) {\n          LOGGER.trace(\"Extraction completed successfully\");\n        }\n      } catch (Exception e) {\n        // some exception during the file extraction, return a null\n        // value\n        LOGGER.error(\"Error extracting the zip file\", e);\n        throw new IOException(\"Error extracting the zip file\", e);\n      }\n      // extractZipFile(destDir, layername);\n    }\n\n    // return the simple feature collection from the uncompressed shp file\n    // name\n    String shpfilename = figisTmpDir + \"/\" + layername + \"/\" + layername + \"/\" + layername + \".shp\";\n    File shpFile = new File(shpfilename);\n    if (shpFile.exists() && shpFile.canRead() && shpFile.isFile()) {\n      if (LOGGER.isTraceEnabled()) {\n        LOGGER.trace(\"Shpfilename: \" + shpfilename);\n      }\n      return shpfilename;\n    } else {\n      File shpFileDir = new File(figisTmpDir + \"/\" + layername + \"/\" + layername);\n      if (shpFileDir.exists() && shpFileDir.isDirectory()) {\n        File[] shpFiles =\n            shpFileDir.listFiles(\n                new FilenameFilter() {\n\n                  public boolean accept(File dir, String name) {\n                    if (FilenameUtils.getExtension(name).equalsIgnoreCase(\"shp\")) return true;\n                    return false;\n                  }\n                });\n\n        if (shpFiles != null && shpFiles.length == 1) {\n          if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(\"Shpfilename: \" + shpfilename);\n          }\n          return shpFiles[0].getAbsolutePath();\n        } else {\n          LOGGER.error(\"Could not download shapefile from GeoServer\");\n          throw new IOException(\"Could not download shapefile from GeoServer\");\n        }\n      } else {\n        LOGGER.error(\"Could not download shapefile from GeoServer\");\n        throw new IOException(\"Could not download shapefile from GeoServer\");\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2060, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 95, "focalAPIEnd": 111, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/quant42/ProteinPrediction/tree/master/src/proteinprediction/ProgramSettings.java", "rawCode": "  /** initialize program: make required directories */\n  public static void initialize() {\n    MAIN_DIR.mkdir();\n    MODEL_DIR.mkdir();\n    RESULT_DIR.mkdir();\n    DATASET_DIR.mkdir();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2061, "initialization": ["File file = new File(File,*)"], "initializationStart": [514], "initializationEnd": [550], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 593, "focalAPIEnd": 610, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new FileOutputStream(file)"], "useStart": [737], "useEnd": [768], "hasFinally": 1, "cleanUpCall": ["FileOutputStream.close()"], "finallyExpressionStart": 1021, "finallyExpressionEnd": 1029, "finallyBlockStart": 1021, "finallyBlockEnd": 1194, "cleanUpCallStart": [1072], "cleanUpCallEnd": [1083], "url": "https://github.com/bugobliterator/BUAGI/tree/master/app/src/processing/app/tools/ZipDeflater.java", "rawCode": "  public void deflate() throws IOException {\n    String tmpFolderName = folderNameFromZip() + random.nextInt(1000000);\n\n    File tmpFolder = new File(destFolder, tmpFolderName);\n\n    if (!tmpFolder.mkdir()) {\n      throw new IOException(\"Unable to create folder \" + tmpFolderName);\n    }\n\n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      ensureFoldersOfEntryExist(tmpFolder, entry);\n      File entryFile = new File(tmpFolder, entry.getName());\n      if (entry.isDirectory()) {\n        entryFile.mkdir();\n      } else {\n        FileOutputStream fos = null;\n        InputStream zipInputStream = null;\n        try {\n          fos = new FileOutputStream(entryFile);\n          zipInputStream = zipFile.getInputStream(entry);\n          byte[] buffer = new byte[1024 * 4];\n          int len = -1;\n          while ((len = zipInputStream.read(buffer)) != -1) {\n            fos.write(buffer, 0, len);\n          }\n        } finally {\n          if (fos != null) {\n            fos.close();\n          }\n          if (zipInputStream != null) {\n            zipInputStream.close();\n          }\n        }\n      }\n    }\n\n    deleteUndesiredFoldersAndFiles(tmpFolder);\n\n    // Test.zip may or may not contain Test folder. If it does, we keep it. If not, we use zip name.\n    ensureOneLevelFolder(tmpFolder);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2062, "initialization": ["File file = new File(String)"], "initializationStart": [135], "initializationEnd": [156], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 214, "focalAPIEnd": 226, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/niclash/chronos/tree/master/ideaplugin/src/main/java/org/qi4j/chronos/util/ChronosUtil.java", "rawCode": "  public static File getChronosDir() {\n    String chronosHome = getUserHomeDir() + File.separator + CHRONOS_DIR_NAME;\n\n    File file = new File(chronosHome);\n\n    if (!file.exists() || !file.isDirectory()) {\n      file.mkdir();\n    }\n\n    return file;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2063, "initialization": ["File file = new File(File,String)"], "initializationStart": [104], "initializationEnd": [132], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 169, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/insidepower/eclipseandroid/tree/master/reference/web/Catlog/Catlog/src/com/nolanlawson/logcat/helper/SaveLogHelper.java", "rawCode": "  public static File getTempDirectory() {\n    File catlogDir = getCatlogDirectory();\n\n    File tmpDir = new File(catlogDir, TMP_DIR);\n\n    if (!tmpDir.exists()) {\n      tmpDir.mkdir();\n    }\n\n    return tmpDir;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2064, "initialization": ["File file = new File(String)"], "initializationStart": [295], "initializationEnd": [314], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 377, "focalAPIEnd": 392, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)", "new File(file,*)"], "useStart": [559, 632], "useEnd": [594, 689], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eea/eionet.datadict/tree/master/src/main/java/eionet/meta/schemas/SchemaRepository.java", "rawCode": "  /**\n   * @return\n   * @throws IOException\n   */\n  public File addSchema(FileBean fileBean, String schemaSetIdentifier, boolean overwrite)\n      throws IOException {\n\n    if (fileBean == null) {\n      throw new IllegalArgumentException(\"File bean must not be null!\");\n    }\n\n    File repoDir = new File(REPO_PATH);\n    if (!repoDir.exists() || !repoDir.isDirectory()) {\n      repoDir.mkdir();\n    }\n\n    File workingCopyDir = null;\n    boolean isRootLevelSchema = StringUtils.isBlank(schemaSetIdentifier);\n    if (isRootLevelSchema) {\n      workingCopyDir = new File(repoDir, WORKING_COPY_DIR);\n    } else {\n      workingCopyDir = new File(repoDir, schemaSetIdentifier + WORKING_COPY_DIR);\n    }\n\n    if (workingCopyDir.exists() || !workingCopyDir.isDirectory()) {\n      workingCopyDir.mkdir();\n    }\n\n    File schemaFile = new File(workingCopyDir, fileBean.getFileName());\n    if (schemaFile.exists() && schemaFile.isFile()) {\n      if (overwrite == false) {\n        throw new DDRuntimeException(\"File already exists, but overwrite not requested!\");\n      } else {\n        schemaFile.delete();\n      }\n    }\n\n    fileBean.save(schemaFile);\n    if (schemaFile.exists() && schemaFile.isFile()) {\n      return schemaFile;\n    } else {\n      throw new DDRuntimeException(\n          \"Schema file creation threw no exceptions, yet the file does not exist!\");\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2065, "initialization": ["File file = new File(File,String)"], "initializationStart": [503], "initializationEnd": [521], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 527, "focalAPIEnd": 537, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [558], "useEnd": [581], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/snasrallah/DiskSpaceInformer/tree/master/test/dsi/DiskSpaceInformerTest.java", "rawCode": "  @Before\n  public void setUp() throws Exception {\n    String tempPath = tempFolder.getRoot().toString();\n    // System.out.format(\"created temp folder: %s\", tempPath);\n    tempFolder.newFile(\"empty.txt\");\n\n    File f1 = tempFolder.newFolder(\"f1\");\n    fillFileToSize(new File(f1, \"1Mb.txt\"), 1024);\n\n    File f2 = tempFolder.newFolder(\"f2\");\n    fillFileToSize(new File(f2, \"2Mb.txt\"), 3072);\n\n    File f3 = tempFolder.newFolder(\"f3\");\n    fillFileToSize(new File(f3, \"3Mb.txt\"), 2048);\n\n    File f4 = new File(f3, \"f4\");\n    f4.mkdir();\n    fillFileToSize(new File(f4, \"4Mb.txt\"), 4096);\n\n    app = ApplicationLauncher.application(DiskSpaceInformer.class);\n    app.withArgs(tempPath);\n    app.start();\n\n    robot = BasicRobot.robotWithCurrentAwtHierarchy();\n    robot.settings().delayBetweenEvents(delay);\n\n    FrameFinder ff = WindowFinder.findFrame(\"DiskSpaceInformer\");\n\n    // Find the main window\n    window = ff.using(robot);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2066, "initialization": ["File file = createTempFile(String,*)"], "initializationStart": [394], "initializationEnd": [429], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.delete()"], "configurationStart": [454], "configurationEnd": [467], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 473, "focalAPIEnd": 485, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.deleteOnExit()", "ResourceCollection.copyTo(file)", "file.toURI()", "delete(file)"], "useStart": [491, 516, 572, 940], "useEnd": [510, 531, 584, 955], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-spdy/tree/master/jetty-util/src/test/java/org/eclipse/jetty/util/resource/ResourceCollectionTest.java", "rawCode": "  @Test\n  public void testCopyTo() throws Exception {\n    ResourceCollection rc =\n        new ResourceCollection(\n            new String[] {\n              \"src/test/resources/org/eclipse/jetty/util/resource/one/\",\n              \"src/test/resources/org/eclipse/jetty/util/resource/two/\",\n              \"src/test/resources/org/eclipse/jetty/util/resource/three/\"\n            });\n\n    File dest = File.createTempFile(\"copyto\", null);\n    if (dest.exists()) dest.delete();\n    dest.mkdir();\n    dest.deleteOnExit();\n    rc.copyTo(dest);\n\n    Resource r = Resource.newResource(dest.toURI());\n    assertEquals(\"1 - one\", getContent(r, \"1.txt\"));\n    assertEquals(\"2 - two\", getContent(r, \"2.txt\"));\n    assertEquals(\"3 - three\", getContent(r, \"3.txt\"));\n    r = r.addPath(\"dir\");\n    assertEquals(\"1 - one\", getContent(r, \"1.txt\"));\n    assertEquals(\"2 - two\", getContent(r, \"2.txt\"));\n    assertEquals(\"3 - three\", getContent(r, \"3.txt\"));\n\n    IO.delete(dest);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2067, "initialization": ["File file = new File(String)"], "initializationStart": [189], "initializationEnd": [207], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 213, "focalAPIEnd": 231, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OpenSextant/opensextant/tree/master/Xponents/XText/src/main/java/org/mitre/xtext/converters/ArchiveNavigator.java", "rawCode": "  public File unzip(File zipFile) throws IOException {\n\n    String _working =\n        getWorkingDir() + File.separator + FilenameUtils.getBaseName(zipFile.getPath());\n    File workingDir = new File(_working);\n    workingDir.mkdir();\n\n    InputStream input = new BufferedInputStream(new FileInputStream(zipFile));\n    try {\n      ZipArchiveInputStream in =\n          (ZipArchiveInputStream)\n              (new ArchiveStreamFactory().createArchiveInputStream(\"zip\", input));\n\n      ZipArchiveEntry zipEntry;\n      while ((zipEntry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n        if (filterEntry(zipEntry)) {\n          continue;\n        }\n\n        try {\n          File tmpFile = saveArchiveEntry(zipEntry, in, _working);\n          converter.convert(tmpFile);\n\n        } catch (IOException err) {\n          log.error(\n              \"Unable to save item, FILE=\" + zipEntry.getName() + \"!\" + zipEntry.getName(), err);\n        }\n      }\n      in.close();\n    } catch (ArchiveException ae) {\n      throw new IOException(ae);\n    }\n\n    return workingDir;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2068, "initialization": ["File file = new File(*)"], "initializationStart": [285], "initializationEnd": [308], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 355, "focalAPIEnd": 366, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/vjet.all/tree/master/eclipse/plugins/org.eclipse.vjet.eclipse.ui/src/org/eclipse/vjet/eclipse/internal/ui/text/completion/VjoProposalAditionalInfoGenerator.java", "rawCode": "  /**\n   * @param baseUrl\n   * @param create\n   */\n  private static void generateTempFolder(URL baseUrl, boolean create) {\n    if (baseUrl == null) {\n      return;\n    }\n\n    try {\n      // make sure the directory exists\n      URL url = new URL(baseUrl, PERS_FOLDER);\n      File dir = new File(url.getFile());\n      if (!dir.exists() && create) {\n        dir.mkdir();\n      }\n\n    } catch (IOException e) {\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2069, "initialization": ["File file = new SecureDirectory(*,String)"], "initializationStart": [1351], "initializationEnd": [1436], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1444, "focalAPIEnd": 1461, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [1487], "useEnd": [1524], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/i2p/i2p.i2p/tree/master/apps/routerconsole/java/src/net/i2p/router/web/WebAppStarter.java", "rawCode": "  /**\n   * add but don't start This is used only by RouterConsoleRunner, which adds all the webapps first\n   * and then starts all at once.\n   */\n  static WebAppContext addWebApp(\n      RouterContext ctx,\n      ContextHandlerCollection server,\n      String appName,\n      String warPath,\n      File tmpdir)\n      throws IOException {\n\n    // Jetty will happily load one context on top of another without stopping\n    // the first one, so we remove any previous one here\n    try {\n      stopWebApp(ctx, appName);\n    } catch (Throwable t) {\n    }\n\n    // To avoid ZipErrors from JarURLConnetion caching,\n    // (used by Jetty JarResource and JarFileResource)\n    // copy the war to a new directory if it is newer than the one we loaded originally.\n    // Yes, URLConnection has a setDefaultUseCaches() method, but it's hard to get to\n    // because it's non-static and the class is abstract, and we don't really want to\n    // set the default to false for everything.\n    long newmod = (new File(warPath)).lastModified();\n    if (newmod <= 0) throw new IOException(\"Web app \" + warPath + \" does not exist\");\n    Long oldmod = warModTimes.get(warPath);\n    if (oldmod == null) {\n      warModTimes.put(warPath, Long.valueOf(newmod));\n    } else if (oldmod.longValue() < newmod) {\n      // copy war to temporary directory\n      File warTmpDir =\n          new SecureDirectory(ctx.getTempDir(), \"war-copy-\" + appName + ctx.random().nextInt());\n      warTmpDir.mkdir();\n      String tmpPath = (new File(warTmpDir, appName + \".war\")).getAbsolutePath();\n      if (!FileUtil.copy(warPath, tmpPath, true))\n        throw new IOException(\"Web app failed copy from \" + warPath + \" to \" + tmpPath);\n      warPath = tmpPath;\n    }\n\n    WebAppContext wac = new WebAppContext(warPath, \"/\" + appName);\n    tmpdir.mkdir();\n    wac.setTempDirectory(tmpdir);\n    // all the JSPs are precompiled, no need to extract\n    // UNLESS it's a plugin and we want to scan it for annotations.\n    // We do not use Servlet 3.0 for any built-in wars.\n    // Jetty bug - annotation scanning fails unless we extract the war:\n    // org.eclipse.jetty.server.Server: Skipping scan on invalid file\n    // jar:file:/home/.../i2p/webapps/routerconsole.war!/WEB-INF/classes/net/i2p/router/web/servlets/CodedIconRendererServlet.class\n    // See AnnotationParser.isValidClassFileName()\n    // Server must be at DEBUG level to see what's happening\n    boolean scanAnnotations = HAS_ANNOTATION_CLASSES && !BUILTINS.contains(appName);\n    // System.out.println(\"Scanning \" + appName + \" for annotations? \" + scanAnnotations);\n    wac.setExtractWAR(scanAnnotations);\n\n    // this does the passwords...\n    RouterConsoleRunner.initialize(ctx, wac);\n    setWebAppConfiguration(wac, scanAnnotations);\n    server.addHandler(wac);\n    server.mapContexts();\n    return wac;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2070, "initialization": ["File file = new File(File,String)", "File file = new File(File,*)"], "initializationStart": [588, 717], "initializationEnd": [621, 758], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 818, "focalAPIEnd": 835, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MarkBennett/dart/tree/master/editor/tools/plugins/com.google.dart.tools.core_test/src/com/google/dart/tools/core/test/util/FileUtilities.java", "rawCode": "  /**\n   * Return a directory with the given name in the given base directory. If the directory did not\n   * already exist it will be created. If there is a file of the same name in the base directory,\n   * then the directory name will be made unique by appending an integer to the base name.\n   *\n   * @return a directory with the given name in the given base directory\n   * @throws SecurityException if the directory cannot be accessed or created\n   */\n  public static File getOrCreateDirectory(File baseDirectory, String baseName) {\n    File directory;\n    int index;\n\n    directory = new File(baseDirectory, baseName);\n    index = 1;\n    while (directory.exists() && !directory.isDirectory()) {\n      directory = new File(baseDirectory, baseName + index);\n      index++;\n    }\n    if (!directory.exists()) {\n      directory.mkdir();\n    }\n    return directory;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2071, "initialization": ["File file = new File(String)"], "initializationStart": [56], "initializationEnd": [71], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 163, "focalAPIEnd": 172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [475], "useEnd": [507], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/ej3.java", "rawCode": "  public static void main(String[] args) {\n    File d = new File(\"ej3\");\n    File f1 = new File(d, \"fichero1.txt\");\n    File f2 = new File(d, \"fichero2.txt\");\n    d.mkdir();\n    try {\n      if (f1.createNewFile()) {\n        System.out.println(\"Fichero creado\");\n      }\n      if (f2.createNewFile()) {\n        System.out.println(\"Fichero creado\");\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    if (f1.exists() && f2.exists()) {\n      f1.renameTo(new File(d, \"nuevofichero1.txt\"));\n      f2.delete();\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2072, "initialization": ["File file = new File(*,String)"], "initializationStart": [95], "initializationEnd": [127], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 144, "focalAPIEnd": 156, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(var)", "new File(file,String)", "new File(file,String)"], "useStart": [133, 279, 366], "useEnd": [157, 302, 389], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zeph/grinder/tree/master/source/tests-src/net/grinder/console/swingui/TestFileTreeModel.java", "rawCode": "  public void testRefreshChangedDirectoriesListener() throws Exception {\n    final File dir1 = new File(getDirectory(), \"dir1\");\n    assertTrue(dir1.mkdir());\n    final File file1 = new File(getDirectory(), \"file1\");\n    assertTrue(file1.createNewFile());\n    final File file2 = new File(dir1, \"file2\");\n    assertTrue(file2.createNewFile());\n    final File file3 = new File(dir1, \"file3\");\n    assertTrue(file3.createNewFile());\n\n    final FileTreeModel fileTreeModel =\n        new FileTreeModel(m_editorModel, m_nullFileFilter, getDirectory());\n    fileTreeModel.setRootDirectory(getDirectory());\n\n    final RandomStubFactory<TreeModelListener> listenerStubFactory =\n        RandomStubFactory.create(TreeModelListener.class);\n    final TreeModelListener listener = listenerStubFactory.getStub();\n    fileTreeModel.addTreeModelListener(listener);\n\n    final FileChangeWatcher.FileChangedListener filesChangedListener =\n        fileTreeModel.new RefreshChangedDirectoriesListener();\n\n    filesChangedListener.filesChanged(new File[0]);\n    listenerStubFactory.assertNoMoreCalls();\n\n    filesChangedListener.filesChanged(\n        new File[] {\n          file2, dir1,\n        });\n    listenerStubFactory.assertSuccess(\"treeStructureChanged\", TreeModelEvent.class);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2073, "initialization": ["File file = new File(String)"], "initializationStart": [755], "initializationEnd": [783], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 814, "focalAPIEnd": 823, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cfeclipse/cfeclipse/tree/master/org.cfeclipse.cfml.snippets/src/org/cfeclipse/cfml/snippets/SnippetPlugin.java", "rawCode": "  public void start(BundleContext context) throws Exception {\n    super.start(context);\n    CFPluginImages.initCFPluginImages();\n    this.propertyStore =\n        new PreferenceStore(\n            SnippetPlugin.getDefault().getStateLocation().toString() + \"/properties.ini\");\n    fPreferenceManager = new CFMLPreferenceManager();\n    try {\n      fPropertyManager = new CFMLPropertyManager();\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.out.println(e);\n    }\n    getWorkbench()\n        .getActiveWorkbenchWindow()\n        .getSelectionService()\n        .addSelectionListener(fPropertyManager.getListener());\n\n    String defaultSnippetPath =\n        SnippetPlugin.getDefault().getStateLocation().toString() + \"/snippets\";\n    File f = new File(defaultSnippetPath);\n    if (!f.exists()) {\n      f.mkdir();\n    }\n    plugin = this;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2074, "initialization": ["File file = new File(File,String)"], "initializationStart": [120], "initializationEnd": [140], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(file.exists()&&file.isDirectory()&&file.canWrite())", "guardType": "IF {", "guardExpressionStart": 147, "guardExpressionEnd": 215, "guardBlockStart": 147, "guardBlockEnd": 245, "focalAPI": "var = file.mkdir()", "focalAPIStart": 224, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [257], "useEnd": [279], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bulldog2011/nano/tree/master/sample/binding/nano-and-android/src/com/leansoft/nano/sample/AbstractTask.java", "rawCode": "  File getFile(String dir, String file) {\n    File sdDir = Environment.getExternalStorageDirectory();\n    File appDir = new File(sdDir, dir);\n\n    if (!(appDir.exists() && appDir.isDirectory() && appDir.canWrite())) {\n      appDir.mkdir();\n    }\n    return new File(appDir, file);\n  }\n"}, {"dataset": "mkdir", "exampleID": 2075, "initialization": ["File file = new File(String,String)"], "initializationStart": [85], "initializationEnd": [116], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 160, "focalAPIEnd": 178, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [207], "useEnd": [237], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/minnymin3/Zephyrus/tree/master/Zephyrus-WizardPaths/src/main/java/net/lordsofcode/zephyrus/paths/util/ConfigHandler.java", "rawCode": "  public void reloadConfig() {\n    if (configFile == null) {\n      File dataFolder = new File(\"plugins\", \"Zephyrus\");\n      if (!dataFolder.exists()) {\n        dataFolder.mkdir();\n      }\n      configFile = new File(dataFolder, fileName);\n    }\n    fileConfiguration = YamlConfiguration.loadConfiguration(configFile);\n\n    InputStream defConfigStream = plugin.getResource(fileName);\n    if (defConfigStream != null) {\n      YamlConfiguration defConfig = YamlConfiguration.loadConfiguration(defConfigStream);\n      fileConfiguration.setDefaults(defConfig);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2076, "initialization": ["File file = new File(*)"], "initializationStart": [143], "initializationEnd": [174], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 282, "focalAPIEnd": 291, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new FileOutputStream(file)", "file.setReadable(boolean)", "file.setWritable(boolean)", "file.setExecutable(boolean)"], "useStart": [339, 712, 756, 801], "useEnd": [362, 748, 793, 839], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SBasalaev/alchemy-os/tree/master/arh/src/org/alchemy/arh/Main.java", "rawCode": "  /** Unpacks archive. */\n  private static void unarh(DataInputStream in) throws IOException {\n    while (in.available() > 0) {\n      File f = new File(arhpath(in.readUTF()));\n      in.skipBytes(8);\n      int attrs = in.readUnsignedByte();\n      if ((attrs & A_DIR) != 0) {\n        f.mkdir();\n      } else {\n        FileOutputStream out = new FileOutputStream(f);\n        int len = in.readInt();\n        if (len > 0) {\n          byte[] buf = new byte[4096];\n          while (len > 4096) {\n            in.read(buf);\n            out.write(buf);\n            len -= 4096;\n          }\n          in.read(buf, 0, len);\n          out.write(buf, 0, len);\n        }\n        out.flush();\n        out.close();\n      }\n      f.setReadable((attrs & A_READ) != 0);\n      f.setWritable((attrs & A_WRITE) != 0);\n      f.setExecutable((attrs & A_EXEC) != 0);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2077, "initialization": ["File file = new File(*,String)"], "initializationStart": [162], "initializationEnd": [206], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 223, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(var)", "new File(file,String)", "new File(file,String)", "file.getAbsolutePath()"], "useStart": [212, 256, 306, 496], "useEnd": [239, 280, 331, 521], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-hdfs-project/hadoop-hdfs-httpfs/src/test/java/org/apache/hadoop/lib/server/TestServer.java", "rawCode": "  @Test\n  @TestException(exception = ServerException.class, msgRegExp = \"S01.*\")\n  @TestDir\n  public void initNoConfigDir() throws Exception {\n    File homeDir = new File(TestDirHelper.getTestDir(), \"home\");\n    assertTrue(homeDir.mkdir());\n    assertTrue(new File(homeDir, \"log\").mkdir());\n    assertTrue(new File(homeDir, \"temp\").mkdir());\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", TestService.class.getName());\n    Server server = new Server(\"server\", homeDir.getAbsolutePath(), conf);\n    server.init();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2078, "initialization": ["File file = new File(File,*)"], "initializationStart": [1081], "initializationEnd": [1110], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.getCanonicalFile()"], "configurationStart": [1176], "configurationEnd": [1201], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1258, "focalAPIEnd": 1272, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeStreamToFile(InputStream,file)"], "useStart": [1354], "useEnd": [1402], "hasFinally": 1, "cleanUpCall": ["ZipFile.close()"], "finallyExpressionStart": 1459, "finallyExpressionEnd": 1467, "finallyBlockStart": 1459, "finallyBlockEnd": 1608, "cleanUpCallStart": [1507], "cleanUpCallEnd": [1523], "url": "https://github.com/bitrepository/reference/tree/master/bitrepository-core/src/main/java/org/bitrepository/common/utils/FileUtils.java", "rawCode": "  /**\n   * Unzip a zipFile into a directory. This will create subdirectories as needed.\n   *\n   * @param zipFile The file to unzip\n   * @param toDir The directory to create the files under. This directory will be created if\n   *     necessary. Files in it will be overwritten if the filenames match.\n   * @throws IOException If any error occurs while writing the stream to a file\n   */\n  public static void unzip(File zipFile, File toDir) throws IOException {\n    ArgumentValidator.checkNotNull(zipFile, \"File zipFile\");\n    ArgumentValidator.checkNotNull(toDir, \"File toDir\");\n    ArgumentValidator.checkTrue(\n        toDir.getAbsoluteFile().getParentFile().canWrite(), \"can't write to '\" + toDir + \"'\");\n    ArgumentValidator.checkTrue(zipFile.canRead(), \"can't read '\" + zipFile + \"'\");\n    InputStream inputStream = null;\n    ZipFile unzipper = null;\n    try {\n      unzipper = new ZipFile(zipFile);\n      Enumeration<? extends ZipEntry> entries = unzipper.entries();\n      while (entries.hasMoreElements()) {\n        ZipEntry ze = entries.nextElement();\n        File target = new File(toDir, ze.getName());\n        // Ensure that its dir exists\n        retrieveDirectory(target.getCanonicalFile().getParent());\n        if (ze.isDirectory()) {\n          target.mkdir();\n        } else {\n          inputStream = unzipper.getInputStream(ze);\n          FileUtils.writeStreamToFile(inputStream, target);\n          inputStream.close();\n        }\n      }\n    } finally {\n      if (unzipper != null) {\n        unzipper.close();\n      }\n      if (inputStream != null) {\n        inputStream.close();\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2079, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 136, "focalAPIEnd": 146, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,*)", "copyFile(File,file)", "new File(file,*)", "new FileOutputStream(file)"], "useStart": [439, 520, 667, 788], "useEnd": [464, 535, 695, 812], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MiniSEC/adito_reload/tree/master/adito/branches/openvpn-als/agent/common/net/openvpn/als/agent/client/util/Utils.java", "rawCode": "  public static void copyFile(File from, File to) throws IOException {\n\n    if (from.isDirectory()) {\n      if (!to.exists()) {\n        to.mkdir();\n      }\n      String[] children = from.list();\n      for (int i = 0; i < children.length; i++) {\n        File f = new File(from, children[i]);\n        if (f.getName().equals(\".\") || f.getName().equals(\"..\")) {\n          continue;\n        }\n        if (f.isDirectory()) {\n          File f2 = new File(to, f.getName());\n          copyFile(f, f2);\n        } else {\n          copyFile(f, to);\n        }\n      }\n    } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n      if (to.isDirectory()) {\n        to = new File(to, from.getName());\n      }\n      FileInputStream in = new FileInputStream(from);\n      FileOutputStream out = new FileOutputStream(to);\n      byte[] buf = new byte[32678];\n      int read;\n      while ((read = in.read(buf)) > -1) {\n        out.write(buf, 0, read);\n      }\n      closeStream(in);\n      closeStream(out);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2080, "initialization": ["File file = new File(String)"], "initializationStart": [552], "initializationEnd": [578], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 612, "focalAPIEnd": 632, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arpanghosh/twitter_research/tree/master/relevance_filter/src/main/java/com/edge/twitter_research/relevance_filter/LogisticRegressionTweetRelevanceFilterLanguage.java", "rawCode": "  public static void main(String[] args) {\n\n    if (args.length < 1) {\n      System.out.println(\"usage: LogisticRegressionTweetRelevanceFilterLanguage <root_path>\");\n      System.exit(-1);\n    }\n\n    String rootPath = args[0];\n    File dataFolder = new File(rootPath + \"/data/language\");\n    String resultFolderPath = rootPath + \"/results/language/LogisticRegression/\";\n\n    CrisisMailer crisisMailer = CrisisMailer.getCrisisMailer();\n    Logger logger = Logger.getLogger(LogisticRegressionTweetRelevanceFilterLanguage.class);\n\n    File resultFolder = new File(resultFolderPath);\n    if (!resultFolder.exists()) resultFolder.mkdir();\n\n    CSVLoader csvLoader = new CSVLoader();\n\n    try {\n      for (File dataSetName : dataFolder.listFiles()) {\n\n        Instances data = null;\n        try {\n          csvLoader.setSource(dataSetName);\n          csvLoader.setNominalAttributes(\"22\");\n          data = csvLoader.getDataSet();\n\n        } catch (IOException ioe) {\n          logger.error(ioe);\n          crisisMailer.sendEmailAlert(ioe);\n          System.exit(-1);\n        }\n\n        data.setClassIndex(data.numAttributes() - 1);\n        data.deleteWithMissingClass();\n        data.deleteAttributeAt(0);\n\n        FileOutputStream resultOutputStream =\n            new FileOutputStream(new File(resultFolderPath + dataSetName.getName()));\n\n        resultOutputStream.write(data.toSummaryString().getBytes());\n\n        SimpleLogistic logisticRegressionClassifier = new SimpleLogistic();\n\n        try {\n          Evaluation eval = new Evaluation(data);\n          eval.crossValidateModel(\n              logisticRegressionClassifier, data, 5, new Random(System.currentTimeMillis()));\n\n          resultOutputStream.write(eval.toSummaryString(\"=== Summary ===\", false).getBytes());\n          resultOutputStream.write(eval.toMatrixString().getBytes());\n          resultOutputStream.write(eval.toClassDetailsString().getBytes());\n          resultOutputStream.close();\n\n        } catch (Exception exception) {\n          logger.error(exception);\n          crisisMailer.sendEmailAlert(exception);\n          System.exit(-1);\n        }\n      }\n    } catch (Exception exception) {\n      logger.error(exception);\n      crisisMailer.sendEmailAlert(exception);\n      System.out.println(-1);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2081, "initialization": ["File file = new File(String)"], "initializationStart": [347], "initializationEnd": [363], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 369, "focalAPIEnd": 380, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["deleteDirectory(file)"], "useStart": [619], "useEnd": [649], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/mylyn.reviews.r4e/tree/master/org.eclipse.mylyn.reviews.r4e.core.tests/src/org/eclipse/mylyn/reviews/r4e/core/utils/filePermission/OSPermissionTest.java", "rawCode": "  /** Run the boolean changePermission(String) method test */\n  public void testChangePermissionFailed() {\n    // add test code here\n    String base = System.getProperty(\"java.io.tmpdir\");\n    if (!base.endsWith(File.separator)) {\n      base = base + File.separator;\n    }\n    String dirStr = base + \"PermDirTest\" + File.separator;\n    File dir = new File(dirStr);\n    dir.mkdir();\n\n    try {\n      assertFalse(perm.grantWritePermission(dirStr + \"1\"));\n    } catch (IOException e) {\n      Activator.fTracer.traceDebug(\n          \"IOException received as expected, the directory does not exist\");\n    }\n\n    try {\n      FileUtils.deleteDirectory(dir);\n    } catch (IOException e) {\n      e.printStackTrace();\n      fail(\"Exception\");\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2082, "initialization": ["File file = new File(String)"], "initializationStart": [46], "initializationEnd": [123], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 129, "focalAPIEnd": 141, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RebelKeithy/Metallurgy/tree/master/common/shadow/mods/metallurgy/base/ConfigBase.java", "rawCode": "  public static void init() {\n    File file = new File(MetallurgyBaseMetals.proxy.getMinecraftDir() + \"/config/Metallurgy\");\n    file.mkdir();\n    File newFile =\n        new File(\n            MetallurgyBaseMetals.proxy.getMinecraftDir() + \"/config/Metallurgy/MetallurgyBase.cfg\");\n\n    try {\n      newFile.createNewFile();\n      System.out.println(\"Successfully created/read configuration file\");\n    } catch (IOException e) {\n      System.out.println(\"Could not create configuration file for mod_MetallugyBase. Reason:\");\n      System.out.println(e);\n    }\n\n    /* [Forge] Configuration class, used as config method */\n    Configuration config = new Configuration(newFile);\n\n    /* Load the configuration file */\n    config.load();\n\n    baseMetalsVeinID = config.getBlock(\"Metal Ore\", 901).getInt(900);\n    baseMetalsBrickID = config.getBlock(\"Metal Brick\", 902).getInt(901);\n    baseAlloysBrickID = config.getBlock(\"Alloy Brick\", 903).getInt(902);\n    baseMetalsBlockID = config.getBlock(\"Metal Block\", 929).getInt(929);\n    baseAlloysBlockID = config.getBlock(\"Alloy Block\", 930).getInt(930);\n    doorID = config.getBlock(\"Copper Door\", 935).getInt(935);\n\n    furnaceID = config.getBlock(\"Furnace\", 904).getInt(904);\n    itemDoorID = config.getItem(\"Copper Door\", 926).getInt(9350);\n\n    dimensions = config.get(\"Dimensions\", \"Dimensions\", \"0 2-10000\").value;\n\n    furnacesEnabled = config.get(\"Machines\", \"Enable Furnaces\", true).getBoolean(true);\n    railsEnabled = config.get(\"Machines\", \"Enable Rail Recipes\", true).getBoolean(true);\n\n    copperSpeed = config.get(\"Furnaces\", \"Copper Speed\", 9500).getInt(9500) / 1000f;\n    bronzeSpeed = config.get(\"Furnaces\", \"Bronze Speed\", 9000).getInt(9000) / 1000f;\n    ironSpeed = config.get(\"Furnaces\", \"Iron Speed\", 8000).getInt(8000) / 1000f;\n    steelSpeed = config.get(\"Furnaces\", \"Steel Speed\", 7000).getInt(7000) / 1000f;\n\n    for (int i = 0; i < 5; i++)\n      alloyEnabled[i] =\n          config.get(\"Ores\", AlloyBaseEnum.names[i] + \" Enabled\", true).getBoolean(true);\n    for (int i = 0; i < 3; i++)\n      metalEnabled[i] =\n          config.get(\"Ores\", OreBaseEnum.names[i] + \" Enabled\", true).getBoolean(true);\n\n    ItemStartID = config.get(\"Item Ids Uses next 250\", \"Item Start IDs\", 26250).getInt(26250);\n    balkonsIDs = config.get(\"Balkons Ids Uses next 36\", \"Balkons Start IDs\", 29000).getInt(29000);\n\n    lanternId = config.getBlock(\"Lantern\", 2016).getInt(2016);\n    ladderId = config.getBlock(\"Ladder\", 2011).getInt(2011);\n    glassDustId = config.getItem(\"Glass Dust\", 2012).getInt(2012);\n    coloredGlassId = config.getBlock(\"Colored Glass\", 2013).getInt(2013);\n\n    for (int i = 0; i < 3; i++) {\n      VeinCount[i] =\n          config\n              .get(\n                  \"Ore Generation\",\n                  OreBaseEnum.names[i] + \" Vein Count\",\n                  OreBaseEnum.defaultVeinCount[i])\n              .getInt(OreBaseEnum.defaultVeinCount[i]);\n      OreCount[i] =\n          config\n              .get(\n                  \"Ore Generation\",\n                  OreBaseEnum.names[i] + \" Ore Count\",\n                  OreBaseEnum.defaultOreCount[i])\n              .getInt(OreBaseEnum.defaultOreCount[i]);\n      OreHeight[i] =\n          config\n              .get(\n                  \"Ore Generation\",\n                  OreBaseEnum.names[i] + \" Height\",\n                  OreBaseEnum.defaultOreHeight[i])\n              .getInt(OreBaseEnum.defaultOreHeight[i]);\n      OreMinHeight[i] =\n          config.get(\"Ore Generation\", OreBaseEnum.names[i] + \" Minimum Height\", 0).getInt(0);\n    }\n\n    config.save();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2083, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.getAbsolutePath()"], "configurationStart": [239], "configurationEnd": [265], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 279, "focalAPIEnd": 295, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-tests/src/test/java/org/apache/hadoop/yarn/server/TestContainerManagerSecurity.java", "rawCode": "  @BeforeClass\n  public static void setup()\n      throws AccessControlException, FileNotFoundException, UnsupportedFileSystemException,\n          IOException {\n    localFS = FileContext.getLocalFSFileContext();\n    localFS.delete(new Path(localDir.getAbsolutePath()), true);\n    localDir.mkdir();\n\n    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION, \"kerberos\");\n    // Set AM expiry interval to be very long.\n    conf.setLong(YarnConfiguration.RM_AM_EXPIRY_INTERVAL_MS, 100000L);\n    UserGroupInformation.setConfiguration(conf);\n    yarnCluster = new MiniYARNCluster(TestContainerManagerSecurity.class.getName(), 1, 1, 1);\n    yarnCluster.init(conf);\n    yarnCluster.start();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2084, "initialization": ["File file = new File(File,*)"], "initializationStart": [396], "initializationEnd": [424], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 432, "focalAPIEnd": 446, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/test/java/org/apache/hadoop/yarn/util/TestProcfsBasedProcessTree.java", "rawCode": "  /**\n   * Create PID directories under the specified procfs root directory\n   *\n   * @param procfsRootDir root directory of procfs file system\n   * @param pids the PID directories to create.\n   * @throws IOException If PID dirs could not be created\n   */\n  public static void setupPidDirs(File procfsRootDir, String[] pids) throws IOException {\n    for (String pid : pids) {\n      File pidDir = new File(procfsRootDir, pid);\n      pidDir.mkdir();\n      if (!pidDir.exists()) {\n        throw new IOException(\"couldn't make process directory under \" + \"fake procfs\");\n      } else {\n        LOG.info(\"created pid dir\");\n      }\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2085, "initialization": ["File file = new File(*)"], "initializationStart": [106], "initializationEnd": [133], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 83, "tryExpressionEnd": 87, "tryBlockStart": 83, "tryBlockEnd": 1177, "catchExpressionStart": 263, "catchExpressionEnd": 283, "catchBlockStart": 263, "catchBlockEnd": 325, "exceptionHandlingCallStart": [295], "exceptionHandlingCallEnd": [314], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 170, "focalAPIEnd": 181, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getAbsolutePath()"], "useStart": [383], "useEnd": [404], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vedina/RESTNet/tree/master/restnet-sparql/src/main/java/net/idea/restnet/sparql/TripleStoreResource.java", "rawCode": "  protected Model createOntologyModel(boolean init) throws ResourceException {\n    try {\n      File dir = new File(getTDBDirectory());\n      if (!dir.exists()) {\n        dir.mkdir();\n        try {\n          new File(dir + \"/fixed.opt\").createNewFile();\n        } catch (Exception x) {\n          x.printStackTrace();\n        }\n      }\n      Dataset dataset = TDBFactory.createDataset(dir.getAbsolutePath());\n      Model ontology = dataset.getDefaultModel();\n      if (init && (ontology.size() == 0)) readOntologies(ontology);\n      ontology.setNsPrefix(\"ot\", \"http://www.opentox.org/api/1.1#\");\n      ontology.setNsPrefix(\"ota\", \"http://www.opentox.org/algorithmTypes.owl#\");\n      ontology.setNsPrefix(\"otee\", \"http://www.opentox.org/echaEndpoints.owl#\");\n      ontology.setNsPrefix(\"owl\", OWL.NS);\n      ontology.setNsPrefix(\"dc\", DC.NS);\n      ontology.setNsPrefix(\"bx\", \"http://purl.org/net/nknouf/ns/bibtex#\");\n      ontology.setNsPrefix(\n          \"bo\", \"http://www.blueobelisk.org/ontologies/chemoinformatics-algorithms/#\");\n\n      return ontology;\n    } catch (ResourceException x) {\n      throw x;\n    } catch (Exception x) {\n      throw new ResourceException(x);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2086, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.getParentFile()"], "configurationStart": [121], "configurationEnd": [140], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 180, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jbcpollak/UrlRewriteFilter/tree/master/src/annotation/java/org/tuckey/web/filters/urlrewrite/annotation/UrlRewriteAnnotationProcessor.java", "rawCode": "  private static void checkDirsExistMkdir(File dir) {\n    if (!dir.getParentFile().exists()) {\n      checkDirsExistMkdir(dir.getParentFile());\n    }\n    if (!dir.exists()) {\n      dir.mkdir();\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2087, "initialization": ["File file = createTempFile(*,String)"], "initializationStart": [271], "initializationEnd": [322], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 352, "focalAPIEnd": 367, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stain/alibaba/tree/master/query-repository/src/test/java/org/openrdf/repository/query/DelegatingNamedQueryRepositoryTest.java", "rawCode": "  private File createTempDir() throws IOException {\n    String tmpDirStr = System.getProperty(\"java.io.tmpdir\");\n    if (tmpDirStr != null) {\n      File tmpDir = new File(tmpDirStr);\n      if (!tmpDir.exists()) {\n        tmpDir.mkdirs();\n      }\n    }\n    File dataDir = File.createTempFile(getClass().getSimpleName(), \"\");\n    deleteDir(dataDir);\n    dataDir.mkdir();\n    return dataDir;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2088, "initialization": ["File file = new File(*,String)"], "initializationStart": [235], "initializationEnd": [304], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 310, "focalAPIEnd": 334, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.getAbsolutePath()", "JFileChooser.setCurrentDirectory(file)"], "useStart": [361, 465], "useEnd": [395, 514], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/martinb3/egonet/tree/master/src/main/java/org/egonet/gui/interview/ClientFrame.java", "rawCode": "  void saveGraphSettings_actionPerformed(ActionEvent e) {\n    String name = egoClient.getStorage().getInterviewFile().getName();\n    String fileName = \"/\" + name.replace(\".int\", \"\") + \".xml\";\n\n    final File currentDirectory =\n        new File(egoClient.getStorage().getStudyFile().getParent(), \"Graphs\");\n    currentDirectory.mkdir();\n    File file = new File(currentDirectory.getAbsolutePath() + fileName);\n\n    JFileChooser fileChooser = new JFileChooser();\n    fileChooser.setCurrentDirectory(currentDirectory);\n    fileChooser.setSelectedFile(new File(fileName));\n    fileChooser.setDialogTitle(\"Save Graph Settings\");\n    fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\n    fileChooser.setSelectedFile(file);\n\n    ExtensionFileFilter filter = new ExtensionFileFilter(\"Graph Settings\", \"xml\");\n    fileChooser.addChoosableFileFilter(filter);\n\n    int returnValue = fileChooser.showSaveDialog(this);\n    if (returnValue == JFileChooser.APPROVE_OPTION) {\n      File settingsFile = fileChooser.getSelectedFile();\n\n      GraphRenderer.getGraphSettings().saveSettingsFile(settingsFile);\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2089, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 98, "focalAPIEnd": 115, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,*)", "file.delete()"], "useStart": [1503, 3323], "useEnd": [1537, 3341], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codecop/eclipse-babel-plugins/tree/master/org.eclipse.babel.build.core/src/org/eclipse/babel/build/core/languagepack/NonJarNLFragment.java", "rawCode": "  public PluginCoverageInformation generateFragment(Configuration config) throws Exception {\n\n    directory.mkdir();\n\n    TranslationCatalogue translationCatalogue = config.translations();\n    Set<LocaleProxy> locales = config.locales();\n\n    // An empty list of locales means all of them should be parsed\n    if (locales.isEmpty() && config.localeGroups().isEmpty()) {\n      locales.addAll(translationCatalogue.getAllLocales());\n    }\n\n    Map<String, PluginProxy> translationCataloguePluginMap =\n        getPluginOrFeatureForSpecifiedLocales(config, eclipseInstallPlugin);\n\n    boolean pluginIsMatchedToAnyLocale = false;\n\n    PluginCoverageInformation coverage = new PluginCoverageInformation(eclipseInstallPlugin);\n\n    try {\n      for (LocaleProxy locale : locales) {\n        // Start by inspecting the plug-ins\n        boolean pluginIsMatchedToThisLocale =\n            translationCataloguePluginMap.containsKey(locale.getName());\n\n        if (pluginIsMatchedToThisLocale) {\n          PluginProxy translationCataloguePlugin =\n              translationCataloguePluginMap.get(locale.getName());\n          pluginIsMatchedToAnyLocale = true;\n\n          // For all the resources of the plug-in from the eclipse\n          // archive\n          for (ResourceProxy resource : eclipseInstallPlugin.getResources()) {\n            // If the resource is the Manifest file\n            if (resource.getRelativePath().equalsIgnoreCase(MANIFEST_PATH)) {\n              FileOutputStream fileOut = new FileOutputStream(new File(directory, MANIFEST_PATH));\n              Manifest manifest = composeManifestContent(config.localeExtension());\n              manifest.write(fileOut);\n            } else {\n              // Retrieve the translation resource\n              ResourceProxy translationResource =\n                  translationCatalogue.getResourceTranslation(translationCataloguePlugin, resource);\n\n              /*\n               * Write the resource... if the object is not null,\n               * that means that a corresponding resource was\n               * found in the TranslationArchive\n               */\n              if (translationResource != null) {\n                writeResource(eclipseInstallPlugin, translationResource, locale);\n\n                // TODO: Look for percentage of coverage for\n                // property files only\n                if (resource\n                    .getRelativePath()\n                    .endsWith(Messages.getString(\"Extensions_properties\"))) { // $NON-NLS-1$\n\n                  int value =\n                      computePropertyCoverageForLocale(config, resource, translationResource);\n                  coverage.setResourceCoverageForLocale(locale, resource, true, value);\n                } else {\n                  // Mark that this resource has been matched\n                  // for this locale\n                  coverage.setResourceCoverageForLocale(locale, resource, true);\n                }\n              } else {\n                // Mark that this resource has NOT been matched\n                // for this locale\n                coverage.setResourceCoverageForLocale(locale, resource, false);\n              }\n            }\n          }\n        }\n        coverage.setPluginMatchingForLocale(locale, pluginIsMatchedToThisLocale);\n      }\n\n      if (!pluginIsMatchedToAnyLocale) {\n        directory.delete();\n      }\n\n      if (bundleClasspathStream != null) {\n        bundleClasspathStream.close();\n      }\n    } catch (IOException e) {\n      System.out.println(e.getMessage());\n      e.printStackTrace();\n    }\n\n    return coverage;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2090, "initialization": ["File file = new File(String,String)"], "initializationStart": [557], "initializationEnd": [582], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 809, "focalAPIEnd": 823, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(file,String)"], "useStart": [851], "useEnd": [885], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rachitpant/UAlbany-Client/tree/master/src/plugins/sip/src/java/net/java/sipmack/media/JmfMediaManager.java", "rawCode": "  /**\n   * Runs JMFInit the first time the application is started so that capture devices are properly\n   * detected and initialized by JMF.\n   */\n  public static void setupJMF() {\n    // .jmf is the place where we store the jmf.properties file used\n    // by JMF. if the directory does not exist or it does not contain\n    // a jmf.properties file. or if the jmf.properties file has 0 length\n    // then this is the first time we're running and should continue to\n    // with JMFInit\n    String homeDir = System.getProperty(\"user.home\");\n    File jmfDir = new File(homeDir, \".jmf\");\n    String classpath = System.getProperty(\"java.class.path\");\n    classpath += System.getProperty(\"path.separator\") + jmfDir.getAbsolutePath();\n    System.setProperty(\"java.class.path\", classpath);\n\n    if (!jmfDir.exists()) jmfDir.mkdir();\n\n    File jmfProperties = new File(jmfDir, \"jmf.properties\");\n\n    if (!jmfProperties.exists()) {\n      try {\n        jmfProperties.createNewFile();\n      } catch (IOException ex) {\n        System.out.println(\"Failed to create jmf.properties\");\n        ex.printStackTrace();\n      }\n    }\n\n    // if we're running on linux checkout that libjmutil.so is where it\n    // should be and put it there.\n    runLinuxPreInstall();\n\n    // if (jmfProperties.length() == 0) {\n    new JMFInit(null, false);\n    // }\n\n  }\n"}, {"dataset": "mkdir", "exampleID": 2091, "initialization": ["File file = new File(*,String)"], "initializationStart": [189], "initializationEnd": [213], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 219, "focalAPIEnd": 235, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/rt.equinox.p2/tree/master/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/reconciler/dropins/SharedInstallTests.java", "rawCode": "  protected void setupReadOnlyInstall() {\n    readOnlyBase = new File(output, getRootFolder());\n    assertTrue(readOnlyBase.canWrite());\n    setReadOnly(readOnlyBase, true);\n    userBase = new File(output, \"user\");\n    userBase.mkdir();\n  }\n"}, {"dataset": "mkdir", "exampleID": 2092, "initialization": ["File file = new File(String,String)"], "initializationStart": [180], "initializationEnd": [207], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 213, "focalAPIEnd": 228, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addMembers(file,Map<ClassFile, List<Method>>)"], "useStart": [602], "useEnd": [630], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openjdk-mirror/jdk7u-langtools/tree/master/test/tools/javac/generics/OverrideBridge.java", "rawCode": "  static Map<ClassFile, List<Method>> compile(\n      Implementation implB, Implementation implC, Implementation implD, String destPath)\n      throws Exception {\n    File destDir = new File(workDir, destPath);\n    destDir.mkdir();\n    final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();\n    JavaSource source = new JavaSource(implB, implC, implD);\n    JavacTask ct =\n        (JavacTask)\n            tool.getTask(\n                null, null, null, Arrays.asList(\"-d\", destPath), null, Arrays.asList(source));\n    ct.generate();\n    Map<ClassFile, List<Method>> members = new HashMap<>();\n    addMembers(destDir, members);\n    return members;\n  }\n"}, {"dataset": "mkdir", "exampleID": 2093, "initialization": ["File file = new File(File,String)"], "initializationStart": [647], "initializationEnd": [671], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 688, "focalAPIEnd": 702, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(var)", "new File(file,String)"], "useStart": [677, 720], "useEnd": [703, 747], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/libcore/java/io/FileTest.java", "rawCode": "  public void test_getCanonicalPath() throws Exception {\n    // This assumes you can create symbolic links in the temporary directory. This isn't\n    // true on Android if you're using /sdcard. It will work in /data/local though.\n    File base = createTemporaryDirectory();\n    File target = new File(base, \"target\");\n    target.createNewFile(); // The RI won't follow a dangling symlink, which seems like a bug!\n    File linkName = new File(base, \"link\");\n    ln_s(target, linkName);\n    assertEquals(target.getCanonicalPath(), linkName.getCanonicalPath());\n\n    // .../subdir/shorter -> .../target (using a link to ../target).\n    File subdir = new File(base, \"subdir\");\n    assertTrue(subdir.mkdir());\n    linkName = new File(subdir, \"shorter\");\n    ln_s(\"../target\", linkName.toString());\n    assertEquals(target.getCanonicalPath(), linkName.getCanonicalPath());\n\n    // .../l -> .../subdir/longer (using a relative link to subdir/longer).\n    linkName = new File(base, \"l\");\n    ln_s(\"subdir/longer\", linkName.toString());\n    File longer = new File(base, \"subdir/longer\");\n    longer.createNewFile(); // The RI won't follow a dangling symlink, which seems like a bug!\n    assertEquals(longer.getCanonicalPath(), linkName.getCanonicalPath());\n\n    // .../double -> .../target (via a link into subdir and a link back out).\n    linkName = new File(base, \"double\");\n    ln_s(\"subdir/shorter\", linkName.toString());\n    assertEquals(target.getCanonicalPath(), linkName.getCanonicalPath());\n  }\n"}, {"dataset": "mkdir", "exampleID": 2094, "initialization": ["File file = new File(*)"], "initializationStart": [661], "initializationEnd": [703], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "printStackTrace()", "stateChanged()"], "tryExpressionStart": 236, "tryExpressionEnd": 240, "tryBlockStart": 236, "tryBlockEnd": 4501, "catchExpressionStart": 2076, "catchExpressionEnd": 2096, "catchBlockStart": 2076, "catchBlockEnd": 3014, "exceptionHandlingCallStart": [4362, 4418, 4478], "exceptionHandlingCallEnd": [4408, 4437, 4492], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 830, "focalAPIEnd": 845, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new JarFile(file)", "file.getParentFile()", "new FileOutputStream(file)"], "useStart": [1081, 3288, 3705], "useEnd": [1101, 3311, 3734], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/marytts/marytts/tree/master/marytts-runtime/src/main/java/marytts/tools/install/ComponentDescription.java", "rawCode": "    public void run() {\n      String maryBase = System.getProperty(\"mary.base\");\n      System.out.println(\"Installing \" + name + \"-\" + version + \" in \" + maryBase + \"...\");\n      ArrayList<String> files = new ArrayList<String>();\n      try {\n        ZipFile zipfile = new ZipFile(archiveFile);\n        Enumeration<? extends ZipEntry> entries = zipfile.entries();\n        while (entries.hasMoreElements()) {\n          ZipEntry entry = entries.nextElement();\n          files.add(\n              entry\n                  .getName()); // add to installed filelist; rely on uninstaller retaining shared\n                               // files\n          File newFile = new File(maryBase + \"/\" + entry.getName());\n          if (entry.isDirectory()) {\n            System.err.println(\"Extracting directory: \" + entry.getName());\n            newFile.mkdir();\n          } else {\n            if (newFile.exists()) {\n              // is existing file newer?\n              boolean existingIsNewer = false;\n              try {\n                // existing JAR:\n                JarFile existingJar = new JarFile(newFile);\n                Manifest existingManifest = existingJar.getManifest();\n                String existingVersion =\n                    existingManifest.getMainAttributes().getValue(\"Specification-Version\");\n                // packaged JAR:\n                JarInputStream packagedJar = new JarInputStream(zipfile.getInputStream(entry));\n                Manifest packagedManifest = packagedJar.getManifest();\n                String packagedVersion =\n                    packagedManifest.getMainAttributes().getValue(\"Specification-Version\");\n                // compare the version strings:\n                existingIsNewer = isVersionNewerThan(existingVersion, packagedVersion);\n                if (existingIsNewer) {\n                  // if we don't overwrite a newer existing JAR, then never log it as installed,\n                  // otherwise we\n                  // lose it during uninstall!\n                  files.remove(entry.getName());\n                }\n              } catch (Exception e) {\n                // we're not dealing with a JAR file\n                // TODO disabled this block on short notice because installed files are touched and\n                // will therefore\n                // always be newer:\n                // long existingDate;\n                // // fall back to last modification time:\n                // try {\n                // existingDate = newFile.lastModified();\n                // } catch (SecurityException f) {\n                // // WTF, we can't get the date from the existing file!?\n                // e.printStackTrace();\n                // // assume it's outdated, to trigger reinstall (which may well fail):\n                // existingDate = Long.MIN_VALUE;\n                // }\n                // long packagedDate = entry.getTime();\n                // if (existingDate > packagedDate) {\n                // existingIsNewer = true;\n                // }\n              }\n              // do not overwrite existing files if they are newer:\n              if (existingIsNewer) {\n                System.err.println(\"NOT overwriting existing newer file: \" + entry.getName());\n                continue;\n              }\n            }\n            if (!newFile.getParentFile().isDirectory()) {\n              System.err.println(\n                  \"Creating directory tree: \" + newFile.getParentFile().getAbsolutePath());\n              newFile.getParentFile().mkdirs();\n            }\n            System.err.println(\"Extracting file: \" + entry.getName());\n            copyInputStream(\n                zipfile.getInputStream(entry),\n                new BufferedOutputStream(new FileOutputStream(newFile)));\n            // better hack: try to set executable bit on files in bin/\n            if (entry.getName().startsWith(\"bin/\")) {\n              try {\n                if (newFile.setExecutable(true, false)) {\n                  System.err.println(\"Setting executable bit on file: \" + entry.getName());\n                }\n              } catch (SecurityException e) {\n                e.printStackTrace(); // but ignore\n              }\n            }\n          }\n        }\n        zipfile.close();\n        installedFilesNames = StringUtils.join(files, \", \");\n        writeInstalledComponentXML();\n      } catch (Exception e) {\n        System.err.println(\"... installation failed:\");\n        e.printStackTrace();\n        status = Status.ERROR;\n        stateChanged();\n      }\n      System.err.println(\"...done\");\n      status = Status.INSTALLED;\n      stateChanged();\n    }\n"}, {"dataset": "mkdir", "exampleID": 2095, "initialization": ["File file = new File(*)"], "initializationStart": [1066], "initializationEnd": [1108], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 1146, "focalAPIEnd": 1169, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["file.listFiles()", "deleteDir(file)"], "useStart": [1604, 1799], "useEnd": [1631, 1825], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jarodwen/hyracks/tree/master/fullstack/hivesterix/hivesterix-dist/src/test/java/edu/uci/ics/hivesterix/perf/PerfTestCase.java", "rawCode": "  @Test\n  public void testRuntimeFunction() throws Exception {\n    StringBuilder queryString = new StringBuilder();\n    readFileToString(queryFile, queryString);\n    String[] queries = queryString.toString().split(\";\");\n    StringWriter sw = new StringWriter();\n\n    HiveConf hconf = ConfUtil.getHiveConf();\n    Driver driver = new Driver(hconf, new PrintWriter(sw));\n    driver.init();\n\n    dfs = FileSystem.get(ConfUtil.getJobConf());\n\n    int i = 0;\n    for (String query : queries) {\n      if (i == queries.length - 1) break;\n      driver.run(query);\n      driver.clear();\n      i++;\n    }\n\n    String warehouse = hconf.get(\"hive.metastore.warehouse.dir\");\n    String tableName = removeExt(resultFile.getName());\n    String directory = warehouse + \"/\" + tableName + \"/\";\n    String localDirectory = \"tmp\";\n\n    FileStatus[] files = dfs.listStatus(new Path(directory));\n    FileSystem lfs = null;\n    if (files == null) {\n      lfs = FileSystem.getLocal(ConfUtil.getJobConf());\n      files = lfs.listStatus(new Path(directory));\n    }\n\n    File resultDirectory = new File(localDirectory + \"/\" + tableName);\n    deleteDir(resultDirectory);\n    resultDirectory.mkdir();\n\n    for (FileStatus fs : files) {\n      Path src = fs.getPath();\n      if (src.getName().indexOf(\"crc\") >= 0) continue;\n\n      String destStr = localDirectory + \"/\" + tableName + \"/\" + src.getName();\n      Path dest = new Path(destStr);\n      if (lfs != null) {\n        lfs.copyToLocalFile(src, dest);\n        dfs.copyFromLocalFile(dest, new Path(directory));\n      } else dfs.copyToLocalFile(src, dest);\n    }\n\n    File[] rFiles = resultDirectory.listFiles();\n    StringBuilder sb = new StringBuilder();\n    for (File r : rFiles) {\n      if (r.getName().indexOf(\"crc\") >= 0) continue;\n      readFileToString(r, sb);\n    }\n    deleteDir(resultDirectory);\n\n    StringBuilder buf = new StringBuilder();\n    readFileToString(resultFile, buf);\n    if (!equal(buf, sb)) {\n      throw new Exception(\"Result for \" + queryFile + \" changed:\\n\" + sw.toString());\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2096, "initialization": ["File file = createTempFile(String,String)"], "initializationStart": [162], "initializationEnd": [197], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["file.delete()"], "configurationStart": [203], "configurationEnd": [219], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 225, "focalAPIEnd": 240, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["createTempFile(String,*,file)", "file.toURL()"], "useStart": [257, 397], "useEnd": [309, 412], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bobmcwhirter/vfs/tree/master/src/test/java/org/jboss/test/virtual/test/FileVFSUnitTestCase.java", "rawCode": "  /**\n   * Test VirtualFile.exists for vfsfile based urls.\n   *\n   * @throws Exception\n   */\n  public void testFileExists() throws Exception {\n    File tmpRoot = File.createTempFile(\"vfs\", \".root\");\n    tmpRoot.delete();\n    tmpRoot.mkdir();\n    File tmp = File.createTempFile(\"testFileExists\", null, tmpRoot);\n    log.info(\"+++ testFileExists, tmp=\" + tmp.getCanonicalPath());\n\n    URL rootURL = tmpRoot.toURL();\n    VFS vfs = VFS.getVFS(rootURL);\n    VirtualFile tmpVF = vfs.findChild(tmp.getName());\n    assertTrue(tmpVF.getPathName() + \".exists()\", tmpVF.exists());\n    assertTrue(\"tmp.delete()\", tmpVF.delete());\n    assertFalse(tmpVF.getPathName() + \".exists()\", tmpVF.exists());\n    assertTrue(tmpRoot + \".delete()\", tmpRoot.delete());\n  }\n"}, {"dataset": "mkdir", "exampleID": 2097, "initialization": ["File file = new File(String)"], "initializationStart": [435], "initializationEnd": [490], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 555, "focalAPIEnd": 573, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/knay/trombinoscope/tree/master/src/killheart/knay/trombinoscope/AndroidTree.java", "rawCode": "  /**\n   * @author David et Jonathan\n   *     <p>Cette fonction est appele  la cration de nouveau Dossier. Ex:Si l'on prend une photo\n   *     on l'enregistre dans le dossier \"Picture\". Il faut donc faire appel  la fonction\n   *     CreateFolder. Si le dossier existe dj elle ne le cre pas.\n   * @param NameFolder Nom du dossier.\n   */\n  public static void CreateFolder(String NameFolder, String chemin) {\n    File FileFolder = new File(Racine + \"/\" + chemin + \"/\" + NameFolder + \"\");\n    if (!FileFolder.exists()) { // < Si il n'existe pas.\n      FileFolder.mkdir(); // < On le cre.\n    }\n  }\n"}, {"dataset": "mkdir", "exampleID": 2098, "initialization": ["File file = new File(String)"], "initializationStart": [683], "initializationEnd": [701], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 725, "focalAPIEnd": 735, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lwz7512/ipintu/tree/master/src/com/pintu/facade/ServerListener.java", "rawCode": "  @Override\n  public void contextInitialized(ServletContextEvent event) {\n    // context param\n    filePath = event.getServletContext().getInitParameter(\"filepath\");\n    tempPath = event.getServletContext().getInitParameter(\"temppath\");\n\n    // \n    filePath = event.getServletContext().getRealPath(filePath);\n    tempPath = event.getServletContext().getRealPath(tempPath);\n\n    // \n    System.setProperty(\"filePath\", filePath);\n    log.debug(\">>> Environment variable, filePath: \" + filePath);\n    // \n    System.setProperty(\"tempPath\", tempPath);\n    log.debug(\">>> Environment variable, tempPath: \" + tempPath);\n\n    // \n    File fp = new File(filePath);\n    if (!fp.exists()) fp.mkdir();\n\n    File tp = new File(tempPath);\n    if (!tp.exists()) tp.mkdir();\n\n    log.debug(\"filePath and tempPath complete\");\n  }\n"}, {"dataset": "mkdir", "exampleID": 2099, "initialization": ["File file = new File(String)"], "initializationStart": [246], "initializationEnd": [269], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 302, "focalAPIEnd": 316, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iansealy/picard-detct/tree/master/src/tests/java/net/sf/picard/util/IOUtilTest.java", "rawCode": "  @BeforeClass\n  public void setUp() throws IOException {\n    existingTempFile = File.createTempFile(\"FiletypeTest.\", \".tmp\");\n    existingTempFile.deleteOnExit();\n    systemTempDir = System.getProperty(\"java.io.tmpdir\");\n    final File tmpDir = new File(systemTempDir);\n    if (!tmpDir.isDirectory()) tmpDir.mkdir();\n    if (!tmpDir.isDirectory())\n      throw new RuntimeException(\"java.io.tmpdir (\" + systemTempDir + \") is not a directory\");\n  }\n"}, {"dataset": "mkdir", "exampleID": 2100, "initialization": ["File file = createTempFile(String,*)"], "initializationStart": [99], "initializationEnd": [135], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "var = file.mkdir()", "focalAPIStart": 165, "focalAPIEnd": 180, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sisbell/jxta/tree/master/j2se/core/src/test/java/net/jxta/test/util/FileSystemTest.java", "rawCode": "  public static File createTempDirectory(String dirPrefix) throws IOException {\n    File tempDir = File.createTempFile(dirPrefix, null);\n    deleteDir(tempDir);\n    tempDir.mkdir();\n\n    return tempDir;\n  }\n"}]