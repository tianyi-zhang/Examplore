[{"dataset": "nanoTime", "exampleID": 9201, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "RuntimeException", "exceptionHandlingCall": ["AtomicLong.incrementAndGet()", "new IOException(String,*)"], "tryExpressionStart": 793, "tryExpressionEnd": 797, "tryBlockStart": 793, "tryBlockEnd": 1691, "catchExpressionStart": 974, "catchExpressionEnd": 1001, "catchBlockStart": 974, "catchBlockEnd": 1179, "exceptionHandlingCallStart": [1009, 1125], "exceptionHandlingCallEnd": [1053, 1172], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 828, "focalAPIEnd": 845, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [914], "useEnd": [931], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pierre/serialization/tree/master/writer/src/main/java/com/ning/metrics/serialization/writer/DiskSpoolEventWriter.java", "rawCode": "  @Override\n  public synchronized void write(final Event event) throws IOException {\n    if (!acceptsEvents) {\n      log.warn(\"Writer not ready, discarding event: {}\", event);\n      return;\n    }\n\n    if (currentOutputter == null) {\n      currentOutputFile =\n          new File(tmpSpoolDirectory, String.format(\"%d.bin\", fileId.incrementAndGet()));\n\n      final FileOutputStream outputStream = codec.getFileOutputStream(currentOutputFile);\n      if (eventSerializer == null) {\n        currentOutputter =\n            ObjectOutputterFactory.createObjectOutputter(outputStream, syncType, syncBatchSize);\n      } else {\n        currentOutputter =\n            ObjectOutputterFactory.createObjectOutputter(\n                outputStream, syncType, syncBatchSize, eventSerializer);\n      }\n    }\n\n    try {\n      final long startTime = System.nanoTime();\n      currentOutputter.writeObject(event);\n      writeTimer.update(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n    } catch (RuntimeException e) {\n      eventSerializationFailures.incrementAndGet();\n      // noinspection AccessToStaticFieldLockedOnInstance\n      throw new IOException(\"unable to serialize event\", e);\n    } catch (IOException e) {\n      eventSerializationFailures.incrementAndGet();\n      // If we got bad data, the stream may be in a bad state (i.e. jackson might be unable to\n      // append more data).\n      // It's safer to close the stream and reopen a new one.\n      try {\n        forceCommit();\n      } catch (IOException ignored) {\n        // We want to throw the original one\n      }\n      // noinspection AccessToStaticFieldLockedOnInstance\n      throw new IOException(\"unable to serialize event\", e);\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9202, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 569, "focalAPIEnd": 586, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()"], "useStart": [689, 727, 838, 1030, 1202, 1734, 2090, 2241, 2398], "useEnd": [706, 744, 855, 1047, 1219, 1751, 2107, 2258, 2415], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/interdroid/ibis-ipl/tree/master/benchmarks/src/ibis/ipl/benchmarks/LogP/LogP.java", "rawCode": "  void send(int count, int gapCount, int repeat) throws Exception {\n    long time;\n    long sendStart, sendTotal;\n    long recvStart, recvTotal;\n    long nanoStart, nanoTotal;\n    long nanoStartTicks, nanoTotalTicks;\n    int timeCount;\n\n    System.out.println(\n        \"LogP:\"\n            + \" repeat \"\n            + repeat\n            + \" count \"\n            + count\n            + \" gapCount \"\n            + gapCount\n            + \" (times in usec)\");\n\n    // measure clock overhead of the o_r/o_s tests below\n    timeCount = 100000;\n    sendTotal = 0;\n    nanoStart = System.nanoTime();\n    nanoStartTicks = Native.timestamp();\n    for (int i = 0; i < timeCount; i++) {\n      sendStart = System.nanoTime();\n      sendTotal += System.nanoTime() - sendStart;\n    }\n    nanoTotalTicks = Native.timestamp() - nanoStartTicks;\n    nanoTotal = System.nanoTime() - nanoStart;\n    double clock = (nanoTotal / 1000.0) / timeCount;\n    double ratio = ((double) nanoTotalTicks / (double) nanoTotal);\n\n    // rdtsc() overhead\n    nanoStart = System.nanoTime();\n    for (int i = 0; i < timeCount; i++) {\n      sendStart = Native.timestamp();\n      sendTotal += Native.timestamp() - sendStart;\n    }\n    nanoTotal = System.nanoTime() - nanoStart;\n    double tick = (nanoTotal / 1000.0) / timeCount;\n\n    System.out.println(\n        \"LogP:\"\n            + \" overhead: nano \"\n            + String.format(\"%.3f\", clock)\n            + \" rdtsc \"\n            + String.format(\"%.3f\", tick)\n            + \"; rdtsc/nano tickrate ratio \"\n            + String.format(\"%.3f\", ratio));\n\n    for (int r = 0; r < repeat; r++) {\n      WriteMessage writeMessage;\n      ReadMessage readMessage;\n\n      // rtt and o_s (send overhead)\n      sendTotal = 0;\n      time = System.nanoTime();\n      for (int i = 0; i < count; i++) {\n        // do send, measuring overhead\n        sendStart = Native.timestamp();\n        writeMessage = sport.newMessage();\n        writeMessage.finish();\n        sendTotal += Native.timestamp() - sendStart;\n\n        readMessage = rport.receive();\n        readMessage.finish();\n      }\n      time = System.nanoTime() - time;\n\n      double rtt = (time / 1000.0) / count;\n      double sendOverhead = (sendTotal / ratio / 1000.0) / count;\n\n      time = System.nanoTime();\n      for (int i = 0; i < gapCount; i++) {\n        writeMessage = sport.newMessage();\n        writeMessage.finish();\n      }\n      time = System.nanoTime() - time;\n\n      double g = (time / 1000.0) / gapCount;\n      // wait till everything is received:\n      readMessage = rport.receive();\n      readMessage.finish();\n\n      // o_r (receive overhead)\n      recvTotal = 0;\n      for (int i = 0; i < count; i++) {\n        writeMessage = sport.newMessage();\n        writeMessage.finish();\n\n        // busywait for 2*RTT so that the next message\n        // should be pending when we read it away\n        recvStart = System.nanoTime() + (long) ((2.0 * rtt) * 1000.0);\n        while (System.nanoTime() < recvStart) {\n          // nothing\n        }\n\n        // do receive, measuring overhead\n        recvStart = Native.timestamp();\n        readMessage = rport.receive();\n        readMessage.finish();\n        recvTotal += Native.timestamp() - recvStart;\n      }\n\n      double recvOverhead = (recvTotal / ratio / 1000.0) / count;\n\n      double ovhd = tick / 2;\n      System.out.println(\n          \"LogP:\"\n              + \" RTT \"\n              + String.format(\"%.2f\", (rtt - ovhd))\n              + \" os \"\n              + String.format(\"%.2f\", (sendOverhead - ovhd))\n              + \" or \"\n              + String.format(\"%.2f\", (recvOverhead - ovhd))\n              + \" g \"\n              + String.format(\"%.2f\", g));\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9203, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 273, "focalAPIEnd": 290, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["IResourceType.setName()"], "useStart": [242], "useEnd": [291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nkhoang/ja12sec02jav/tree/master/dbsync/src/test/java/com/nkhoang/wybness/model/ResourceTypeTest.java", "rawCode": "  @Override\n  protected List<IResourceType> doCreate(int count) throws Exception {\n    List<IResourceType> list = new ArrayList<IResourceType>();\n    for (int i = 0; i < count; i++) {\n      IResourceType bean = new ResourceTypeBean();\n\n      bean.setName(\"ResourceType-\" + System.nanoTime());\n\n      list.add(bean);\n    }\n    return list;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9204, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 719, "focalAPIEnd": 736, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()"], "useStart": [861, 1015, 1249, 1365, 1488], "useEnd": [878, 1032, 1266, 1382, 1505], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemire/JavaFastPFOR/tree/master/src/main/java/me/lemire/integercompression/benchmarktools/BenchmarkBitPacking.java", "rawCode": "  private static void testWithDeltas(boolean verbose) {\n    DecimalFormat dfspeed = new DecimalFormat(\"0\");\n    final int N = 32;\n    final int times = 100000;\n    Random r = new Random(0);\n    int[] data = new int[N];\n    int[] compressed = new int[N];\n    int[] icompressed = new int[N];\n    int[] uncompressed = new int[N];\n    for (int bit = 1; bit < 31; ++bit) {\n      long comp = 0;\n      long decomp = 0;\n      long icomp = 0;\n      long idecomp = 0;\n      for (int t = 0; t < times; ++t) {\n        data[0] = r.nextInt(1 << bit);\n        for (int k = 1; k < N; ++k) {\n          data[k] = r.nextInt(1 << bit) + data[k - 1];\n        }\n        int[] tmpdata = Arrays.copyOf(data, data.length);\n        long time1 = System.nanoTime();\n        Delta.delta(tmpdata);\n        BitPacking.fastpackwithoutmask(tmpdata, 0, compressed, 0, bit);\n        long time2 = System.nanoTime();\n        BitPacking.fastunpack(compressed, 0, uncompressed, 0, bit);\n        Delta.fastinverseDelta(uncompressed);\n        long time3 = System.nanoTime();\n        if (!Arrays.equals(data, uncompressed)) throw new RuntimeException(\"bug\");\n        comp += time2 - time1;\n        decomp += time3 - time2;\n        tmpdata = Arrays.copyOf(data, data.length);\n        time1 = System.nanoTime();\n        IntegratedBitPacking.integratedpack(0, tmpdata, 0, icompressed, 0, bit);\n        time2 = System.nanoTime();\n        IntegratedBitPacking.integratedunpack(0, icompressed, 0, uncompressed, 0, bit);\n        time3 = System.nanoTime();\n        if (!Arrays.equals(icompressed, compressed)) throw new RuntimeException(\"ibug \" + bit);\n        if (!Arrays.equals(data, uncompressed)) throw new RuntimeException(\"bug \" + bit);\n        icomp += time2 - time1;\n        idecomp += time3 - time2;\n      }\n      if (verbose)\n        System.out.println(\n            \"bit = \"\n                + bit\n                + \" comp. speed = \"\n                + dfspeed.format(N * times * 1000.0 / (comp))\n                + \" decomp. speed = \"\n                + dfspeed.format(N * times * 1000.0 / (decomp))\n                + \" icomp. speed = \"\n                + dfspeed.format(N * times * 1000.0 / (icomp))\n                + \" idecomp. speed = \"\n                + dfspeed.format(N * times * 1000.0 / (idecomp)));\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9205, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 64, "focalAPIEnd": 81, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [518], "useEnd": [535], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/achudars/Project-Euler/tree/master/PE164/src/PE164.java", "rawCode": "  public static void main(String[] args) {\n    long startTime = System.nanoTime();\n\n    long[][][] v = new long[20][10][10];\n    for (int i = 1; i < 10; i++) v[0][0][i] = 1;\n    for (int i = 1; i < 20; i++)\n      for (int j = 0; j < 10; j++)\n        for (int k = 0; k < 10; k++)\n          for (int d = 0; d + j + k < 10; d++) v[i][k][d] += v[i - 1][j][k];\n    long ret = 0;\n    for (int j = 0; j < 10; j++) for (int k = 0; k < 10; k++) ret += v[19][j][k];\n    System.out.println(\"Answer: \" + ret);\n\n    long endTime = System.nanoTime();\n    System.out.printf(\"Total Time: %.6f seconds\\n\", ((endTime - startTime) / 1000000000.0));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9206, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 56, "focalAPIEnd": 73, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [237], "useEnd": [254], "hasFinally": 1, "cleanUpCall": ["nanoTime()", "update(*,*)"], "finallyExpressionStart": 202, "finallyExpressionEnd": 210, "finallyBlockStart": 202, "finallyBlockEnd": 296, "cleanUpCallStart": [237, 218], "cleanUpCallEnd": [254, 289], "url": "https://github.com/taskurotta/taskurotta/tree/master/hazelcast/src/main/java/ru/taskurotta/hazelcast/store/MongoMapStore.java", "rawCode": "  public void delete(Object key) {\n    long startTime = System.nanoTime();\n\n    try {\n      DBObjectCheat<Object> objKey = new DBObjectCheat<>(key);\n      coll.remove(objKey, noWaitWriteConcern);\n    } finally {\n      deleteTimer.update(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9207, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 167, "focalAPIEnd": 184, "followUpCheck": "end -  > monitoringAnnot.expected()", "checkType": "IF", "followUpCheckExpressionStart": 257, "followUpCheckExpressionEnd": 302, "followUpCheckBlockStart": 257, "followUpCheckBlockEnd": 595, "use": ["system.nanoTime()"], "useStart": [233], "useEnd": [250], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/org.aspectj/tree/master/tests/multiIncremental/PR148285/inc1/Monitor.java", "rawCode": "  @Around(\"monitored(monitoringAnnot)\")\n  public Object flagExpectationMismatch(\n      ProceedingJoinPoint pjp, PerformenceMonitor monitoringAnnot) {\n    long start = System.nanoTime();\n    Object ret = pjp.proceed();\n    long end = System.nanoTime();\n\n    if (end - start > monitoringAnnot.expected()) {\n      System.out.println(\n          \"Method \"\n              + pjp.getSignature().toShortString()\n              + \" took longer than expected\\n\\t\"\n              + \"Max expected = \"\n              + monitoringAnnot.expected()\n              + \", actual = \"\n              + (end - start));\n    }\n    return ret;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9208, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 92, "focalAPIEnd": 109, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convert(,*)"], "useStart": [124], "useEnd": [171], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lalithsuresh/odin-master/tree/master/src/main/java/net/floodlightcontroller/core/internal/RoleChanger.java", "rawCode": "    @Override\n    public long getDelay(TimeUnit tu) {\n      long timeRemaining = deadline - System.nanoTime();\n      return tu.convert(timeRemaining, TimeUnit.NANOSECONDS);\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9209, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 251, "focalAPIEnd": 268, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lowasser/guava-experimental/tree/master/guava-tests/test/com/google/common/util/concurrent/JSR166TestCase.java", "rawCode": "  /**\n   * Delays, via Thread.sleep, for the given millisecond delay, but if the sleep is shorter than\n   * specified, may re-sleep or yield until time elapses.\n   */\n  static void delay(long millis) throws InterruptedException {\n    long startTime = System.nanoTime();\n    long ns = millis * 1000 * 1000;\n    for (; ; ) {\n      if (millis > 0L) Thread.sleep(millis);\n      else // too short to sleep\n      Thread.yield();\n      long d = ns - (System.nanoTime() - startTime);\n      if (d > 0L) millis = d / (1000 * 1000);\n      else break;\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9210, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 224, "focalAPIEnd": 241, "followUpCheck": "( - time < mChordDelay &&  - mPressedInsideTime < mChordDelay) || true", "checkType": "IF", "followUpCheckExpressionStart": 1087, "followUpCheckExpressionEnd": 1190, "followUpCheckBlockStart": 1087, "followUpCheckBlockEnd": 1407, "use": ["SparseArray<Long>.put(int,)"], "useStart": [871], "useEnd": [905], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tsion/FastDraw/tree/master/src/usask/hci/fastdraw/DrawView.java", "rawCode": "  @Override\n  public boolean onTouchEvent(MotionEvent event) {\n    int index = event.getActionIndex();\n    float x = event.getX(index);\n    float y = event.getY(index);\n    int id = event.getPointerId(index);\n    long now = System.nanoTime();\n\n    switch (event.getActionMasked()) {\n      case MotionEvent.ACTION_DOWN:\n      case MotionEvent.ACTION_POINTER_DOWN:\n        mLog.event(\"Touch down: \" + id);\n\n        mFingers.add(id);\n\n        if (event.getPointerCount() == 1) mCheckOverlay = true;\n\n        if (getOverlayButtonBounds().contains(x, y)) {\n          mFingerInside = id;\n          mPressedInsideTime = now;\n          mIgnoredFingers.add(mFingerInside);\n        } else {\n          int col = (int) (x / mColWidth);\n          int row = (int) (y / mRowHeight);\n\n          if (mLeftHanded) col = mCols - col - 1;\n\n          mSelected = row * mCols + col;\n          mRecentTouches.put(mSelected, now);\n        }\n\n        for (int i = 0; i < mRecentTouches.size(); i++) {\n          int selection = mRecentTouches.keyAt(i);\n          long time = mRecentTouches.valueAt(i);\n\n          if ((now - time < mChordDelay && now - mPressedInsideTime < mChordDelay)\n              || mShowOverlay) {\n            changeSelection(selection);\n            mRecentTouches.removeAt(i);\n            i--;\n          } else if (now - time > mChordDelay) {\n            mRecentTouches.removeAt(i);\n            i--;\n          }\n        }\n\n        if (!mShowOverlay) {\n          mOrigins.put(id, new PointF(x, y));\n          mTool.touchStart(id, x, y);\n        }\n        break;\n\n      case MotionEvent.ACTION_MOVE:\n        if (mShowOverlay) break;\n\n        int count = event.getPointerCount();\n\n        for (int i = 0; i < count; i++) {\n          int fingerId = event.getPointerId(i);\n          float x2 = event.getX(i);\n          float y2 = event.getY(i);\n\n          if (mIgnoredFingers.contains(fingerId)) continue;\n\n          PointF origin = mOrigins.get(fingerId);\n\n          if (origin != null) {\n            float dx = origin.x - x2;\n            float dy = origin.y - y2;\n            double dist = Math.sqrt(dx * dx + dy * dy);\n\n            if (dist > mThreshold) {\n              mOrigins.delete(fingerId);\n              origin = null;\n              mLog.event(\n                  \"Started using tool: \"\n                      + mThicknessName\n                      + \" \"\n                      + mColorName\n                      + \" \"\n                      + mToolName\n                      + \", \"\n                      + fingerId);\n            }\n          }\n\n          if (origin == null) {\n            mTool.touchMove(fingerId, x2, y2);\n\n            if (!mChanged) {\n              mChanged = true;\n              mNextUndo = mBitmap.copy(mBitmap.getConfig(), true);\n            }\n          }\n        }\n\n        break;\n\n      case MotionEvent.ACTION_UP:\n      case MotionEvent.ACTION_POINTER_UP:\n        mLog.event(\"Touch up: \" + id);\n\n        mOrigins.delete(id);\n        mFingers.remove(id);\n\n        if (id == mFingerInside) {\n          mFingerInside = -1;\n        }\n\n        boolean draw = true;\n\n        if (mIgnoredFingers.contains(id)) {\n          mIgnoredFingers.remove(id);\n          draw = false;\n        }\n\n        if (mShowOverlay) {\n          if (event.getPointerCount() == 1) {\n            mShowOverlay = false;\n            long duration = now - mOverlayStart;\n            mLog.event(\"Overlay hidden after \" + duration / 1000000 + \" ms\");\n          }\n        } else if (draw) {\n          if (event.getPointerCount() == 1 && mChanged) {\n            mUndo = mNextUndo;\n          }\n\n          synchronized (mBitmapLock) {\n            mTool.touchStop(id, x, y, new Canvas(mBitmap));\n          }\n\n          mLog.event(\n              \"Finished using tool: \"\n                  + mThicknessName\n                  + \" \"\n                  + mColorName\n                  + \" \"\n                  + mToolName\n                  + \", \"\n                  + id);\n        }\n\n        if (event.getPointerCount() == 1) mChanged = false;\n\n        break;\n    }\n\n    invalidate();\n    return true;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9211, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["system.currentTimeMillis()"], "configurationStart": [-1735], "configurationEnd": [-1709], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": -1662, "focalAPIEnd": -1645, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println()"], "useStart": [1515], "useEnd": [1545], "hasFinally": 1, "cleanUpCall": ["PrintWriter.close()"], "finallyExpressionStart": 1663, "finallyExpressionEnd": 1671, "finallyBlockStart": 1663, "finallyBlockEnd": 1732, "cleanUpCallStart": [1706], "cleanUpCallEnd": [1717], "url": "https://github.com/davros-/platform_frameworks_base/tree/master/services/java/com/android/server/EntropyMixer.java", "rawCode": "  /**\n   * Add additional information to the kernel entropy pool. The information isn't necessarily\n   * \"random\", but that's ok. Even sending non-random information to {@code /dev/urandom} is useful\n   * because, while it doesn't increase the \"quality\" of the entropy pool, it mixes more bits into\n   * the pool, which gives us a higher degree of uncertainty in the generated randomness. Like\n   * nature, writes to the random device can only cause the quality of the entropy in the kernel to\n   * stay the same or increase.\n   *\n   * <p>For maximum effect, we try to target information which varies on a per-device basis, and is\n   * not easily observable to an attacker.\n   */\n  private void addDeviceSpecificEntropy() {\n    PrintWriter out = null;\n    try {\n      out = new PrintWriter(new FileOutputStream(randomDevice));\n      out.println(\"Copyright (C) 2009 The Android Open Source Project\");\n      out.println(\"All Your Randomness Are Belong To Us\");\n      out.println(START_TIME);\n      out.println(START_NANOTIME);\n      out.println(SystemProperties.get(\"ro.serialno\"));\n      out.println(SystemProperties.get(\"ro.bootmode\"));\n      out.println(SystemProperties.get(\"ro.baseband\"));\n      out.println(SystemProperties.get(\"ro.carrier\"));\n      out.println(SystemProperties.get(\"ro.bootloader\"));\n      out.println(SystemProperties.get(\"ro.hardware\"));\n      out.println(SystemProperties.get(\"ro.revision\"));\n      out.println(new Object().hashCode());\n      out.println(System.currentTimeMillis());\n      out.println(System.nanoTime());\n    } catch (IOException e) {\n      Slog.w(TAG, \"Unable to add device specific data to the entropy pool\", e);\n    } finally {\n      if (out != null) {\n        out.close();\n      }\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9212, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 124, "focalAPIEnd": 141, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toString()"], "useStart": [110], "useEnd": [142], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rlindsgaard/pretested-integration-plugin-old/tree/master/src/test/java/org/jenkinsci/plugins/pretestedintegration/PretestedIntegrationTestCase.java", "rawCode": "  public static File getTempFile() throws IOException {\n    final File temp = File.createTempFile(\"prteco-\" + Long.toString(System.nanoTime()), \"\");\n\n    if (!(temp.delete())) {\n      throw new IOException(\"Could not delete temp file: \" + temp.getAbsolutePath());\n    }\n\n    return temp;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9213, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 2057, "focalAPIEnd": 2074, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convertNanosecondsToMilliseconds()"], "useStart": [2018], "useEnd": [2075], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/heskew-riotapps/WordAndroid/tree/master/src/com/riotapps/word/hooks/PlayerService.java", "rawCode": "  public static Player handleAuthResponse(String result) { // InputStream iStream){\n    Gson gson = new Gson(); // wrap json return into a single call that takes a type\n\n    // Logger.w(TAG, \"handlePlayerResponse incoming json=\" + IOHelper.streamToString(iStream));\n    // Reader reader = new InputStreamReader(iStream);\n    // //serverResponseObject.response.getEntity().getContent());\n\n    Logger.d(TAG, \"handleAuthResponse result=\" + result.length() + \" \" + result);\n\n    Player storedPlayer = getPlayerFromLocal();\n\n    Type type = new TypeToken<Player>() {}.getType();\n    Player player = gson.fromJson(result, type);\n\n    /// save player info to shared preferences\n    // userId and auth_token ...email and password should have been stored before this call\n    SharedPreferences settings = Storage.getSharedPreferences();\n    SharedPreferences.Editor editor = settings.edit();\n\n    // Logger.w(TAG, \"handlePlayerResponse auth=\" + player.getAuthToken() + \" \" +\n    // gson.toJson(player));\n    Date completedDate =\n        new Date(\n            settings.getString(\n                Constants.USER_PREFS_LATEST_COMPLETED_GAME_DATE,\n                Constants.DEFAULT_COMPLETED_GAMES_DATE));\n\n    Logger.d(TAG, \"handlePlayerResponse about to getPlayerFromLocal\");\n    // manage the local completed games list, only keep 10 max in the list. roll off older games.\n    // do this before the player is stored locally\n\n    storedPlayer.setId(player.getId());\n    storedPlayer.setNickname(player.getNickname());\n    storedPlayer.setFirstName(player.getFirstName());\n    storedPlayer.setLastName(player.getLastName());\n    storedPlayer.setGravatar(player.getGravatar());\n    storedPlayer.setFB(player.getFB());\n    storedPlayer.setNumWins(player.getNumWins());\n    storedPlayer.setAuthToken(player.getAuthToken());\n    storedPlayer.setEmail(player.getEmail());\n    storedPlayer.setNoInterstitialAdsOption(player.isNoInterstitialAdsOption());\n    storedPlayer.setLastRefreshDate(player.getLastRefreshDate());\n\n    long now = Utils.convertNanosecondsToMilliseconds(System.nanoTime());\n\n    editor.putLong(Constants.USER_PREFS_PLAYER_CHECK_TIME, now);\n    editor.putString(Constants.USER_PREFS_LATEST_COMPLETED_GAME_DATE, completedDate.toGMTString());\n    editor.putString(Constants.USER_PREFS_AUTH_TOKEN, storedPlayer.getAuthToken());\n    editor.putString(Constants.USER_PREFS_USER_ID, storedPlayer.getId());\n    editor.putString(Constants.USER_PREFS_PLAYER_JSON, gson.toJson(storedPlayer));\n    // Check if we're running on GingerBread or above\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n      // If so, call apply()\n      editor.apply();\n      // if not\n    } else {\n      // Call commit()\n      editor.commit();\n    }\n\n    player = null;\n    gson = null;\n    result = null;\n\n    return storedPlayer;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9214, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 166, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [311], "useEnd": [328], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/echocat/jomon/tree/master/cache/src/test/java/org/echocat/jomon/cache/CachePerformanceTestSupport.java", "rawCode": "  @Test\n  public final void testPut() {\n    initMapPutTime();\n    final Cache<String, String> cache = getInstance(100000, MAX_OPERATIONS);\n    final long startTime = System.nanoTime();\n    for (int i = 0; i < MAX_OPERATIONS; ++i) {\n      cache.put(Integer.toString(i), \"_\" + i);\n    }\n    final long duration = System.nanoTime() - startTime;\n    assertThat(duration, isLessThan(c_mapPutTime * 2));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9215, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 89, "focalAPIEnd": 106, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/levire/MetaProject/tree/master/MetaProject/cocos2dx/platform/ouya/java/src/org/cocos2dx/lib/Cocos2dxRenderer.java", "rawCode": "  @Override\n  public void onDrawFrame(final GL10 gl) {\n    final long nowInNanoSeconds = System.nanoTime();\n    final long interval = nowInNanoSeconds - this.mLastTickInNanoSeconds;\n\n    // should render a frame when onDrawFrame() is called or there is a\n    // \"ghost\"\n    Cocos2dxRenderer.nativeRender();\n\n    // fps controlling\n    if (interval < Cocos2dxRenderer.sAnimationInterval) {\n      try {\n        // because we render it before, so we should sleep twice time interval\n        Thread.sleep(\n            (Cocos2dxRenderer.sAnimationInterval - interval)\n                * 2\n                / Cocos2dxRenderer.NANOSECONDSPERMICROSECOND);\n      } catch (final Exception e) {\n      }\n    }\n\n    this.mLastTickInNanoSeconds = nowInNanoSeconds;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9216, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 682, "focalAPIEnd": 699, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["signalNextWaiter()"], "finallyExpressionStart": 1046, "finallyExpressionEnd": 1054, "finallyBlockStart": 1046, "finallyBlockEnd": 1313, "cleanUpCallStart": [1213], "cleanUpCallEnd": [1231], "url": "https://github.com/sensui/guava-libraries/tree/master/guava/src/com/google/common/util/concurrent/Monitor.java", "rawCode": "  /**\n   * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n   * the time to acquire the lock and the time to wait for the guard to be satisfied, and may be\n   * interrupted.\n   *\n   * @return whether the monitor was entered with the guard satisfied\n   */\n  public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {\n    long timeoutNanos = unit.toNanos(time);\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean reentrant = lock.isHeldByCurrentThread();\n    if (fair || !lock.tryLock()) {\n      long deadline = System.nanoTime() + timeoutNanos;\n      if (!lock.tryLock(time, unit)) {\n        return false;\n      }\n      timeoutNanos = deadline - System.nanoTime();\n    }\n\n    boolean satisfied = false;\n    boolean threw = true;\n    try {\n      satisfied = guard.isSatisfied() || awaitNanos(guard, timeoutNanos, reentrant);\n      threw = false;\n      return satisfied;\n    } finally {\n      if (!satisfied) {\n        try {\n          // Don't need to signal if timed out, but do if interrupted\n          if (threw && !reentrant) {\n            signalNextWaiter();\n          }\n        } finally {\n          lock.unlock();\n        }\n      }\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9217, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 46, "focalAPIEnd": 63, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xored/f4/tree/master/com.xored.f4.fantom/fantom/src/sys/java/fan/sys/Duration.java", "rawCode": "  public static long nowMillis() {\n    return System.nanoTime() / 1000000L;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9218, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 208, "focalAPIEnd": 225, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [329], "useEnd": [346], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/advancedrendering/project/tree/master/ExtraBees/src/particlesystem/FireCannon.java", "rawCode": "  @Override\n  public void draw(GLAutoDrawable drawable) {\n    if (Blocks.fireCannonActive) {\n      // get the gl object\n      GL gl = drawable.getGL();\n\n      if (lastTime == -1) {\n        lastTime = (float) System.nanoTime() / 1000000.0f;\n      } else {\n        if (this.update == true) {\n          float current_time = (float) System.nanoTime() / 1000000.0f;\n          float elapsed_time = current_time - lastTime;\n          lastTime = current_time;\n          // update the particle system\n          update(15f);\n        }\n        // draw particles\n        float[] position = SceneRoot.getInstance(drawable).getHeli().getTranslation();\n        position[0] = position[0];\n        position[1] = position[1] + 0.04f;\n        position[2] = position[2] + 0.12f;\n        ((FireCannonEmitter) settings.emitter).position_vector = position;\n        float[] target =\n            VectorMath.normalize(\n                VectorMath.minus(position, SceneRoot.getInstance(drawable).getHeli().heliTarget));\n\n        this.settings.general_external_force[0] = target[0] * -100f;\n        this.settings.general_external_force[1] = target[1] * -150f;\n        this.settings.general_external_force[2] = target[2] * -110f;\n\n        // use point sprites\n\n        FloatBuffer buffer_sizes = FloatBuffer.allocate(2);\n        gl.glGetFloatv(GL.GL_ALIASED_POINT_SIZE_RANGE, buffer_sizes);\n\n        gl.glEnable(GL.GL_TEXTURE_2D);\n\n        this.raindrop.bind();\n\n        // Enable blending and set for particles\n        gl.glEnable(GL.GL_BLEND);\n        gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE);\n\n        gl.glEnable(GL.GL_POINT_SPRITE_ARB);\n        float[] quadratic = {1.0f, 0.0f, 0.01f};\n        FloatBuffer buffer_quadratic = FloatBuffer.wrap(quadratic);\n\n        gl.glPointParameterfvARB(GL.GL_POINT_DISTANCE_ATTENUATION_ARB, buffer_quadratic);\n        gl.glPointParameterf(GL.GL_POINT_FADE_THRESHOLD_SIZE_ARB, 60.0f);\n        FloatBuffer point_size_arg = FloatBuffer.allocate(1);\n        gl.glGetFloatv(GL.GL_POINT_SIZE_MAX_ARB, point_size_arg);\n        gl.glPointSize(settings.point_size);\n        gl.glPointParameterfARB(GL.GL_POINT_SIZE_MAX_ARB, point_size_arg.get(0));\n        gl.glPointParameterfARB(GL.GL_POINT_SIZE_MIN_ARB, 0.0f);\n\n        // Tell it the max and min sizes we can use using our pre-filled array.\n        gl.glPointParameterfARB(GL.GL_POINT_SIZE_MIN_ARB, buffer_sizes.get(0));\n        gl.glPointParameterfARB(GL.GL_POINT_SIZE_MAX_ARB, buffer_sizes.get(1));\n\n        // Tell OGL to replace the coordinates upon drawing.\n        gl.glTexEnvi(GL.GL_POINT_SPRITE_ARB, GL.GL_COORD_REPLACE_ARB, GL.GL_TRUE);\n\n        // Turn off depth masking so particles in front will not occlude particles behind them.\n        gl.glDepthMask(false);\n\n        gl.glEnable(GL.GL_COLOR_MATERIAL);\n\n        gl.glBegin(GL.GL_POINTS);\n        for (Particle par : this.active_particles) {\n          gl.glColor3fv(par.getColor(), 0); // last parameter (i.e. 0) is offset\n          float[] loc_pos = par.getPosition();\n          gl.glVertex3f(loc_pos[0], loc_pos[1], loc_pos[2]);\n        }\n        gl.glEnd();\n        gl.glDepthMask(true);\n        gl.glDisable(GL.GL_POINT_SPRITE_ARB);\n        gl.glDisable(GL.GL_TEXTURE_2D);\n        gl.glDisable(GL.GL_BLEND);\n        gl.glDisable(GL.GL_COLOR_MATERIAL);\n      }\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9219, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 89, "focalAPIEnd": 106, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nschlimm/playground/tree/master/projectLibrary/src/bb/util/JUnitExecutor.java", "rawCode": "    public synchronized void testRunFinished(Result result) {\n      long timeRunStopNs = System.nanoTime();\n      double timeRunExecS =\n          (timeRunStopNs - timeRunStartNs)\n              * 1e-9; // e-9 converts ns to s as needed by FormatUtil.toEngineeringTime below\n      String execTime = \"; total execution time = \" + FormatUtil.toEngineeringTime(timeRunExecS);\n\n      events += \"--------------------------------------------------\" + \"\\n\";\n\n      if (result.wasSuccessful()) {\n        events +=\n            \"JUnit 4 test run was successful: all \"\n                + result.getRunCount()\n                + \" tests passed (\"\n                + result.getIgnoreCount()\n                + \" tests were ignored)\"\n                + execTime\n                + \"\\n\";\n      } else {\n        events +=\n            \"JUnit 4 test run FAILED: \"\n                + result.getFailureCount()\n                + \"/\"\n                + result.getRunCount()\n                + \" tests failed (\"\n                + result.getIgnoreCount()\n                + \" tests were ignored)\"\n                + execTime\n                + \"\\n\"; // WARNING JUnit 4.5 has a nasty bug (fixed in 4.6) in which getRunCount is\n                        // wrong when tests are ignored:\n                        // http://sourceforge.net/tracker/index.php?func=detail&aid=2106324&group_id=15278&atid=115278\n        events += \"\\n\";\n        events +=\n            \"Summary of each class which failed, followed by a list of that class's failing methods:\"\n                + \"\\n\";\n        events += \"\\t\" + StringUtil.toString(classToMethodsFailed, \"\\n\\t\") + \"\\n\";\n      }\n\n      if (testOutputDirectory.exists()) {\n        try {\n          int numberOutputFiles = DirUtil.getContents(testOutputDirectory).length;\n          if (numberOutputFiles > 0) {\n            events += \"\\n\";\n            events +=\n                \"Note: there are \"\n                    + numberOutputFiles\n                    + \" test output files inside \"\n                    + testOutputDirectory.getPath()\n                    + \"\\n\";\n          }\n        } catch (Throwable t) {\n          throw ThrowableUtil.toRuntimeException(t);\n        }\n      }\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9220, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 53, "focalAPIEnd": 70, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vaadin/gwt/tree/master/dev/core/src/com/google/gwt/dev/util/log/speedtracer/SpeedTracerLogger.java", "rawCode": "    public long normalizedTimeNanos() {\n      return System.nanoTime() - zeroTimeNanos;\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9221, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 427, "focalAPIEnd": 444, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toMillis()"], "useStart": [397], "useEnd": [445], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgothel/jogl/tree/master/src/jogl/classes/jogamp/opengl/FPSCounterImpl.java", "rawCode": "  /**\n   * Increases total frame count and updates values if feature is enabled and update interval is\n   * reached.<br>\n   * Shall be called by actual FPSCounter implementing renderer, after display a new frame.\n   */\n  public final synchronized void tickFPS() {\n    fpsTotalFrames++;\n    if (fpsUpdateFramesInterval > 0 && fpsTotalFrames % fpsUpdateFramesInterval == 0) {\n      final long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\n      fpsLastPeriod = now - fpsLastUpdateTime;\n      fpsLastPeriod = Math.max(fpsLastPeriod, 1); // div 0\n      fpsLast = (fpsUpdateFramesInterval * 1000f) / (fpsLastPeriod);\n\n      fpsTotalDuration = now - fpsStartTime;\n      fpsTotalDuration = Math.max(fpsTotalDuration, 1); // div 0\n      fpsTotal = (fpsTotalFrames * 1000f) / (fpsTotalDuration);\n\n      if (null != fpsOutputStream) {\n        fpsOutputStream.println(toString());\n      }\n\n      fpsLastUpdateTime = now;\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9222, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 112, "focalAPIEnd": 129, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [450], "useEnd": [467], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codehaus/multiverse/tree/master/multiverse-alpha-unborn/src/test/java/org/multiverse/stms/alpha/transactions/readonly/NonTrackingReadonlyAlphaTransaction_performanceTest.java", "rawCode": "  @Test\n  public void whenTransactionReused() {\n    ManualRef ref = new ManualRef(stm, 10);\n\n    long startNs = System.nanoTime();\n    long version = stm.getVersion();\n    AlphaTransaction tx = createSutTransaction();\n\n    for (int k = 0; k < transactionCount; k++) {\n      tx.reset();\n      tx.openForRead(ref);\n      tx.commit();\n\n      if (k % (10 * 1000 * 1000) == 0) {\n        System.out.printf(\"at %s\\n\", k);\n      }\n    }\n\n    long periodNs = System.nanoTime() - startNs;\n    double transactionPerSecond = (transactionCount * TimeUnit.SECONDS.toNanos(1)) / periodNs;\n    System.out.printf(\"%s reads-transactions/second\\n\", format(transactionPerSecond));\n\n    assertEquals(version, stm.getVersion());\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9223, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 71, "focalAPIEnd": 88, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addAndGet()"], "useStart": [45], "useEnd": [89], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mgm-tp/jfunk/tree/master/jfunk-common/src/main/java/com/mgmtp/jfunk/common/random/MathRandom.java", "rawCode": "  public static long nextSeed() {\n    return SEED_UNIQUIFIER.addAndGet(System.nanoTime());\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9224, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 199, "focalAPIEnd": 216, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/heavenlyhash/ahslib/tree/master/src/main/us/exultant/ahs/thread/ScheduleParams.java", "rawCode": "  public static ScheduleParams makeFixedDelay(\n      long $startTime, long $period, TimeUnit $unit, boolean $startTimeIsAbsolute) {\n    return new ScheduleParams(\n        ($startTimeIsAbsolute ? 0 : System.nanoTime()) + $unit.toNanos($startTime),\n        -$unit.toNanos($period));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9225, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 148, "focalAPIEnd": 165, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/inkooboo/areks/tree/master/cocos2dx/tools/lua_project_generator/template/android/src/org/cocos2dx/lib/Cocos2dxRenderer.java", "rawCode": "  public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n    nativeInit(Cocos2dxActivity.screenWidth, Cocos2dxActivity.screenHeight);\n    last = System.nanoTime();\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9226, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 815, "focalAPIEnd": 832, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [1611], "useEnd": [1628], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/linkedin/databus/tree/master/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/util/TestRangeBasedReaderWriterLockPerf.java", "rawCode": "  @Test\n  /**\n   * Test how fast we can check out read locks from the lock provider We will keep a maximum of N\n   * read locks checked out at any point in time Once the number of read locks has exceeded N we\n   * will release a few K back to the provider We will also check out a non-overlapping write lock\n   * after checking out the read lock\n   */\n  public void testReaderInsertWithCooperatingWritesPerformance() throws Exception {\n\n    ArrayList<Double> avgInsertsPerSecond = new ArrayList<Double>();\n\n    for (int numTests = 0; numTests < 20; ++numTests) {\n      Queue<LockToken> checkedOutLockTokens = new ArrayBlockingQueue<LockToken>(100);\n\n      RangeBasedReaderWriterLock lockProvider = new RangeBasedReaderWriterLock();\n      RangeBasedReaderWriterLock.LOG.setLevel(Level.FATAL);\n      long startTime = System.nanoTime();\n      int numOperations = 1000000;\n      for (int i = numOperations - 1; i > 0; --i) {\n        LockToken token = lockProvider.acquireReaderLock(i, numOperations, _parser, \"lock\" + i);\n        long minStart = lockProvider.getReaderRanges().peek()._id.start;\n        lockProvider.acquireWriterLock(0, minStart, _parser);\n        lockProvider.releaseWriterLock(_parser);\n        if (minStart != i) {\n          Assert.fail(\"i should always be equal to minStart\");\n        }\n        // assertEquals(i, minStart);\n        while (!checkedOutLockTokens.offer(token)) {\n          for (int j = 0; j < 5; ++j) {\n            LockToken releaseToken = checkedOutLockTokens.poll();\n            lockProvider.releaseReaderLock(releaseToken);\n          }\n        }\n      }\n\n      long endTime = System.nanoTime();\n\n      if (numTests > 0) {\n        double insertsPerSecond = numOperations * 1000000000L / (endTime - startTime);\n        avgInsertsPerSecond.add(insertsPerSecond);\n        System.out.println(\"Inserts per second = \" + insertsPerSecond);\n      }\n    }\n\n    double total = 0;\n    for (Double d : avgInsertsPerSecond) {\n      total += d;\n    }\n    System.out.println(\n        \"Overall Average Inserts Per Second = \" + (total / avgInsertsPerSecond.size()));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9227, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 358, "focalAPIEnd": 375, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File()"], "useStart": [293], "useEnd": [376], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/VEDAGroup/webstart-maven-plugin/tree/master/webstart-maven-plugin/src/test/java/org/codehaus/mojo/webstart/JarUnsignMojoTest.java", "rawCode": "  /** {@inheritDoc} */\n  public void setUp() throws Exception {\n    super.setUp();\n\n    embedder = new MavenEmbedder();\n\n    embedder.setClassLoader(Thread.currentThread().getContextClassLoader());\n    embedder.setLogger(new MavenEmbedderConsoleLogger());\n    embedder.start();\n\n    tempdir = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + System.nanoTime());\n    FileUtils.mkdir(tempdir.getAbsolutePath());\n\n    File unsignTempDir = new File(tempdir, \"unsign\");\n\n    FileUtils.deleteDirectory(unsignTempDir);\n\n    mojo = new JarUnsignMojo();\n    mojo.setVerbose(false);\n\n    signTool = (SignTool) lookup(SignTool.ROLE);\n    mojo.setSignTool(signTool);\n\n    File keystore = new File(tempdir, \"keystore\");\n\n    sign = new DefaultSignConfig();\n    sign.setAlias(\"test\");\n    sign.setKeypass(\"123456\");\n    sign.setKeystore(keystore.getAbsolutePath());\n    sign.setStorepass(\"123456\");\n    sign.setVerify(false);\n\n    sign.setDnameCn(\"CN\");\n    sign.setDnameOu(\"OU\");\n    sign.setDnameL(\"L\");\n    sign.setDnameSt(\"ST\");\n    sign.setDnameO(\"O\");\n    sign.setDnameC(\"C\");\n\n    KeystoreConfig keystoreConfig = new KeystoreConfig();\n    keystoreConfig.setDelete(true);\n    keystoreConfig.setGen(true);\n    sign.setKeystoreConfig(keystoreConfig);\n\n    sign.init(tempdir, false, signTool, getClassLoader());\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9228, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 120, "focalAPIEnd": 137, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["updateAt(,double)"], "useStart": [111], "useEnd": [146], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/perfectsense/dari/tree/master/util/src/main/java/com/psddev/dari/util/ExponentialMovingAverage.java", "rawCode": "  /** Updates the average with the given {@code amount}. */\n  public double update(double amount) {\n    return updateAt(System.nanoTime(), amount);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9229, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 155, "focalAPIEnd": 172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [407], "useEnd": [424], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/echocat/jomon/tree/master/cache/src/test/java/org/echocat/jomon/cache/CachePerformanceTestSupport.java", "rawCode": "  private static void initMapGetTime() {\n    if (c_mapGetTime == 0) {\n      final Map<String, String> map = initMapPutTime();\n      final long startTime = System.nanoTime();\n      // measure MAX_OPERATIONS successful look ups as well as MAX_OPERATIONS unsuccessful look ups\n      // ...\n      for (int i = 0; i < MAX_OPERATIONS * 2; ++i) {\n        map.get(Integer.toString(i));\n      }\n      c_mapGetTime = System.nanoTime() - startTime;\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9230, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 400, "focalAPIEnd": 417, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toMilliseconds()"], "useStart": [385], "useEnd": [418], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Y3PP3R/AP2DX/tree/master/java/AP2DX/lib/jmockit/samples/TimingFramework/src/org/jdesktop/animation/timing/Animator.java", "rawCode": "  /**\n   * Starts the animation.\n   *\n   * @throws IllegalStateException if animation is already running; this command may only be run\n   *     prior to starting the animation or after the animation has ended\n   */\n  public void start() {\n    throwExceptionIfRunning();\n    hasBegun = false;\n    running = true;\n\n    // Initialize start time variables to current time.\n    startTime = toMilliseconds(System.nanoTime()) + startDelay;\n\n    if (duration != INFINITE && isStartAtIntermediateFraction()) {\n      float offsetFraction = direction == Direction.FORWARD ? startFraction : 1.0f - startFraction;\n      long startDelta = (long) (duration * offsetFraction);\n      startTime -= startDelta;\n    }\n\n    currentStartTime = startTime;\n    timer.start();\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9231, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 317, "focalAPIEnd": 334, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/walware/rj-core/tree/master/de.walware.rj.rpkg/src/de/walware/rj/server/jri/JRIServer.java", "rawCode": "  private void connectClient0(\n      final Client client, final ConsoleEngine consoleEngine, final ConsoleEngine export) {\n    disconnectClient0();\n\n    this.client0 = client;\n    this.client0Engine = consoleEngine;\n    this.client0ExpRef = export;\n    DefaultServerImpl.addClient(export);\n    this.client0LastPing = System.nanoTime();\n    this.serverState = S_CONNECTED;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9232, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 251, "tryExpressionEnd": 255, "tryBlockStart": 251, "tryBlockEnd": 9048, "catchExpressionStart": 8967, "catchExpressionEnd": 8987, "catchBlockStart": 8967, "catchBlockEnd": 9031, "exceptionHandlingCallStart": [9001], "exceptionHandlingCallEnd": [9024], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 1807, "focalAPIEnd": 1824, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["updateIncrementalXMLDatabase(File,File,)"], "useStart": [5560], "useEnd": [5618], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/EBIBioSamples/biosd_ui/tree/master/webapp/src/main/java/uk/ac/ebi/arrayexpress/jobs/IncrementalReloadBiosamplesJob.java", "rawCode": "  public void doExecute(JobExecutionContext jec) throws Exception {\n    logger.info(\"Incremental Reload of BioSamples data into the Application Server\");\n    File setupDirectory = null;\n    File backDir = null;\n    File setupTempDirectory = null;\n    try {\n\n      boolean updateActive =\n          Application.getInstance().getPreferences().getBoolean(\"bs.xmlupdate.active\");\n      logger.debug(\"Is Reloading Active?->\" + updateActive);\n\n      if (!updateActive) {\n        logger.error(\n            \"IncrementalReloadBiosamplesJob is trying to execute and the configuration does not allow that\");\n        this.getApplication()\n            .sendEmail(\n                null,\n                null,\n                \"BIOSAMPLES: WARNING\",\n                \"IncrementalReloadBiosamplesJob is trying to execute and the configuration does not allow that!\");\n        return;\n      }\n\n      // I will create a backup directory, where I will backup the Actual\n      // Setup directory, where I will put the new biosamples.xml and\n      // where I will creste a new SetupDirectory based on the new\n      // biosamples.xml\n      String setupDir = Application.getInstance().getPreferences().getString(\"bs.setupDirectory\");\n      logger.debug(\"setupDir->\" + setupDir);\n\n      setupDirectory = new File(setupDir);\n      String backupDirectory =\n          Application.getInstance().getPreferences().getString(\"bs.backupDirectory\");\n      logger.debug(\"backupDirectory->\" + backupDirectory);\n\n      String globalSetupDir =\n          Application.getInstance().getPreferences().getString(\"bs.globalSetupDirectory\");\n      logger.debug(\"globalSetupDirectory->\" + globalSetupDir);\n\n      // this variable will be used in the creation of the bakup\n      // directory anda in the creation od the database backup\n      Long tempDir = System.nanoTime();\n\n      String newDir = \"backup_\" + tempDir;\n      backDir = new File(backupDirectory + \"/\" + newDir);\n      if (backDir.mkdir()) {\n        logger.info(\"Backup directory was created in [{}]\", backDir.getAbsolutePath());\n\n      } else {\n        // TODO: rpe stop the process\n        logger.error(\"Backup directory was NOT created in [{}]\", backDir.getAbsolutePath());\n        throw new Exception(\"Backup directory was NOT created in \" + backDir.getAbsolutePath());\n      }\n\n      // DownloadBiosamplesXmlFileFromAGE dxml = new\n      // DownloadBiosamplesXmlFileFromAGE();\n      // I need to know which type of biosample updting process am I using\n      String typeBioSampleUpdate =\n          Application.getInstance().getPreferences().getString(\"bs.xmlupdate.type\");\n      logger.debug(\"Type of Biosamples updating process->\" + typeBioSampleUpdate);\n      IDownloadBiosamplesXmlFile dxml =\n          DownloadBiosamplesXmlFileFactory.createDownloadBiosamplesXmlFile(typeBioSampleUpdate);\n      File xmlDir = new File(backDir.getAbsolutePath() + \"/XmlDownload\");\n      if (xmlDir.mkdir()) {\n        logger.info(\"XmlDownload directory was created in [{}]\", xmlDir.getAbsolutePath());\n      } else {\n        logger.error(\"XmlDownload directory was NOT created in [{}]\", xmlDir.getAbsolutePath());\n        throw new Exception(\"XmlDownload directory was NOT created in \" + xmlDir.getAbsolutePath());\n      }\n      String downloadDirectory = xmlDir.getAbsolutePath();\n      boolean downloadOk = dxml.downloadXml(downloadDirectory);\n\n      if (downloadOk) {\n\n        File oldSetupDir = new File(backDir.getAbsolutePath() + \"/OldSetup\");\n        if (oldSetupDir.mkdir()) {\n          logger.info(\n              \"OldSetup Backup directory was created in [{}]\", oldSetupDir.getAbsolutePath());\n          copyDirectory(setupDirectory, oldSetupDir);\n        } else {\n          logger.error(\n              \"OldSetup Backup directory was NOT created in [{}]\", oldSetupDir.getAbsolutePath());\n          throw new Exception(\n              \"oldSetupDir Backup directory was NOT created in \" + oldSetupDir.getAbsolutePath());\n        }\n\n        // update of the xmlDatabase\n        logger.info(\"DatabaseXml Creation\");\n\n        // File newSetupDir= new File(backDir.getAbsolutePath() +\n        // \"/newSetup\" );\n        // I need to change this because it's not possible to move\n        // directories from a local disk (/tomcat/temp to NFS). So my\n        // all temporary Setup will be created in the same place where\n        // is the Setup Directory)\n        // getParentFile() to create at the same level of Setup\n        // directory\n        File newSetupDir = new File(setupDirectory.getParentFile().getAbsolutePath() + \"/newSetup\");\n\n        if (newSetupDir.exists()) {\n          // I will force the delete of the NewSetupDir (I need this\n          // because if for any reason the process fails once (before\n          // it renames nesSetup to Setup), the next time the process\n          // will always fail because the newSetup already exists\n          FileUtils.forceDelete(newSetupDir);\n        }\n        if (newSetupDir.mkdir()) {\n          logger.info(\"newSetupDir directory was created in [{}]\", newSetupDir.getAbsolutePath());\n        } else {\n          logger.error(\n              \"newSetupDir directory was NOT created in [{}]\", newSetupDir.getAbsolutePath());\n          throw new Exception(\n              \"newSetupDir directory was NOT created in \" + newSetupDir.getAbsolutePath());\n        }\n        // Now I need to copy the Setup luceneIndexes directory to the\n        // new Setup\n        FileUtils.copyDirectory(setupDirectory, newSetupDir);\n\n        // update in a temporary database\n        // index it in the newSetupDir\n        updateIncrementalXMLDatabase(xmlDir, newSetupDir, tempDir);\n        logger.info(\"End of DatabaseXml Creation\");\n        // only after update the database I update the Lucenes Indexes\n        logger.info(\n            \"Deleting Setup Directory and renaming - from now on the application is not answering\");\n\n        SearchEngine search = ((SearchEngine) getComponent(\"SearchEngine\"));\n\n        // I need to close the IndexReader otherwise it would not be\n        // possible dor me to delete the Setup directory (this problem\n        // only occurs on NFS);\n        search.getController().getEnvironment(\"biosamplesgroup\").closeIndexReader();\n        search.getController().getEnvironment(\"biosamplessample\").closeIndexReader();\n\n        // remove the old setupdirectory\n        deleteDirectory(setupDirectory);\n\n        // Rename file (or directory)\n        logger.info(\"Before file renamed!!!\");\n        boolean success2 = newSetupDir.renameTo(setupDirectory);\n        // FileUtilities.\n        if (success2) {\n          logger.info(\n              \"newSetupDir was successfully renamed to [{}]!!!\", setupDirectory.getAbsolutePath());\n          // need to remove the globalSetupDirectory e copy the new\n          // one to there\n          File globalSetupDirectory = new File(globalSetupDir);\n          if (globalSetupDirectory.exists()) {\n            FileUtils.forceDelete(globalSetupDirectory);\n          } else {\n            logger.info(\n                \"globalSetupDirectory doesnt exist!! [{}]!!!\",\n                globalSetupDirectory.getAbsolutePath());\n          }\n          FileUtils.copyDirectory(setupDirectory, globalSetupDirectory);\n\n        } else {\n          logger.error(\n              \"newSetupDir was not successfully renamed to [{}]!!!\",\n              setupDirectory.getAbsolutePath());\n          throw new Exception(\n              \"newSetupDir was not successfully renamed to [{}]!!!\"\n                  + setupDirectory.getAbsolutePath());\n        }\n        logger.info(\"Deleting Setup Directory and renaming - End\");\n\n        // I do this to know the number of elements\n        ((BioSamplesGroup) getComponent(\"BioSamplesGroup\")).reloadIndex();\n        // TODO: rpe nowaday I need to do this to clean the xmldatabase\n        // connection nad to reload the new index\n        ((IndexEnvironmentBiosamplesGroup) search.getController().getEnvironment(\"biosamplesgroup\"))\n            .setup();\n\n        ((BioSamplesSample) getComponent(\"BioSamplesSample\")).reloadIndex();\n        // TODO: rpe nowadays I need to do this to clean the xmldatabase\n        // connection nad to reload the new index\n        ((IndexEnvironmentBiosamplesSample)\n                search.getController().getEnvironment(\"biosamplessample\"))\n            .setup();\n\n        // / search.getController().getEnvironment(\"biosamplesgroup\")\n        // / .indexReader();\n        // / //I need to setupIt to point to the new Database\n        // / ((IndexEnvironmentBiosamplesGroup) search.getController()\n        // / .getEnvironment(\"biosamplesgroup\")).setup();\n        // / search.getController().getEnvironment(\"biosamplessample\").\n        // / indexReader();\n        // / ((IndexEnvironmentBiosamplesSample) search.getController()\n        // / .getEnvironment(\"biosamplessample\")).setup();\n        // TODO: RPE Update the EFO!!??\n\n      } else {\n        logger.debug(\"Something went wrong on Xml download\");\n      }\n\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    } finally {\n\n    }\n    logger.info(\"End of Reloading all Biosamples data into the Application Server\");\n\n    // I want to start using the new version of the data\n    // (/Users/rpslpereira/Apps/apache-tomcat-6.0.33/temp/StagingArea/4)\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9233, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 228, "focalAPIEnd": 245, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convert(,*)"], "useStart": [203], "useEnd": [268], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/sis/tree/master/core/sis-utility/src/main/java/org/apache/sis/internal/system/DelayedRunnable.java", "rawCode": "  /**\n   * Returns the delay to wait before to execute this task, or {@code 0} if this task shall be\n   * executed immediately.\n   */\n  @Override\n  public long getDelay(final TimeUnit unit) {\n    return unit.convert(timestamp - System.nanoTime(), TimeUnit.NANOSECONDS);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9234, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 219, "focalAPIEnd": 236, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [357], "useEnd": [374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/panmari/3d_geometry_processing/tree/master/framework/src/expr/Benchmark.java", "rawCode": "  static long timeRun(String expression) {\n    Variable x = Variable.make(\"x\");\n    Expr expr = parse(expression);\n\n    double low = 0.0;\n    double high = 4.0;\n    double step = (high - low) / nruns;\n\n    long start = System.nanoTime();\n    for (double xval = low; xval <= high; xval += step) {\n      x.setValue(xval);\n      expr.value();\n    }\n    return System.nanoTime() - start;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9235, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 77, "focalAPIEnd": 94, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craig-a-roach/geowx/tree/master/ebx/src/main/java/com/metservice/neon/ProfileSample.java", "rawCode": "  public long lineDone(long ntStart, int lineIndex) {\n    final long ntEnd = System.nanoTime();\n    final long nsElapsed = ntEnd - ntStart;\n    if (linesExecuted == 0) {\n      ntFirstLineStart = ntStart;\n    }\n    ntLatestLineEnd = ntEnd;\n    linesExecuted++;\n    program.lineDone(lineIndex, nsElapsed);\n    return ntEnd;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9236, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 712, "focalAPIEnd": 729, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["nanoTime()"], "finallyExpressionStart": 1111, "finallyExpressionEnd": 1119, "finallyBlockStart": 1111, "finallyBlockEnd": 1212, "cleanUpCallStart": [1167], "cleanUpCallEnd": [1184], "url": "https://github.com/mkeesey/guava-for-small-classpaths/tree/master/guava/src/com/google/common/util/concurrent/Monitor.java", "rawCode": "  /**\n   * Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\n   * the time to acquire the lock and the time to wait for the guard to be satisfied.\n   *\n   * @return whether the monitor was entered\n   */\n  public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean reentrant = lock.isHeldByCurrentThread();\n    boolean interruptIgnored = false;\n    try {\n      long remainingNanos;\n      if (!fair && lock.tryLock()) {\n        remainingNanos = unit.toNanos(time);\n      } else {\n        long startNanos = System.nanoTime();\n        long timeoutNanos = unit.toNanos(time);\n        remainingNanos = timeoutNanos;\n        while (true) {\n          try {\n            if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS)) {\n              break;\n            } else {\n              return false;\n            }\n          } catch (InterruptedException ignored) {\n            interruptIgnored = true;\n          } finally {\n            remainingNanos = (timeoutNanos - (System.nanoTime() - startNanos));\n          }\n        }\n      }\n      boolean satisfied = false;\n      try {\n        satisfied = waitUninterruptibly(guard, remainingNanos, reentrant);\n      } finally {\n        if (!satisfied) {\n          lock.unlock();\n        }\n      }\n      return satisfied;\n    } finally {\n      if (interruptIgnored) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9237, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 236, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [758], "useEnd": [775], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jamie-bates-8/Mario-Kart-GL/tree/master/Mario-Kart-OpenGL-Demo/src/bates/jamie/graphics/scene/Scene.java", "rawCode": "  /**\n   * This method renders the world geometry that represents the artificial boundaries of the virtual\n   * environment. This consists of the skybox and the terrain itself.\n   */\n  public long renderWorld(GL2 gl) {\n    long start = System.nanoTime();\n\n    renderTimes[frameIndex][1] = renderObstacles(gl);\n\n    Shader.disable(gl);\n\n    if (displayWalls) renderWalls(gl);\n    else brickWall.render(gl);\n\n    if (enableTerrain && !environmentMode) renderTimes[frameIndex][0] = renderTerrain(gl);\n    else {\n      if (displayWalls) renderFloor(gl);\n      renderTimes[frameIndex][0] = 0;\n    }\n\n    // gl.glPolygonMode(GL2.GL_FRONT_AND_BACK, GL2.GL_LINE);\n    // planeMesh.render(gl);\n    // gl.glPolygonMode(GL2.GL_FRONT_AND_BACK, GL2.GL_FILL);\n\n    return System.nanoTime() - start;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9238, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 364, "focalAPIEnd": 381, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [1079], "useEnd": [1096], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/phreenet/UMUC/tree/master/CMSC350/src/cmsc350/project3/SortAlgorithmTester.java", "rawCode": "  /**\n   * Insertion Sort Algorithm\n   *\n   * @param data : Array to be sorted\n   * @return SortingStatsNode containing runtime information on algorithm.\n   */\n  public static <T extends Comparable<? super T>> SortingStatsNode insertionSort(T[] data) {\n    SortingStatsNode stats = new SortingStatsNode(\"Insertion Sort\");\n    long c = 0, s = 0;\n    double start = System.nanoTime();\n\n    for (int index = 1; index < data.length; index++) {\n      T key = data[index];\n      int position = index;\n\n      // Shift larger values to the right\n      while (position > 0 && data[position - 1].compareTo(key) > 0) {\n        c += 1;\n        data[position] = data[position - 1];\n        position--; // Fixed error in book\n      }\n      // Java will short-circuit && op so we trade off a little run time speed so our comparison\n      // count is\n      // correct. Check to see if position > 0 meaning we did execute a compareTo event though we\n      // didn't\n      // execute the while.\n      if (position > 0) c += 1;\n      data[position] = key;\n      s += 1;\n    }\n\n    stats.setRunTime(System.nanoTime() - start);\n    stats.setComparisons(c);\n    stats.setSwaps(s);\n    return stats;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9239, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 28948, "focalAPIEnd": 28965, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [29217], "useEnd": [29234], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/achudars/Project-Euler/tree/master/PE042/src/PE042.java", "rawCode": "  public static void main(String[] args) {\n\n    String[] stringArray = {\n      \"A\",\n      \"ABILITY\",\n      \"ABLE\",\n      \"ABOUT\",\n      \"ABOVE\",\n      \"ABSENCE\",\n      \"ABSOLUTELY\",\n      \"ACADEMIC\",\n      \"ACCEPT\",\n      \"ACCESS\",\n      \"ACCIDENT\",\n      \"ACCOMPANY\",\n      \"ACCORDING\",\n      \"ACCOUNT\",\n      \"ACHIEVE\",\n      \"ACHIEVEMENT\",\n      \"ACID\",\n      \"ACQUIRE\",\n      \"ACROSS\",\n      \"ACT\",\n      \"ACTION\",\n      \"ACTIVE\",\n      \"ACTIVITY\",\n      \"ACTUAL\",\n      \"ACTUALLY\",\n      \"ADD\",\n      \"ADDITION\",\n      \"ADDITIONAL\",\n      \"ADDRESS\",\n      \"ADMINISTRATION\",\n      \"ADMIT\",\n      \"ADOPT\",\n      \"ADULT\",\n      \"ADVANCE\",\n      \"ADVANTAGE\",\n      \"ADVICE\",\n      \"ADVISE\",\n      \"AFFAIR\",\n      \"AFFECT\",\n      \"AFFORD\",\n      \"AFRAID\",\n      \"AFTER\",\n      \"AFTERNOON\",\n      \"AFTERWARDS\",\n      \"AGAIN\",\n      \"AGAINST\",\n      \"AGE\",\n      \"AGENCY\",\n      \"AGENT\",\n      \"AGO\",\n      \"AGREE\",\n      \"AGREEMENT\",\n      \"AHEAD\",\n      \"AID\",\n      \"AIM\",\n      \"AIR\",\n      \"AIRCRAFT\",\n      \"ALL\",\n      \"ALLOW\",\n      \"ALMOST\",\n      \"ALONE\",\n      \"ALONG\",\n      \"ALREADY\",\n      \"ALRIGHT\",\n      \"ALSO\",\n      \"ALTERNATIVE\",\n      \"ALTHOUGH\",\n      \"ALWAYS\",\n      \"AMONG\",\n      \"AMONGST\",\n      \"AMOUNT\",\n      \"AN\",\n      \"ANALYSIS\",\n      \"ANCIENT\",\n      \"AND\",\n      \"ANIMAL\",\n      \"ANNOUNCE\",\n      \"ANNUAL\",\n      \"ANOTHER\",\n      \"ANSWER\",\n      \"ANY\",\n      \"ANYBODY\",\n      \"ANYONE\",\n      \"ANYTHING\",\n      \"ANYWAY\",\n      \"APART\",\n      \"APPARENT\",\n      \"APPARENTLY\",\n      \"APPEAL\",\n      \"APPEAR\",\n      \"APPEARANCE\",\n      \"APPLICATION\",\n      \"APPLY\",\n      \"APPOINT\",\n      \"APPOINTMENT\",\n      \"APPROACH\",\n      \"APPROPRIATE\",\n      \"APPROVE\",\n      \"AREA\",\n      \"ARGUE\",\n      \"ARGUMENT\",\n      \"ARISE\",\n      \"ARM\",\n      \"ARMY\",\n      \"AROUND\",\n      \"ARRANGE\",\n      \"ARRANGEMENT\",\n      \"ARRIVE\",\n      \"ART\",\n      \"ARTICLE\",\n      \"ARTIST\",\n      \"AS\",\n      \"ASK\",\n      \"ASPECT\",\n      \"ASSEMBLY\",\n      \"ASSESS\",\n      \"ASSESSMENT\",\n      \"ASSET\",\n      \"ASSOCIATE\",\n      \"ASSOCIATION\",\n      \"ASSUME\",\n      \"ASSUMPTION\",\n      \"AT\",\n      \"ATMOSPHERE\",\n      \"ATTACH\",\n      \"ATTACK\",\n      \"ATTEMPT\",\n      \"ATTEND\",\n      \"ATTENTION\",\n      \"ATTITUDE\",\n      \"ATTRACT\",\n      \"ATTRACTIVE\",\n      \"AUDIENCE\",\n      \"AUTHOR\",\n      \"AUTHORITY\",\n      \"AVAILABLE\",\n      \"AVERAGE\",\n      \"AVOID\",\n      \"AWARD\",\n      \"AWARE\",\n      \"AWAY\",\n      \"AYE\",\n      \"BABY\",\n      \"BACK\",\n      \"BACKGROUND\",\n      \"BAD\",\n      \"BAG\",\n      \"BALANCE\",\n      \"BALL\",\n      \"BAND\",\n      \"BANK\",\n      \"BAR\",\n      \"BASE\",\n      \"BASIC\",\n      \"BASIS\",\n      \"BATTLE\",\n      \"BE\",\n      \"BEAR\",\n      \"BEAT\",\n      \"BEAUTIFUL\",\n      \"BECAUSE\",\n      \"BECOME\",\n      \"BED\",\n      \"BEDROOM\",\n      \"BEFORE\",\n      \"BEGIN\",\n      \"BEGINNING\",\n      \"BEHAVIOUR\",\n      \"BEHIND\",\n      \"BELIEF\",\n      \"BELIEVE\",\n      \"BELONG\",\n      \"BELOW\",\n      \"BENEATH\",\n      \"BENEFIT\",\n      \"BESIDE\",\n      \"BEST\",\n      \"BETTER\",\n      \"BETWEEN\",\n      \"BEYOND\",\n      \"BIG\",\n      \"BILL\",\n      \"BIND\",\n      \"BIRD\",\n      \"BIRTH\",\n      \"BIT\",\n      \"BLACK\",\n      \"BLOCK\",\n      \"BLOOD\",\n      \"BLOODY\",\n      \"BLOW\",\n      \"BLUE\",\n      \"BOARD\",\n      \"BOAT\",\n      \"BODY\",\n      \"BONE\",\n      \"BOOK\",\n      \"BORDER\",\n      \"BOTH\",\n      \"BOTTLE\",\n      \"BOTTOM\",\n      \"BOX\",\n      \"BOY\",\n      \"BRAIN\",\n      \"BRANCH\",\n      \"BREAK\",\n      \"BREATH\",\n      \"BRIDGE\",\n      \"BRIEF\",\n      \"BRIGHT\",\n      \"BRING\",\n      \"BROAD\",\n      \"BROTHER\",\n      \"BUDGET\",\n      \"BUILD\",\n      \"BUILDING\",\n      \"BURN\",\n      \"BUS\",\n      \"BUSINESS\",\n      \"BUSY\",\n      \"BUT\",\n      \"BUY\",\n      \"BY\",\n      \"CABINET\",\n      \"CALL\",\n      \"CAMPAIGN\",\n      \"CAN\",\n      \"CANDIDATE\",\n      \"CAPABLE\",\n      \"CAPACITY\",\n      \"CAPITAL\",\n      \"CAR\",\n      \"CARD\",\n      \"CARE\",\n      \"CAREER\",\n      \"CAREFUL\",\n      \"CAREFULLY\",\n      \"CARRY\",\n      \"CASE\",\n      \"CASH\",\n      \"CAT\",\n      \"CATCH\",\n      \"CATEGORY\",\n      \"CAUSE\",\n      \"CELL\",\n      \"CENTRAL\",\n      \"CENTRE\",\n      \"CENTURY\",\n      \"CERTAIN\",\n      \"CERTAINLY\",\n      \"CHAIN\",\n      \"CHAIR\",\n      \"CHAIRMAN\",\n      \"CHALLENGE\",\n      \"CHANCE\",\n      \"CHANGE\",\n      \"CHANNEL\",\n      \"CHAPTER\",\n      \"CHARACTER\",\n      \"CHARACTERISTIC\",\n      \"CHARGE\",\n      \"CHEAP\",\n      \"CHECK\",\n      \"CHEMICAL\",\n      \"CHIEF\",\n      \"CHILD\",\n      \"CHOICE\",\n      \"CHOOSE\",\n      \"CHURCH\",\n      \"CIRCLE\",\n      \"CIRCUMSTANCE\",\n      \"CITIZEN\",\n      \"CITY\",\n      \"CIVIL\",\n      \"CLAIM\",\n      \"CLASS\",\n      \"CLEAN\",\n      \"CLEAR\",\n      \"CLEARLY\",\n      \"CLIENT\",\n      \"CLIMB\",\n      \"CLOSE\",\n      \"CLOSELY\",\n      \"CLOTHES\",\n      \"CLUB\",\n      \"COAL\",\n      \"CODE\",\n      \"COFFEE\",\n      \"COLD\",\n      \"COLLEAGUE\",\n      \"COLLECT\",\n      \"COLLECTION\",\n      \"COLLEGE\",\n      \"COLOUR\",\n      \"COMBINATION\",\n      \"COMBINE\",\n      \"COME\",\n      \"COMMENT\",\n      \"COMMERCIAL\",\n      \"COMMISSION\",\n      \"COMMIT\",\n      \"COMMITMENT\",\n      \"COMMITTEE\",\n      \"COMMON\",\n      \"COMMUNICATION\",\n      \"COMMUNITY\",\n      \"COMPANY\",\n      \"COMPARE\",\n      \"COMPARISON\",\n      \"COMPETITION\",\n      \"COMPLETE\",\n      \"COMPLETELY\",\n      \"COMPLEX\",\n      \"COMPONENT\",\n      \"COMPUTER\",\n      \"CONCENTRATE\",\n      \"CONCENTRATION\",\n      \"CONCEPT\",\n      \"CONCERN\",\n      \"CONCERNED\",\n      \"CONCLUDE\",\n      \"CONCLUSION\",\n      \"CONDITION\",\n      \"CONDUCT\",\n      \"CONFERENCE\",\n      \"CONFIDENCE\",\n      \"CONFIRM\",\n      \"CONFLICT\",\n      \"CONGRESS\",\n      \"CONNECT\",\n      \"CONNECTION\",\n      \"CONSEQUENCE\",\n      \"CONSERVATIVE\",\n      \"CONSIDER\",\n      \"CONSIDERABLE\",\n      \"CONSIDERATION\",\n      \"CONSIST\",\n      \"CONSTANT\",\n      \"CONSTRUCTION\",\n      \"CONSUMER\",\n      \"CONTACT\",\n      \"CONTAIN\",\n      \"CONTENT\",\n      \"CONTEXT\",\n      \"CONTINUE\",\n      \"CONTRACT\",\n      \"CONTRAST\",\n      \"CONTRIBUTE\",\n      \"CONTRIBUTION\",\n      \"CONTROL\",\n      \"CONVENTION\",\n      \"CONVERSATION\",\n      \"COPY\",\n      \"CORNER\",\n      \"CORPORATE\",\n      \"CORRECT\",\n      \"COS\",\n      \"COST\",\n      \"COULD\",\n      \"COUNCIL\",\n      \"COUNT\",\n      \"COUNTRY\",\n      \"COUNTY\",\n      \"COUPLE\",\n      \"COURSE\",\n      \"COURT\",\n      \"COVER\",\n      \"CREATE\",\n      \"CREATION\",\n      \"CREDIT\",\n      \"CRIME\",\n      \"CRIMINAL\",\n      \"CRISIS\",\n      \"CRITERION\",\n      \"CRITICAL\",\n      \"CRITICISM\",\n      \"CROSS\",\n      \"CROWD\",\n      \"CRY\",\n      \"CULTURAL\",\n      \"CULTURE\",\n      \"CUP\",\n      \"CURRENT\",\n      \"CURRENTLY\",\n      \"CURRICULUM\",\n      \"CUSTOMER\",\n      \"CUT\",\n      \"DAMAGE\",\n      \"DANGER\",\n      \"DANGEROUS\",\n      \"DARK\",\n      \"DATA\",\n      \"DATE\",\n      \"DAUGHTER\",\n      \"DAY\",\n      \"DEAD\",\n      \"DEAL\",\n      \"DEATH\",\n      \"DEBATE\",\n      \"DEBT\",\n      \"DECADE\",\n      \"DECIDE\",\n      \"DECISION\",\n      \"DECLARE\",\n      \"DEEP\",\n      \"DEFENCE\",\n      \"DEFENDANT\",\n      \"DEFINE\",\n      \"DEFINITION\",\n      \"DEGREE\",\n      \"DELIVER\",\n      \"DEMAND\",\n      \"DEMOCRATIC\",\n      \"DEMONSTRATE\",\n      \"DENY\",\n      \"DEPARTMENT\",\n      \"DEPEND\",\n      \"DEPUTY\",\n      \"DERIVE\",\n      \"DESCRIBE\",\n      \"DESCRIPTION\",\n      \"DESIGN\",\n      \"DESIRE\",\n      \"DESK\",\n      \"DESPITE\",\n      \"DESTROY\",\n      \"DETAIL\",\n      \"DETAILED\",\n      \"DETERMINE\",\n      \"DEVELOP\",\n      \"DEVELOPMENT\",\n      \"DEVICE\",\n      \"DIE\",\n      \"DIFFERENCE\",\n      \"DIFFERENT\",\n      \"DIFFICULT\",\n      \"DIFFICULTY\",\n      \"DINNER\",\n      \"DIRECT\",\n      \"DIRECTION\",\n      \"DIRECTLY\",\n      \"DIRECTOR\",\n      \"DISAPPEAR\",\n      \"DISCIPLINE\",\n      \"DISCOVER\",\n      \"DISCUSS\",\n      \"DISCUSSION\",\n      \"DISEASE\",\n      \"DISPLAY\",\n      \"DISTANCE\",\n      \"DISTINCTION\",\n      \"DISTRIBUTION\",\n      \"DISTRICT\",\n      \"DIVIDE\",\n      \"DIVISION\",\n      \"DO\",\n      \"DOCTOR\",\n      \"DOCUMENT\",\n      \"DOG\",\n      \"DOMESTIC\",\n      \"DOOR\",\n      \"DOUBLE\",\n      \"DOUBT\",\n      \"DOWN\",\n      \"DRAW\",\n      \"DRAWING\",\n      \"DREAM\",\n      \"DRESS\",\n      \"DRINK\",\n      \"DRIVE\",\n      \"DRIVER\",\n      \"DROP\",\n      \"DRUG\",\n      \"DRY\",\n      \"DUE\",\n      \"DURING\",\n      \"DUTY\",\n      \"EACH\",\n      \"EAR\",\n      \"EARLY\",\n      \"EARN\",\n      \"EARTH\",\n      \"EASILY\",\n      \"EAST\",\n      \"EASY\",\n      \"EAT\",\n      \"ECONOMIC\",\n      \"ECONOMY\",\n      \"EDGE\",\n      \"EDITOR\",\n      \"EDUCATION\",\n      \"EDUCATIONAL\",\n      \"EFFECT\",\n      \"EFFECTIVE\",\n      \"EFFECTIVELY\",\n      \"EFFORT\",\n      \"EGG\",\n      \"EITHER\",\n      \"ELDERLY\",\n      \"ELECTION\",\n      \"ELEMENT\",\n      \"ELSE\",\n      \"ELSEWHERE\",\n      \"EMERGE\",\n      \"EMPHASIS\",\n      \"EMPLOY\",\n      \"EMPLOYEE\",\n      \"EMPLOYER\",\n      \"EMPLOYMENT\",\n      \"EMPTY\",\n      \"ENABLE\",\n      \"ENCOURAGE\",\n      \"END\",\n      \"ENEMY\",\n      \"ENERGY\",\n      \"ENGINE\",\n      \"ENGINEERING\",\n      \"ENJOY\",\n      \"ENOUGH\",\n      \"ENSURE\",\n      \"ENTER\",\n      \"ENTERPRISE\",\n      \"ENTIRE\",\n      \"ENTIRELY\",\n      \"ENTITLE\",\n      \"ENTRY\",\n      \"ENVIRONMENT\",\n      \"ENVIRONMENTAL\",\n      \"EQUAL\",\n      \"EQUALLY\",\n      \"EQUIPMENT\",\n      \"ERROR\",\n      \"ESCAPE\",\n      \"ESPECIALLY\",\n      \"ESSENTIAL\",\n      \"ESTABLISH\",\n      \"ESTABLISHMENT\",\n      \"ESTATE\",\n      \"ESTIMATE\",\n      \"EVEN\",\n      \"EVENING\",\n      \"EVENT\",\n      \"EVENTUALLY\",\n      \"EVER\",\n      \"EVERY\",\n      \"EVERYBODY\",\n      \"EVERYONE\",\n      \"EVERYTHING\",\n      \"EVIDENCE\",\n      \"EXACTLY\",\n      \"EXAMINATION\",\n      \"EXAMINE\",\n      \"EXAMPLE\",\n      \"EXCELLENT\",\n      \"EXCEPT\",\n      \"EXCHANGE\",\n      \"EXECUTIVE\",\n      \"EXERCISE\",\n      \"EXHIBITION\",\n      \"EXIST\",\n      \"EXISTENCE\",\n      \"EXISTING\",\n      \"EXPECT\",\n      \"EXPECTATION\",\n      \"EXPENDITURE\",\n      \"EXPENSE\",\n      \"EXPENSIVE\",\n      \"EXPERIENCE\",\n      \"EXPERIMENT\",\n      \"EXPERT\",\n      \"EXPLAIN\",\n      \"EXPLANATION\",\n      \"EXPLORE\",\n      \"EXPRESS\",\n      \"EXPRESSION\",\n      \"EXTEND\",\n      \"EXTENT\",\n      \"EXTERNAL\",\n      \"EXTRA\",\n      \"EXTREMELY\",\n      \"EYE\",\n      \"FACE\",\n      \"FACILITY\",\n      \"FACT\",\n      \"FACTOR\",\n      \"FACTORY\",\n      \"FAIL\",\n      \"FAILURE\",\n      \"FAIR\",\n      \"FAIRLY\",\n      \"FAITH\",\n      \"FALL\",\n      \"FAMILIAR\",\n      \"FAMILY\",\n      \"FAMOUS\",\n      \"FAR\",\n      \"FARM\",\n      \"FARMER\",\n      \"FASHION\",\n      \"FAST\",\n      \"FATHER\",\n      \"FAVOUR\",\n      \"FEAR\",\n      \"FEATURE\",\n      \"FEE\",\n      \"FEEL\",\n      \"FEELING\",\n      \"FEMALE\",\n      \"FEW\",\n      \"FIELD\",\n      \"FIGHT\",\n      \"FIGURE\",\n      \"FILE\",\n      \"FILL\",\n      \"FILM\",\n      \"FINAL\",\n      \"FINALLY\",\n      \"FINANCE\",\n      \"FINANCIAL\",\n      \"FIND\",\n      \"FINDING\",\n      \"FINE\",\n      \"FINGER\",\n      \"FINISH\",\n      \"FIRE\",\n      \"FIRM\",\n      \"FIRST\",\n      \"FISH\",\n      \"FIT\",\n      \"FIX\",\n      \"FLAT\",\n      \"FLIGHT\",\n      \"FLOOR\",\n      \"FLOW\",\n      \"FLOWER\",\n      \"FLY\",\n      \"FOCUS\",\n      \"FOLLOW\",\n      \"FOLLOWING\",\n      \"FOOD\",\n      \"FOOT\",\n      \"FOOTBALL\",\n      \"FOR\",\n      \"FORCE\",\n      \"FOREIGN\",\n      \"FOREST\",\n      \"FORGET\",\n      \"FORM\",\n      \"FORMAL\",\n      \"FORMER\",\n      \"FORWARD\",\n      \"FOUNDATION\",\n      \"FREE\",\n      \"FREEDOM\",\n      \"FREQUENTLY\",\n      \"FRESH\",\n      \"FRIEND\",\n      \"FROM\",\n      \"FRONT\",\n      \"FRUIT\",\n      \"FUEL\",\n      \"FULL\",\n      \"FULLY\",\n      \"FUNCTION\",\n      \"FUND\",\n      \"FUNNY\",\n      \"FURTHER\",\n      \"FUTURE\",\n      \"GAIN\",\n      \"GAME\",\n      \"GARDEN\",\n      \"GAS\",\n      \"GATE\",\n      \"GATHER\",\n      \"GENERAL\",\n      \"GENERALLY\",\n      \"GENERATE\",\n      \"GENERATION\",\n      \"GENTLEMAN\",\n      \"GET\",\n      \"GIRL\",\n      \"GIVE\",\n      \"GLASS\",\n      \"GO\",\n      \"GOAL\",\n      \"GOD\",\n      \"GOLD\",\n      \"GOOD\",\n      \"GOVERNMENT\",\n      \"GRANT\",\n      \"GREAT\",\n      \"GREEN\",\n      \"GREY\",\n      \"GROUND\",\n      \"GROUP\",\n      \"GROW\",\n      \"GROWING\",\n      \"GROWTH\",\n      \"GUEST\",\n      \"GUIDE\",\n      \"GUN\",\n      \"HAIR\",\n      \"HALF\",\n      \"HALL\",\n      \"HAND\",\n      \"HANDLE\",\n      \"HANG\",\n      \"HAPPEN\",\n      \"HAPPY\",\n      \"HARD\",\n      \"HARDLY\",\n      \"HATE\",\n      \"HAVE\",\n      \"HE\",\n      \"HEAD\",\n      \"HEALTH\",\n      \"HEAR\",\n      \"HEART\",\n      \"HEAT\",\n      \"HEAVY\",\n      \"HELL\",\n      \"HELP\",\n      \"HENCE\",\n      \"HER\",\n      \"HERE\",\n      \"HERSELF\",\n      \"HIDE\",\n      \"HIGH\",\n      \"HIGHLY\",\n      \"HILL\",\n      \"HIM\",\n      \"HIMSELF\",\n      \"HIS\",\n      \"HISTORICAL\",\n      \"HISTORY\",\n      \"HIT\",\n      \"HOLD\",\n      \"HOLE\",\n      \"HOLIDAY\",\n      \"HOME\",\n      \"HOPE\",\n      \"HORSE\",\n      \"HOSPITAL\",\n      \"HOT\",\n      \"HOTEL\",\n      \"HOUR\",\n      \"HOUSE\",\n      \"HOUSEHOLD\",\n      \"HOUSING\",\n      \"HOW\",\n      \"HOWEVER\",\n      \"HUGE\",\n      \"HUMAN\",\n      \"HURT\",\n      \"HUSBAND\",\n      \"I\",\n      \"IDEA\",\n      \"IDENTIFY\",\n      \"IF\",\n      \"IGNORE\",\n      \"ILLUSTRATE\",\n      \"IMAGE\",\n      \"IMAGINE\",\n      \"IMMEDIATE\",\n      \"IMMEDIATELY\",\n      \"IMPACT\",\n      \"IMPLICATION\",\n      \"IMPLY\",\n      \"IMPORTANCE\",\n      \"IMPORTANT\",\n      \"IMPOSE\",\n      \"IMPOSSIBLE\",\n      \"IMPRESSION\",\n      \"IMPROVE\",\n      \"IMPROVEMENT\",\n      \"IN\",\n      \"INCIDENT\",\n      \"INCLUDE\",\n      \"INCLUDING\",\n      \"INCOME\",\n      \"INCREASE\",\n      \"INCREASED\",\n      \"INCREASINGLY\",\n      \"INDEED\",\n      \"INDEPENDENT\",\n      \"INDEX\",\n      \"INDICATE\",\n      \"INDIVIDUAL\",\n      \"INDUSTRIAL\",\n      \"INDUSTRY\",\n      \"INFLUENCE\",\n      \"INFORM\",\n      \"INFORMATION\",\n      \"INITIAL\",\n      \"INITIATIVE\",\n      \"INJURY\",\n      \"INSIDE\",\n      \"INSIST\",\n      \"INSTANCE\",\n      \"INSTEAD\",\n      \"INSTITUTE\",\n      \"INSTITUTION\",\n      \"INSTRUCTION\",\n      \"INSTRUMENT\",\n      \"INSURANCE\",\n      \"INTEND\",\n      \"INTENTION\",\n      \"INTEREST\",\n      \"INTERESTED\",\n      \"INTERESTING\",\n      \"INTERNAL\",\n      \"INTERNATIONAL\",\n      \"INTERPRETATION\",\n      \"INTERVIEW\",\n      \"INTO\",\n      \"INTRODUCE\",\n      \"INTRODUCTION\",\n      \"INVESTIGATE\",\n      \"INVESTIGATION\",\n      \"INVESTMENT\",\n      \"INVITE\",\n      \"INVOLVE\",\n      \"IRON\",\n      \"IS\",\n      \"ISLAND\",\n      \"ISSUE\",\n      \"IT\",\n      \"ITEM\",\n      \"ITS\",\n      \"ITSELF\",\n      \"JOB\",\n      \"JOIN\",\n      \"JOINT\",\n      \"JOURNEY\",\n      \"JUDGE\",\n      \"JUMP\",\n      \"JUST\",\n      \"JUSTICE\",\n      \"KEEP\",\n      \"KEY\",\n      \"KID\",\n      \"KILL\",\n      \"KIND\",\n      \"KING\",\n      \"KITCHEN\",\n      \"KNEE\",\n      \"KNOW\",\n      \"KNOWLEDGE\",\n      \"LABOUR\",\n      \"LACK\",\n      \"LADY\",\n      \"LAND\",\n      \"LANGUAGE\",\n      \"LARGE\",\n      \"LARGELY\",\n      \"LAST\",\n      \"LATE\",\n      \"LATER\",\n      \"LATTER\",\n      \"LAUGH\",\n      \"LAUNCH\",\n      \"LAW\",\n      \"LAWYER\",\n      \"LAY\",\n      \"LEAD\",\n      \"LEADER\",\n      \"LEADERSHIP\",\n      \"LEADING\",\n      \"LEAF\",\n      \"LEAGUE\",\n      \"LEAN\",\n      \"LEARN\",\n      \"LEAST\",\n      \"LEAVE\",\n      \"LEFT\",\n      \"LEG\",\n      \"LEGAL\",\n      \"LEGISLATION\",\n      \"LENGTH\",\n      \"LESS\",\n      \"LET\",\n      \"LETTER\",\n      \"LEVEL\",\n      \"LIABILITY\",\n      \"LIBERAL\",\n      \"LIBRARY\",\n      \"LIE\",\n      \"LIFE\",\n      \"LIFT\",\n      \"LIGHT\",\n      \"LIKE\",\n      \"LIKELY\",\n      \"LIMIT\",\n      \"LIMITED\",\n      \"LINE\",\n      \"LINK\",\n      \"LIP\",\n      \"LIST\",\n      \"LISTEN\",\n      \"LITERATURE\",\n      \"LITTLE\",\n      \"LIVE\",\n      \"LIVING\",\n      \"LOAN\",\n      \"LOCAL\",\n      \"LOCATION\",\n      \"LONG\",\n      \"LOOK\",\n      \"LORD\",\n      \"LOSE\",\n      \"LOSS\",\n      \"LOT\",\n      \"LOVE\",\n      \"LOVELY\",\n      \"LOW\",\n      \"LUNCH\",\n      \"MACHINE\",\n      \"MAGAZINE\",\n      \"MAIN\",\n      \"MAINLY\",\n      \"MAINTAIN\",\n      \"MAJOR\",\n      \"MAJORITY\",\n      \"MAKE\",\n      \"MALE\",\n      \"MAN\",\n      \"MANAGE\",\n      \"MANAGEMENT\",\n      \"MANAGER\",\n      \"MANNER\",\n      \"MANY\",\n      \"MAP\",\n      \"MARK\",\n      \"MARKET\",\n      \"MARRIAGE\",\n      \"MARRIED\",\n      \"MARRY\",\n      \"MASS\",\n      \"MASTER\",\n      \"MATCH\",\n      \"MATERIAL\",\n      \"MATTER\",\n      \"MAY\",\n      \"MAYBE\",\n      \"ME\",\n      \"MEAL\",\n      \"MEAN\",\n      \"MEANING\",\n      \"MEANS\",\n      \"MEANWHILE\",\n      \"MEASURE\",\n      \"MECHANISM\",\n      \"MEDIA\",\n      \"MEDICAL\",\n      \"MEET\",\n      \"MEETING\",\n      \"MEMBER\",\n      \"MEMBERSHIP\",\n      \"MEMORY\",\n      \"MENTAL\",\n      \"MENTION\",\n      \"MERELY\",\n      \"MESSAGE\",\n      \"METAL\",\n      \"METHOD\",\n      \"MIDDLE\",\n      \"MIGHT\",\n      \"MILE\",\n      \"MILITARY\",\n      \"MILK\",\n      \"MIND\",\n      \"MINE\",\n      \"MINISTER\",\n      \"MINISTRY\",\n      \"MINUTE\",\n      \"MISS\",\n      \"MISTAKE\",\n      \"MODEL\",\n      \"MODERN\",\n      \"MODULE\",\n      \"MOMENT\",\n      \"MONEY\",\n      \"MONTH\",\n      \"MORE\",\n      \"MORNING\",\n      \"MOST\",\n      \"MOTHER\",\n      \"MOTION\",\n      \"MOTOR\",\n      \"MOUNTAIN\",\n      \"MOUTH\",\n      \"MOVE\",\n      \"MOVEMENT\",\n      \"MUCH\",\n      \"MURDER\",\n      \"MUSEUM\",\n      \"MUSIC\",\n      \"MUST\",\n      \"MY\",\n      \"MYSELF\",\n      \"NAME\",\n      \"NARROW\",\n      \"NATION\",\n      \"NATIONAL\",\n      \"NATURAL\",\n      \"NATURE\",\n      \"NEAR\",\n      \"NEARLY\",\n      \"NECESSARILY\",\n      \"NECESSARY\",\n      \"NECK\",\n      \"NEED\",\n      \"NEGOTIATION\",\n      \"NEIGHBOUR\",\n      \"NEITHER\",\n      \"NETWORK\",\n      \"NEVER\",\n      \"NEVERTHELESS\",\n      \"NEW\",\n      \"NEWS\",\n      \"NEWSPAPER\",\n      \"NEXT\",\n      \"NICE\",\n      \"NIGHT\",\n      \"NO\",\n      \"NOBODY\",\n      \"NOD\",\n      \"NOISE\",\n      \"NONE\",\n      \"NOR\",\n      \"NORMAL\",\n      \"NORMALLY\",\n      \"NORTH\",\n      \"NORTHERN\",\n      \"NOSE\",\n      \"NOT\",\n      \"NOTE\",\n      \"NOTHING\",\n      \"NOTICE\",\n      \"NOTION\",\n      \"NOW\",\n      \"NUCLEAR\",\n      \"NUMBER\",\n      \"NURSE\",\n      \"OBJECT\",\n      \"OBJECTIVE\",\n      \"OBSERVATION\",\n      \"OBSERVE\",\n      \"OBTAIN\",\n      \"OBVIOUS\",\n      \"OBVIOUSLY\",\n      \"OCCASION\",\n      \"OCCUR\",\n      \"ODD\",\n      \"OF\",\n      \"OFF\",\n      \"OFFENCE\",\n      \"OFFER\",\n      \"OFFICE\",\n      \"OFFICER\",\n      \"OFFICIAL\",\n      \"OFTEN\",\n      \"OIL\",\n      \"OKAY\",\n      \"OLD\",\n      \"ON\",\n      \"ONCE\",\n      \"ONE\",\n      \"ONLY\",\n      \"ONTO\",\n      \"OPEN\",\n      \"OPERATE\",\n      \"OPERATION\",\n      \"OPINION\",\n      \"OPPORTUNITY\",\n      \"OPPOSITION\",\n      \"OPTION\",\n      \"OR\",\n      \"ORDER\",\n      \"ORDINARY\",\n      \"ORGANISATION\",\n      \"ORGANISE\",\n      \"ORGANIZATION\",\n      \"ORIGIN\",\n      \"ORIGINAL\",\n      \"OTHER\",\n      \"OTHERWISE\",\n      \"OUGHT\",\n      \"OUR\",\n      \"OURSELVES\",\n      \"OUT\",\n      \"OUTCOME\",\n      \"OUTPUT\",\n      \"OUTSIDE\",\n      \"OVER\",\n      \"OVERALL\",\n      \"OWN\",\n      \"OWNER\",\n      \"PACKAGE\",\n      \"PAGE\",\n      \"PAIN\",\n      \"PAINT\",\n      \"PAINTING\",\n      \"PAIR\",\n      \"PANEL\",\n      \"PAPER\",\n      \"PARENT\",\n      \"PARK\",\n      \"PARLIAMENT\",\n      \"PART\",\n      \"PARTICULAR\",\n      \"PARTICULARLY\",\n      \"PARTLY\",\n      \"PARTNER\",\n      \"PARTY\",\n      \"PASS\",\n      \"PASSAGE\",\n      \"PAST\",\n      \"PATH\",\n      \"PATIENT\",\n      \"PATTERN\",\n      \"PAY\",\n      \"PAYMENT\",\n      \"PEACE\",\n      \"PENSION\",\n      \"PEOPLE\",\n      \"PER\",\n      \"PERCENT\",\n      \"PERFECT\",\n      \"PERFORM\",\n      \"PERFORMANCE\",\n      \"PERHAPS\",\n      \"PERIOD\",\n      \"PERMANENT\",\n      \"PERSON\",\n      \"PERSONAL\",\n      \"PERSUADE\",\n      \"PHASE\",\n      \"PHONE\",\n      \"PHOTOGRAPH\",\n      \"PHYSICAL\",\n      \"PICK\",\n      \"PICTURE\",\n      \"PIECE\",\n      \"PLACE\",\n      \"PLAN\",\n      \"PLANNING\",\n      \"PLANT\",\n      \"PLASTIC\",\n      \"PLATE\",\n      \"PLAY\",\n      \"PLAYER\",\n      \"PLEASE\",\n      \"PLEASURE\",\n      \"PLENTY\",\n      \"PLUS\",\n      \"POCKET\",\n      \"POINT\",\n      \"POLICE\",\n      \"POLICY\",\n      \"POLITICAL\",\n      \"POLITICS\",\n      \"POOL\",\n      \"POOR\",\n      \"POPULAR\",\n      \"POPULATION\",\n      \"POSITION\",\n      \"POSITIVE\",\n      \"POSSIBILITY\",\n      \"POSSIBLE\",\n      \"POSSIBLY\",\n      \"POST\",\n      \"POTENTIAL\",\n      \"POUND\",\n      \"POWER\",\n      \"POWERFUL\",\n      \"PRACTICAL\",\n      \"PRACTICE\",\n      \"PREFER\",\n      \"PREPARE\",\n      \"PRESENCE\",\n      \"PRESENT\",\n      \"PRESIDENT\",\n      \"PRESS\",\n      \"PRESSURE\",\n      \"PRETTY\",\n      \"PREVENT\",\n      \"PREVIOUS\",\n      \"PREVIOUSLY\",\n      \"PRICE\",\n      \"PRIMARY\",\n      \"PRIME\",\n      \"PRINCIPLE\",\n      \"PRIORITY\",\n      \"PRISON\",\n      \"PRISONER\",\n      \"PRIVATE\",\n      \"PROBABLY\",\n      \"PROBLEM\",\n      \"PROCEDURE\",\n      \"PROCESS\",\n      \"PRODUCE\",\n      \"PRODUCT\",\n      \"PRODUCTION\",\n      \"PROFESSIONAL\",\n      \"PROFIT\",\n      \"PROGRAM\",\n      \"PROGRAMME\",\n      \"PROGRESS\",\n      \"PROJECT\",\n      \"PROMISE\",\n      \"PROMOTE\",\n      \"PROPER\",\n      \"PROPERLY\",\n      \"PROPERTY\",\n      \"PROPORTION\",\n      \"PROPOSE\",\n      \"PROPOSAL\",\n      \"PROSPECT\",\n      \"PROTECT\",\n      \"PROTECTION\",\n      \"PROVE\",\n      \"PROVIDE\",\n      \"PROVIDED\",\n      \"PROVISION\",\n      \"PUB\",\n      \"PUBLIC\",\n      \"PUBLICATION\",\n      \"PUBLISH\",\n      \"PULL\",\n      \"PUPIL\",\n      \"PURPOSE\",\n      \"PUSH\",\n      \"PUT\",\n      \"QUALITY\",\n      \"QUARTER\",\n      \"QUESTION\",\n      \"QUICK\",\n      \"QUICKLY\",\n      \"QUIET\",\n      \"QUITE\",\n      \"RACE\",\n      \"RADIO\",\n      \"RAILWAY\",\n      \"RAIN\",\n      \"RAISE\",\n      \"RANGE\",\n      \"RAPIDLY\",\n      \"RARE\",\n      \"RATE\",\n      \"RATHER\",\n      \"REACH\",\n      \"REACTION\",\n      \"READ\",\n      \"READER\",\n      \"READING\",\n      \"READY\",\n      \"REAL\",\n      \"REALISE\",\n      \"REALITY\",\n      \"REALIZE\",\n      \"REALLY\",\n      \"REASON\",\n      \"REASONABLE\",\n      \"RECALL\",\n      \"RECEIVE\",\n      \"RECENT\",\n      \"RECENTLY\",\n      \"RECOGNISE\",\n      \"RECOGNITION\",\n      \"RECOGNIZE\",\n      \"RECOMMEND\",\n      \"RECORD\",\n      \"RECOVER\",\n      \"RED\",\n      \"REDUCE\",\n      \"REDUCTION\",\n      \"REFER\",\n      \"REFERENCE\",\n      \"REFLECT\",\n      \"REFORM\",\n      \"REFUSE\",\n      \"REGARD\",\n      \"REGION\",\n      \"REGIONAL\",\n      \"REGULAR\",\n      \"REGULATION\",\n      \"REJECT\",\n      \"RELATE\",\n      \"RELATION\",\n      \"RELATIONSHIP\",\n      \"RELATIVE\",\n      \"RELATIVELY\",\n      \"RELEASE\",\n      \"RELEVANT\",\n      \"RELIEF\",\n      \"RELIGION\",\n      \"RELIGIOUS\",\n      \"RELY\",\n      \"REMAIN\",\n      \"REMEMBER\",\n      \"REMIND\",\n      \"REMOVE\",\n      \"REPEAT\",\n      \"REPLACE\",\n      \"REPLY\",\n      \"REPORT\",\n      \"REPRESENT\",\n      \"REPRESENTATION\",\n      \"REPRESENTATIVE\",\n      \"REQUEST\",\n      \"REQUIRE\",\n      \"REQUIREMENT\",\n      \"RESEARCH\",\n      \"RESOURCE\",\n      \"RESPECT\",\n      \"RESPOND\",\n      \"RESPONSE\",\n      \"RESPONSIBILITY\",\n      \"RESPONSIBLE\",\n      \"REST\",\n      \"RESTAURANT\",\n      \"RESULT\",\n      \"RETAIN\",\n      \"RETURN\",\n      \"REVEAL\",\n      \"REVENUE\",\n      \"REVIEW\",\n      \"REVOLUTION\",\n      \"RICH\",\n      \"RIDE\",\n      \"RIGHT\",\n      \"RING\",\n      \"RISE\",\n      \"RISK\",\n      \"RIVER\",\n      \"ROAD\",\n      \"ROCK\",\n      \"ROLE\",\n      \"ROLL\",\n      \"ROOF\",\n      \"ROOM\",\n      \"ROUND\",\n      \"ROUTE\",\n      \"ROW\",\n      \"ROYAL\",\n      \"RULE\",\n      \"RUN\",\n      \"RURAL\",\n      \"SAFE\",\n      \"SAFETY\",\n      \"SALE\",\n      \"SAME\",\n      \"SAMPLE\",\n      \"SATISFY\",\n      \"SAVE\",\n      \"SAY\",\n      \"SCALE\",\n      \"SCENE\",\n      \"SCHEME\",\n      \"SCHOOL\",\n      \"SCIENCE\",\n      \"SCIENTIFIC\",\n      \"SCIENTIST\",\n      \"SCORE\",\n      \"SCREEN\",\n      \"SEA\",\n      \"SEARCH\",\n      \"SEASON\",\n      \"SEAT\",\n      \"SECOND\",\n      \"SECONDARY\",\n      \"SECRETARY\",\n      \"SECTION\",\n      \"SECTOR\",\n      \"SECURE\",\n      \"SECURITY\",\n      \"SEE\",\n      \"SEEK\",\n      \"SEEM\",\n      \"SELECT\",\n      \"SELECTION\",\n      \"SELL\",\n      \"SEND\",\n      \"SENIOR\",\n      \"SENSE\",\n      \"SENTENCE\",\n      \"SEPARATE\",\n      \"SEQUENCE\",\n      \"SERIES\",\n      \"SERIOUS\",\n      \"SERIOUSLY\",\n      \"SERVANT\",\n      \"SERVE\",\n      \"SERVICE\",\n      \"SESSION\",\n      \"SET\",\n      \"SETTLE\",\n      \"SETTLEMENT\",\n      \"SEVERAL\",\n      \"SEVERE\",\n      \"SEX\",\n      \"SEXUAL\",\n      \"SHAKE\",\n      \"SHALL\",\n      \"SHAPE\",\n      \"SHARE\",\n      \"SHE\",\n      \"SHEET\",\n      \"SHIP\",\n      \"SHOE\",\n      \"SHOOT\",\n      \"SHOP\",\n      \"SHORT\",\n      \"SHOT\",\n      \"SHOULD\",\n      \"SHOULDER\",\n      \"SHOUT\",\n      \"SHOW\",\n      \"SHUT\",\n      \"SIDE\",\n      \"SIGHT\",\n      \"SIGN\",\n      \"SIGNAL\",\n      \"SIGNIFICANCE\",\n      \"SIGNIFICANT\",\n      \"SILENCE\",\n      \"SIMILAR\",\n      \"SIMPLE\",\n      \"SIMPLY\",\n      \"SINCE\",\n      \"SING\",\n      \"SINGLE\",\n      \"SIR\",\n      \"SISTER\",\n      \"SIT\",\n      \"SITE\",\n      \"SITUATION\",\n      \"SIZE\",\n      \"SKILL\",\n      \"SKIN\",\n      \"SKY\",\n      \"SLEEP\",\n      \"SLIGHTLY\",\n      \"SLIP\",\n      \"SLOW\",\n      \"SLOWLY\",\n      \"SMALL\",\n      \"SMILE\",\n      \"SO\",\n      \"SOCIAL\",\n      \"SOCIETY\",\n      \"SOFT\",\n      \"SOFTWARE\",\n      \"SOIL\",\n      \"SOLDIER\",\n      \"SOLICITOR\",\n      \"SOLUTION\",\n      \"SOME\",\n      \"SOMEBODY\",\n      \"SOMEONE\",\n      \"SOMETHING\",\n      \"SOMETIMES\",\n      \"SOMEWHAT\",\n      \"SOMEWHERE\",\n      \"SON\",\n      \"SONG\",\n      \"SOON\",\n      \"SORRY\",\n      \"SORT\",\n      \"SOUND\",\n      \"SOURCE\",\n      \"SOUTH\",\n      \"SOUTHERN\",\n      \"SPACE\",\n      \"SPEAK\",\n      \"SPEAKER\",\n      \"SPECIAL\",\n      \"SPECIES\",\n      \"SPECIFIC\",\n      \"SPEECH\",\n      \"SPEED\",\n      \"SPEND\",\n      \"SPIRIT\",\n      \"SPORT\",\n      \"SPOT\",\n      \"SPREAD\",\n      \"SPRING\",\n      \"STAFF\",\n      \"STAGE\",\n      \"STAND\",\n      \"STANDARD\",\n      \"STAR\",\n      \"START\",\n      \"STATE\",\n      \"STATEMENT\",\n      \"STATION\",\n      \"STATUS\",\n      \"STAY\",\n      \"STEAL\",\n      \"STEP\",\n      \"STICK\",\n      \"STILL\",\n      \"STOCK\",\n      \"STONE\",\n      \"STOP\",\n      \"STORE\",\n      \"STORY\",\n      \"STRAIGHT\",\n      \"STRANGE\",\n      \"STRATEGY\",\n      \"STREET\",\n      \"STRENGTH\",\n      \"STRIKE\",\n      \"STRONG\",\n      \"STRONGLY\",\n      \"STRUCTURE\",\n      \"STUDENT\",\n      \"STUDIO\",\n      \"STUDY\",\n      \"STUFF\",\n      \"STYLE\",\n      \"SUBJECT\",\n      \"SUBSTANTIAL\",\n      \"SUCCEED\",\n      \"SUCCESS\",\n      \"SUCCESSFUL\",\n      \"SUCH\",\n      \"SUDDENLY\",\n      \"SUFFER\",\n      \"SUFFICIENT\",\n      \"SUGGEST\",\n      \"SUGGESTION\",\n      \"SUITABLE\",\n      \"SUM\",\n      \"SUMMER\",\n      \"SUN\",\n      \"SUPPLY\",\n      \"SUPPORT\",\n      \"SUPPOSE\",\n      \"SURE\",\n      \"SURELY\",\n      \"SURFACE\",\n      \"SURPRISE\",\n      \"SURROUND\",\n      \"SURVEY\",\n      \"SURVIVE\",\n      \"SWITCH\",\n      \"SYSTEM\",\n      \"TABLE\",\n      \"TAKE\",\n      \"TALK\",\n      \"TALL\",\n      \"TAPE\",\n      \"TARGET\",\n      \"TASK\",\n      \"TAX\",\n      \"TEA\",\n      \"TEACH\",\n      \"TEACHER\",\n      \"TEACHING\",\n      \"TEAM\",\n      \"TEAR\",\n      \"TECHNICAL\",\n      \"TECHNIQUE\",\n      \"TECHNOLOGY\",\n      \"TELEPHONE\",\n      \"TELEVISION\",\n      \"TELL\",\n      \"TEMPERATURE\",\n      \"TEND\",\n      \"TERM\",\n      \"TERMS\",\n      \"TERRIBLE\",\n      \"TEST\",\n      \"TEXT\",\n      \"THAN\",\n      \"THANK\",\n      \"THANKS\",\n      \"THAT\",\n      \"THE\",\n      \"THEATRE\",\n      \"THEIR\",\n      \"THEM\",\n      \"THEME\",\n      \"THEMSELVES\",\n      \"THEN\",\n      \"THEORY\",\n      \"THERE\",\n      \"THEREFORE\",\n      \"THESE\",\n      \"THEY\",\n      \"THIN\",\n      \"THING\",\n      \"THINK\",\n      \"THIS\",\n      \"THOSE\",\n      \"THOUGH\",\n      \"THOUGHT\",\n      \"THREAT\",\n      \"THREATEN\",\n      \"THROUGH\",\n      \"THROUGHOUT\",\n      \"THROW\",\n      \"THUS\",\n      \"TICKET\",\n      \"TIME\",\n      \"TINY\",\n      \"TITLE\",\n      \"TO\",\n      \"TODAY\",\n      \"TOGETHER\",\n      \"TOMORROW\",\n      \"TONE\",\n      \"TONIGHT\",\n      \"TOO\",\n      \"TOOL\",\n      \"TOOTH\",\n      \"TOP\",\n      \"TOTAL\",\n      \"TOTALLY\",\n      \"TOUCH\",\n      \"TOUR\",\n      \"TOWARDS\",\n      \"TOWN\",\n      \"TRACK\",\n      \"TRADE\",\n      \"TRADITION\",\n      \"TRADITIONAL\",\n      \"TRAFFIC\",\n      \"TRAIN\",\n      \"TRAINING\",\n      \"TRANSFER\",\n      \"TRANSPORT\",\n      \"TRAVEL\",\n      \"TREAT\",\n      \"TREATMENT\",\n      \"TREATY\",\n      \"TREE\",\n      \"TREND\",\n      \"TRIAL\",\n      \"TRIP\",\n      \"TROOP\",\n      \"TROUBLE\",\n      \"TRUE\",\n      \"TRUST\",\n      \"TRUTH\",\n      \"TRY\",\n      \"TURN\",\n      \"TWICE\",\n      \"TYPE\",\n      \"TYPICAL\",\n      \"UNABLE\",\n      \"UNDER\",\n      \"UNDERSTAND\",\n      \"UNDERSTANDING\",\n      \"UNDERTAKE\",\n      \"UNEMPLOYMENT\",\n      \"UNFORTUNATELY\",\n      \"UNION\",\n      \"UNIT\",\n      \"UNITED\",\n      \"UNIVERSITY\",\n      \"UNLESS\",\n      \"UNLIKELY\",\n      \"UNTIL\",\n      \"UP\",\n      \"UPON\",\n      \"UPPER\",\n      \"URBAN\",\n      \"US\",\n      \"USE\",\n      \"USED\",\n      \"USEFUL\",\n      \"USER\",\n      \"USUAL\",\n      \"USUALLY\",\n      \"VALUE\",\n      \"VARIATION\",\n      \"VARIETY\",\n      \"VARIOUS\",\n      \"VARY\",\n      \"VAST\",\n      \"VEHICLE\",\n      \"VERSION\",\n      \"VERY\",\n      \"VIA\",\n      \"VICTIM\",\n      \"VICTORY\",\n      \"VIDEO\",\n      \"VIEW\",\n      \"VILLAGE\",\n      \"VIOLENCE\",\n      \"VISION\",\n      \"VISIT\",\n      \"VISITOR\",\n      \"VITAL\",\n      \"VOICE\",\n      \"VOLUME\",\n      \"VOTE\",\n      \"WAGE\",\n      \"WAIT\",\n      \"WALK\",\n      \"WALL\",\n      \"WANT\",\n      \"WAR\",\n      \"WARM\",\n      \"WARN\",\n      \"WASH\",\n      \"WATCH\",\n      \"WATER\",\n      \"WAVE\",\n      \"WAY\",\n      \"WE\",\n      \"WEAK\",\n      \"WEAPON\",\n      \"WEAR\",\n      \"WEATHER\",\n      \"WEEK\",\n      \"WEEKEND\",\n      \"WEIGHT\",\n      \"WELCOME\",\n      \"WELFARE\",\n      \"WELL\",\n      \"WEST\",\n      \"WESTERN\",\n      \"WHAT\",\n      \"WHATEVER\",\n      \"WHEN\",\n      \"WHERE\",\n      \"WHEREAS\",\n      \"WHETHER\",\n      \"WHICH\",\n      \"WHILE\",\n      \"WHILST\",\n      \"WHITE\",\n      \"WHO\",\n      \"WHOLE\",\n      \"WHOM\",\n      \"WHOSE\",\n      \"WHY\",\n      \"WIDE\",\n      \"WIDELY\",\n      \"WIFE\",\n      \"WILD\",\n      \"WILL\",\n      \"WIN\",\n      \"WIND\",\n      \"WINDOW\",\n      \"WINE\",\n      \"WING\",\n      \"WINNER\",\n      \"WINTER\",\n      \"WISH\",\n      \"WITH\",\n      \"WITHDRAW\",\n      \"WITHIN\",\n      \"WITHOUT\",\n      \"WOMAN\",\n      \"WONDER\",\n      \"WONDERFUL\",\n      \"WOOD\",\n      \"WORD\",\n      \"WORK\",\n      \"WORKER\",\n      \"WORKING\",\n      \"WORKS\",\n      \"WORLD\",\n      \"WORRY\",\n      \"WORTH\",\n      \"WOULD\",\n      \"WRITE\",\n      \"WRITER\",\n      \"WRITING\",\n      \"WRONG\",\n      \"YARD\",\n      \"YEAH\",\n      \"YEAR\",\n      \"YES\",\n      \"YESTERDAY\",\n      \"YET\",\n      \"YOU\",\n      \"YOUNG\",\n      \"YOUR\",\n      \"YOURSELF\",\n      \"YOUTH\"\n    };\n    long startTime = System.nanoTime();\n    int triangleCounter = 0;\n    for (int i = 0; i < stringArray.length; i++) {\n      if (isTriangle(getWordValue(stringArray[i]))) {\n        triangleCounter++;\n      }\n    }\n\n    System.out.println(\"Answer: \" + triangleCounter);\n\n    long endTime = System.nanoTime();\n    System.out.printf(\"Total Time: %.6f seconds\\n\", ((endTime - startTime) / 1000000000.0));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9240, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 64, "focalAPIEnd": 81, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [673], "useEnd": [690], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/achudars/Project-Euler/tree/master/PE033/src/PE033.java", "rawCode": "  public static void main(String[] args) {\n    long startTime = System.nanoTime();\n    double product = 1;\n\n    for (double n = 1; n < 9; n++) {\n      for (double m = 1; m < 10; m++) {\n        for (double k = 1; k < 10; k++) {\n          if (n / m == ((n * 10 + k) / (k * 10 + m)) && ((n * 10 + k) != (k * 10 + m))) {\n            // list all four non-tivial fractions\n            System.out.println((n * 10 + k) + \"/\" + (k * 10 + m));\n            product *= (n / m);\n          }\n        }\n      }\n    }\n    System.out.println(\n        \"Product (and answer): \"\n            + product\n            + \" which is 1/100, where the denominator is the answer.\");\n\n    long endTime = System.nanoTime();\n    System.out.printf(\"Total Time: %.6f seconds\\n\", ((endTime - startTime) / 1000000000.0));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9241, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 561, "focalAPIEnd": 578, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["substitute(Document,String,)", "assertEquals(String,,*)"], "useStart": [584, 817], "useEnd": [629, 955], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crh/escidoc-core-1.4/tree/master/integration-tests/src/test/java/de/escidoc/core/test/cmm/contentmodel/ContentModelCreateIT.java", "rawCode": "  /**\n   * Test if md-record-name of resource-definitions of ContentModel is handled well.\n   *\n   * <p>See issue INFR-1122\n   *\n   * @throws Exception If anything fails.\n   */\n  public void testCmMetadataRecordName() throws Exception {\n\n    String xPath =\n        \"/content-model/resource-definitions/resource-definition[@name='trans']/md-record-name\";\n    Document contentModel =\n        EscidocAbstractTest.getTemplateAsDocument(\n            TEMPLATE_CONTENT_MODEL_PATH + \"/rest\", \"content-model-all-for-create.xml\");\n\n    String mdRecordName = \"blafasel\" + System.nanoTime();\n    substitute(contentModel, xPath, mdRecordName);\n\n    String contentModelXml = toString(contentModel, false);\n    String createdXML = create(contentModelXml);\n\n    Document cmCreated = EscidocAbstractTest.getDocument(createdXML);\n\n    assertEquals(\n        \"Wrong md-record-name\",\n        mdRecordName,\n        selectSingleNode(cmCreated, xPath + \"/text()\").getNodeValue());\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9242, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 429, "focalAPIEnd": 446, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(File,)"], "useStart": [402], "useEnd": [447], "hasFinally": 1, "cleanUpCall": ["deleteDirectory(File)"], "finallyExpressionStart": 1950, "finallyExpressionEnd": 1958, "finallyBlockStart": 1950, "finallyBlockEnd": 2061, "cleanUpCallStart": [2017], "cleanUpCallEnd": [2052], "url": "https://github.com/gerritjvv/SimpleSQL/tree/master/aggregator/src/main/java/org/simplesql/hbase/HBaseTableEngine.java", "rawCode": "  @Override\n  public void select(SQLCompiler compiler, SELECT select, final SELECT_OUTPUT output) {\n    // create an\n\n    final TableDef table = repo.getTable(select.getTable());\n    if (table == null) throw new RuntimeException(\"No table found for \" + select.getTable());\n\n    // do select data here\n    final SQLExecutor exec = compiler.compile(table, select);\n\n    try {\n      final File storeDir = new File(workingDir, \"_\" + System.nanoTime());\n\n      final KratiAggregateStore store =\n          new KratiAggregateStore(\n              conf,\n              storeDir,\n              createSCHEMA(table),\n              exec.getTransforms().toArray(new TransformFunction[0]));\n\n      final HTableInterface htable = pool.getTable(Bytes.toBytes(table.getName()));\n\n      final int limit = (select.getLimit() < 0) ? Integer.MAX_VALUE : select.getLimit();\n\n      // create start key and end key writers.\n      final Scan scan = new Scan();\n      scan.setMaxVersions(1);\n\n      // set only the families required in the query\n      addFamilies(scan, exec.getColumnsUsed(), table);\n\n      // set start and stop keys\n\n      final int keyLen = columnKeyWidth(table);\n      final byte[] startKey = new byte[keyLen];\n      final byte[] endKey = new byte[keyLen];\n\n      // setup start stop ranges for keys\n      fillStartEndKeys(table, exec, startKey, endKey);\n\n      scan.setStartRow(startKey);\n      scan.setStopRow(endKey);\n\n      ResultScanner scanner = htable.getScanner(scan);\n      try {\n        HBaseDataSource dataSource = new HBaseDataSource(scanner, table, select, exec);\n        exec.pump(dataSource, store, null);\n\n        final AtomicInteger count = new AtomicInteger(0);\n\n        store.write(\n            new DefaultDataSink() {\n\n              @Override\n              public boolean fill(Key key, Cell<?>[] data) {\n                output.write(data);\n                return count.getAndIncrement() < limit;\n              }\n            });\n\n      } finally {\n        scanner.close();\n        htable.close();\n        FileUtils.deleteDirectory(storeDir);\n      }\n\n    } catch (Throwable t) {\n      RuntimeException rte = new RuntimeException(t.toString(), t);\n      rte.setStackTrace(t.getStackTrace());\n      throw rte;\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9243, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 3980, "focalAPIEnd": 3997, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/360/360-Engine-for-Android/tree/master/src/com/vodafone360/people/engine/contactsync/UploadServerContacts.java", "rawCode": "  /**\n   * Called when a server response is received during a new contact sync. The server ID, user ID and\n   * contact detail unique IDs are extracted from the response and the NowPlus database updated.\n   * Possibly server errors are also handled.\n   *\n   * @param resp Response from server.\n   */\n  private void processNewContactsResp(final DecodedResponse resp) {\n\n    ServiceStatus status =\n        BaseEngine.getResponseStatus(BaseDataType.CONTACT_CHANGES_DATA_TYPE, resp.mDataTypes);\n    if (status == ServiceStatus.SUCCESS) {\n      ContactChanges contactChanges = (ContactChanges) resp.mDataTypes.get(0);\n      ListIterator<Contact> itContactSrc = contactChanges.mContacts.listIterator();\n      ListIterator<Contact> itContactDest = mContactChangeList.listIterator();\n      List<ServerIdInfo> contactServerIdList = new ArrayList<ServerIdInfo>();\n      List<ServerIdInfo> detailServerIdList = new ArrayList<ServerIdInfo>();\n\n      while (itContactSrc.hasNext()) {\n        if (!itContactDest.hasNext()) {\n          /**\n           * The response should contain the same number of contacts as was supplied but must handle\n           * the error.\n           */\n          status = ServiceStatus.ERROR_COMMS_BAD_RESPONSE;\n          break;\n        }\n        Contact contactSrc = itContactSrc.next();\n        Contact contactDest = itContactDest.next();\n        if (Settings.ENABLED_CONTACTS_SYNC_TRACE) {\n          String name = null;\n          String sns = null;\n          for (ContactDetail detail : contactDest.details) {\n            if (detail.key == ContactDetail.DetailKeys.VCARD_NAME) {\n              if (detail.value != null) {\n                VCardHelper.Name nameObj = detail.getName();\n                if (nameObj != null) {\n                  name = nameObj.toString();\n                }\n              }\n            }\n            if (detail.key == ContactDetail.DetailKeys.VCARD_INTERNET_ADDRESS) {\n              sns = detail.alt;\n            }\n          }\n          LogUtils.logV(\n              \"UploadServerContacts.\"\n                  + \"processNewContactsResp() Contact uploaded: SID\"\n                  + \" = \"\n                  + contactSrc.contactID\n                  + \", name = \"\n                  + name\n                  + \", sns = \"\n                  + sns\n                  + \", no of details = \"\n                  + contactDest.details.size()\n                  + \", deleted=\"\n                  + contactSrc.deleted);\n        }\n        if (contactSrc.contactID != null && contactSrc.contactID.longValue() != -1L) {\n          if (contactDest.contactID == null\n              || !contactDest.contactID.equals(contactSrc.contactID)) {\n            ServerIdInfo info = new ServerIdInfo();\n            info.localId = contactDest.localContactID;\n            info.serverId = contactSrc.contactID;\n            info.userId = contactSrc.userID;\n            contactServerIdList.add(info);\n          }\n        } else {\n          LogUtils.logE(\n              \"UploadServerContacts.\"\n                  + \"processNewContactsResp() The server failed to \"\n                  + \"add the following contact: \"\n                  + contactDest.localContactID\n                  + \", server ID = \"\n                  + contactDest.contactID);\n          mFailureList += \"Failed to add contact: \" + contactDest.localContactID + \"\\n\";\n          for (ContactDetail d : contactDest.details) {\n            LogUtils.logV(\n                \"Failed Contact Info: \"\n                    + contactDest.localContactID\n                    + \", Detail: \"\n                    + d.key\n                    + \", \"\n                    + d.keyType\n                    + \" = \"\n                    + d.value);\n          }\n        }\n        status = handleUploadDetailChanges(contactSrc, contactDest, detailServerIdList);\n      }\n      if (status != ServiceStatus.SUCCESS) {\n        /** Something is going wrong - cancel the update * */\n        complete(status);\n        return;\n      }\n\n      long startTime = System.nanoTime();\n      List<ContactIdInfo> dupList = new ArrayList<ContactIdInfo>();\n      status =\n          ContactsTable.syncSetServerIds(contactServerIdList, dupList, mDb.getWritableDatabase());\n      if (status != ServiceStatus.SUCCESS) {\n        complete(status);\n        return;\n      }\n      status = ContactDetailsTable.syncSetServerIds(detailServerIdList, mDb.getWritableDatabase());\n      if (status != ServiceStatus.SUCCESS) {\n        complete(status);\n        return;\n      }\n      if (dupList.size() > 0) {\n        LogUtils.logV(\n            \"UploadServerContacts.processNewContactsResp() Found \"\n                + dupList.size()\n                + \" duplicate contacts. Trying to remove them...\");\n\n        if (VersionUtils.is2XPlatform()) {\n          // This is a very important distinction for 2.X devices!\n          // the NAB IDs from the contacts we first import are stripped away\n          // So we won't have the correct ID if syncMergeContactList() is executed\n          // This is critical because a chain reaction will cause a Contact Delete in the end\n          // Instead we can syncDeleteContactList() which should be safe on 2.X!\n          status = mDb.syncDeleteContactList(dupList, false, true);\n        } else {\n          status = mDb.syncMergeContactList(dupList);\n        }\n\n        if (status != ServiceStatus.SUCCESS) {\n          complete(status);\n          return;\n        }\n        markDbChanged();\n      }\n      mDbSyncTime += (System.nanoTime() - startTime);\n\n      while (itContactDest.hasNext()) {\n        Contact contactDest = itContactDest.next();\n        LogUtils.logE(\n            \"UploadServerContacts.processNewContactsResp() \"\n                + \"The server failed to add the following contact (not \"\n                + \"included in returned list): \"\n                + contactDest.localContactID);\n        mFailureList +=\n            \"Failed to add contact (missing from return \"\n                + \"list): \"\n                + contactDest.localContactID\n                + \"\\n\";\n      }\n      updateProgress();\n      sendNextContactAdditionsPage();\n      return;\n    }\n    complete(status);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9244, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 520, "focalAPIEnd": 537, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cogroo/cogroo4/tree/master/cogroo-gc/src/main/java/org/cogroo/gc/cmdline/grammarchecker/GrammarCheckerTool.java", "rawCode": "  public void run(String[] args) {\n    Params params = validateAndParseParams(args, Params.class);\n\n    String lang = params.getLang();\n    CmdLineUtil.checkLanguageCode(lang);\n\n    String country = params.getCountry();\n    if (StringsUtil.isNullOrEmpty(country)) {\n      throw new TerminateToolException(1, \"Country cannot be empty. Example country: BR\");\n    }\n\n    File rulesFile = params.getRulesFile();\n    if (rulesFile != null) {\n      CmdLineUtil.checkInputFile(\"Rules file\", rulesFile);\n    }\n\n    long start = System.nanoTime();\n\n    ComponentFactory factory;\n    try {\n      factory = ComponentFactory.create(new Locale(lang, country));\n    } catch (InitializationException e) {\n      e.printStackTrace();\n      throw new TerminateToolException(\n          1,\n          \"Could not find configuration for \"\n              + lang\n              + \". Only \"\n              + new Locale(\"pt\", \"BR\")\n              + \" might be supported for now.\");\n    }\n    GrammarChecker cogroo;\n    try {\n      if (rulesFile == null) {\n        cogroo = new GrammarChecker(factory.createPipe());\n      } else {\n        String serializedRules = FileUtils.readFile(rulesFile, StandardCharsets.UTF_8);\n        cogroo = new GrammarChecker(factory.createPipe(), serializedRules);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new TerminateToolException(1, \"Could not create pipeline!\");\n    }\n\n    System.out.println(\"Loading time [\" + ((System.nanoTime() - start) / 1000000) + \"ms]\");\n\n    Scanner kb = new Scanner(System.in);\n    System.out.print(\"Enter the sentence or 'q' to quit: \");\n    String input = kb.nextLine();\n\n    while (!input.equals(\"q\")) {\n\n      CheckDocument document = new CheckDocument();\n      document.setText(input);\n      cogroo.analyze(document);\n\n      if (params.getShowAnalysis()) {\n        System.out.println(TextUtils.nicePrint(document));\n      }\n\n      System.out.println(document.getMistakesAsString());\n\n      System.out.print(\"Enter the sentence or 'q' to quit: \");\n      input = kb.nextLine();\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9245, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 114, "focalAPIEnd": 131, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apavlo/h-store/tree/master/src/frontend/org/voltdb/ProcedureProfiler.java", "rawCode": "  final void stopCounter() {\n    if (currentTimingInfo == null) return;\n\n    allCallCount++;\n    profileEndTime = System.nanoTime();\n    long time = profileEndTime - startTime;\n    currentTimingInfo.callCount++;\n    currentTimingInfo.totalTime += time;\n    currentTimingInfo.sumOfSquares += time * time / 1000000;\n    currentTimingInfo.averageTime = currentTimingInfo.totalTime / currentTimingInfo.callCount;\n    totalTime += time;\n    if (time > currentTimingInfo.max) currentTimingInfo.max = time;\n    if (time < currentTimingInfo.min) currentTimingInfo.min = time;\n\n    if (allCallCount == profileOutputNext) {\n      flushProfile();\n      profileOutputNext *= 2;\n    }\n    currentTimingInfo = null;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9246, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 127, "focalAPIEnd": 144, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [501], "useEnd": [518], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AEminium/AEminiumProject/tree/master/AeminiumRuntime/src/aeminium/runtime/tools/benchmark/LinearTaskGraph.java", "rawCode": "  private void runTest(Reporter reporter, int count) {\n    Runtime rt = Factory.getRuntime();\n    rt.init();\n\n    long start = System.nanoTime();\n    Task previousTask = createTask(rt, \"Task-0\");\n    rt.schedule(previousTask, Runtime.NO_PARENT, Runtime.NO_DEPS);\n\n    for (int i = 1; i < count; i++) {\n      Task nextTask = createTask(rt, \"Task-\" + i);\n      rt.schedule(nextTask, Runtime.NO_PARENT, Arrays.asList(previousTask));\n      previousTask = nextTask;\n    }\n    rt.shutdown();\n    long end = System.nanoTime();\n\n    String result =\n        String.format(\n            \"Run %10d tasks in %12d ns ==> %10d ns per task | %6d tasks/second.\",\n            count, (end - start), ((end - start) / count), (1000000000 / ((end - start) / count)));\n    reporter.reportLn(result);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9247, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 88, "focalAPIEnd": 105, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/antigremlin/caliper-fork/tree/master/src/tutorial/Tutorial.java", "rawCode": "    public void timeNanoTime(int reps) {\n      for (int i = 0; i < reps; i++) {\n        System.nanoTime();\n      }\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9248, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": -1726, "focalAPIEnd": -1709, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/abeifuss/simgui/tree/master/src/evaluation/loadGenerator/scheduler/YieldWaitScheduler.java", "rawCode": "  @Override\n  public long now() {\n    return System.nanoTime() - INIT_TIME;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9249, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 166, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [941], "useEnd": [958], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JohnDickerson/KidneyExchange/tree/master/src/edu/cmu/cs/dickerson/kpd/solver/approx/CycleShufflePacker.java", "rawCode": "  @Override\n  public Solution pack(double upperBound) {\n    Set<Cycle> matching = new HashSet<Cycle>();\n    double objVal = 0.0;\n\n    // Pack cycles\n    long start = System.nanoTime();\n\n    // Keep track of which vertices are in the matching so far\n    Set<Vertex> matchedVerts = new HashSet<Vertex>();\n\n    // \"Sample\" randomly from the set of all cycles until either we run out of\n    // cycles, or we hit the parameter upperBound\n    Collections.shuffle(cycles);\n    for (Cycle cycle : cycles) {\n\n      Set<Vertex> cVerts = Cycle.getConstituentVertices(cycle, pool);\n\n      // If no vertices in this cycle are matched, it's legal to add; add it\n      if (Collections.disjoint(cVerts, matchedVerts)) {\n        matchedVerts.addAll(cVerts);\n        objVal += cycle.getWeight();\n        matching.add(cycle);\n      }\n\n      // If we hit the upper bound, break out\n      if (objVal >= upperBound) {\n        break;\n      }\n    }\n\n    long end = System.nanoTime();\n    long totalTime = end - start;\n\n    // Construct formal matching, return\n    Solution sol = new Solution();\n    sol.setMatching(matching);\n    sol.setObjectiveValue(objVal);\n    sol.setSolveTime(totalTime);\n    return sol;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9250, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 75, "focalAPIEnd": 92, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Praqma/praqmajutils/tree/master/src/main/java/net/praqma/util/StopWatch.java", "rawCode": "  public void stop() {\n    if (currentTask != null) {\n      this.endTime = System.nanoTime();\n\n      currentTask.nano = this.endTime - this.startTime;\n\n      this.totalTime += currentTask.nano;\n\n      tasks.add(currentTask);\n      currentTask = null;\n    } else {\n      throw new IllegalStateException(\n          \"No current tasks. Stop watch could have been stopped twice?\");\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9251, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 732, "focalAPIEnd": 749, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [817], "useEnd": [834], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/amal029/jop/tree/master/java/tools/src/com/jopdesign/wcet/analysis/UppaalAnalysis.java", "rawCode": "  public WcetCost calculateWCET(MethodInfo m, long ub)\n      throws IOException, DuplicateKeyException, XmlSerializationException {\n    Long upperBound = null;\n    if (ub > 0) upperBound = ub + 20;\n    logger.info(\"Starting UppAal translation of \" + m.getFQMethodName());\n    Translator translator = new Translator(uppaalConfig, project);\n    translator.translateProgram(m);\n    translator.writeOutput();\n    logger.info(\"model and query can be found in \" + uppaalConfig.outDir);\n    logger.info(\"model file: \" + translator.getModelFile());\n    if (uppaalConfig.hasVerifier()) {\n      logger.info(\"Starting verification\");\n      WcetSearch search = new WcetSearch(project.getConfig(), translator.getModelFile());\n      long start = System.nanoTime();\n      long wcet = search.searchWCET(upperBound);\n      long end = System.nanoTime();\n      searchtime += ((double) (end - start)) / 1E9;\n      solvertimemax = Math.max(solvertimemax, search.getMaxSolverTime());\n      return WcetCost.totalCost(wcet);\n    } else {\n      throw new IOException(\"No verifier binary available. Skipping search\");\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9252, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 38, "focalAPIEnd": 55, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/quchunguang/test/tree/master/testjava/TIJ4-code/innerclasses/controller/Event.java", "rawCode": "  public boolean ready() {\n    return System.nanoTime() >= eventTime;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9253, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 590, "focalAPIEnd": 607, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Random()", "new Random()"], "useStart": [638, 686], "useEnd": [654, 702], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jacketattack/MULE/tree/master/src/main/java/core/IdGenerator.java", "rawCode": "  /** Lazy loads 100 ids so that they can be accessed later */\n  private static void loadIds() {\n    ArrayList<String> adjectives = getText(\"/assets/adjectives.txt\");\n    ArrayList<String> nouns = getText(\"/assets/nouns.txt\");\n\n    // combine 100 random adjectives and nouns\n    for (int a = 0; a < 100 && a < nouns.size() && a < adjectives.size(); a++) {\n      String noun = nouns.get((int) (Math.random() * nouns.size()));\n      String adjective = adjectives.get((int) (Math.random() * adjectives.size()));\n      ids.add(adjective + \"-\" + noun);\n    }\n\n    // random sort\n    long seed = System.nanoTime();\n    Collections.shuffle(ids, new Random(seed));\n    Collections.shuffle(ids, new Random(seed));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9254, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 75, "focalAPIEnd": 92, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Hexcore/HxCAS/tree/master/src/com/hexcore/cas/ui/toolkit/Window.java", "rawCode": "  @Override\n  public void mouseDragged(MouseEvent e) {\n    lastMouseMove = System.nanoTime();\n    mousePos = new Vector2i(e.getX(), e.getY());\n\n    Event event = new Event(Event.Type.MOUSE_MOTION);\n    event.position = new Vector2i(e.getX(), e.getY());\n    event.setModifiers(e);\n    sendEvent(event);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9255, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 2515, "focalAPIEnd": 2532, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [2681], "useEnd": [2698], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ybonnel/ybo-tv-android/tree/master/src/main/java/fr/ybo/ybotv/android/modele/ChannelWithProgramme.java", "rawCode": "  public static List<ChannelWithProgramme> getProgrammesForDate(\n      YboTvApplication application, String date) {\n    YboTvDatabase database = application.getDatabase();\n\n    StringBuilder sqlQuery = new StringBuilder();\n\n    sqlQuery.append(\"SELECT Channel.id as channelId, \");\n    sqlQuery.append(\"Channel.displayName as channelDisplayName, \");\n    sqlQuery.append(\"Channel.icon as channelIcon, \");\n    sqlQuery.append(\"Channel.numero as channelNumero, \");\n    sqlQuery.append(\"Programme.id as programmeId, \");\n    sqlQuery.append(\"Programme.start as programmeStart, \");\n    sqlQuery.append(\"Programme.stop as programmeStop, \");\n    sqlQuery.append(\"Programme.icon as programmeIcon, \");\n    sqlQuery.append(\"Programme.title as programmeTitle, \");\n    sqlQuery.append(\"Programme.desc as programmeDesc, \");\n    sqlQuery.append(\"Programme.starRating as programmeStarRating, \");\n    sqlQuery.append(\"Programme.csaRating as programmeCsaRating, \");\n    sqlQuery.append(\"Programme.directors as programmeDirectors, \");\n    sqlQuery.append(\"Programme.actors as programmeActors, \");\n    sqlQuery.append(\"Programme.writers as programmeWriters, \");\n    sqlQuery.append(\"Programme.presenters as programmePresenters, \");\n    sqlQuery.append(\"Programme.date as programmeDate, \");\n    sqlQuery.append(\"Programme.categories as programmeCategories, \");\n    sqlQuery.append(\"Programme.critique as programmeCritique \");\n\n    sqlQuery.append(\"FROM Channel, Programme, FavoriteChannel \");\n    sqlQuery.append(\"WHERE \");\n    sqlQuery.append(\"Channel.id = Programme.channel \");\n    sqlQuery.append(\"AND Channel.id = FavoriteChannel.channel \");\n    sqlQuery.append(\"AND Programme.start <= :currentDate \");\n    sqlQuery.append(\"AND Programme.stop >= :currentDate \");\n\n    TimeZone currentTimeZone = TimeZone.getDefault();\n    TimeZone frenchTimeZone = TimeZone.getTimeZone(\"Europe/Paris\");\n\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n    Date currentDate;\n    try {\n      currentDate = dateFormat.parse(date);\n    } catch (ParseException e) {\n      currentDate = new Date();\n    }\n\n    int diffToApplyBetweenTZ =\n        currentTimeZone.getOffset(currentDate.getTime())\n            - frenchTimeZone.getOffset(currentDate.getTime());\n    if (diffToApplyBetweenTZ != 0) {\n      currentDate.setTime(currentDate.getTime() + diffToApplyBetweenTZ);\n      date = dateFormat.format(currentDate);\n    }\n\n    List<String> selectionArgs = new ArrayList<String>(1);\n\n    selectionArgs.add(date);\n\n    long startTime = System.nanoTime();\n    Cursor cursor = database.executeSelectQuery(sqlQuery.toString(), selectionArgs);\n\n    int nbResult = cursor.getCount();\n    long elapsedTime = System.nanoTime() - startTime;\n    Log.d(\"YboTv\", \"Requete executee : \" + sqlQuery.toString());\n    Log.d(\"YboTv\", \"Nombre de resultas : \" + nbResult + \" en \" + (elapsedTime / 1000) + \"s\");\n\n    List<ChannelWithProgramme> channels = new ArrayList<ChannelWithProgramme>();\n\n    int channelIdCol = cursor.getColumnIndex(\"channelId\");\n    int channelDisplayNameCol = cursor.getColumnIndex(\"channelDisplayName\");\n    int channelIconCol = cursor.getColumnIndex(\"channelIcon\");\n    int channelNumeroCol = cursor.getColumnIndex(\"channelNumero\");\n    int programmeIdCol = cursor.getColumnIndex(\"programmeId\");\n    int programmeStartCol = cursor.getColumnIndex(\"programmeStart\");\n    int programmeStopCol = cursor.getColumnIndex(\"programmeStop\");\n    int programmeIconCol = cursor.getColumnIndex(\"programmeIcon\");\n    int programmeTitleCol = cursor.getColumnIndex(\"programmeTitle\");\n    int programmeDescCol = cursor.getColumnIndex(\"programmeDesc\");\n    int programmeStarRatingCol = cursor.getColumnIndex(\"programmeStarRating\");\n    int programmeCsaRatingCol = cursor.getColumnIndex(\"programmeCsaRating\");\n    int programmeDirectorsCol = cursor.getColumnIndex(\"programmeDirectors\");\n    int programmeActorsCol = cursor.getColumnIndex(\"programmeActors\");\n    int programmeWritersCol = cursor.getColumnIndex(\"programmeWriters\");\n    int programmePresentersCol = cursor.getColumnIndex(\"programmePresenters\");\n    int programmeDateCol = cursor.getColumnIndex(\"programmeDate\");\n    int programmeCategoriesCol = cursor.getColumnIndex(\"programmeCategories\");\n    int programmeCritiqueCol = cursor.getColumnIndex(\"programmeCritique\");\n\n    while (cursor.moveToNext()) {\n      ChannelWithProgramme oneChannelWithProgramme = new ChannelWithProgramme();\n\n      Channel oneChannel = new Channel();\n      oneChannel.setId(cursor.getString(channelIdCol));\n      oneChannel.setDisplayName(cursor.getString(channelDisplayNameCol));\n      oneChannel.setIcon(cursor.getString(channelIconCol));\n      oneChannel.setNumero(cursor.getInt(channelNumeroCol));\n      oneChannelWithProgramme.setChannel(oneChannel);\n\n      Programme oneProgramme = new Programme();\n      oneProgramme.setId(cursor.getString(programmeIdCol));\n      oneProgramme.setStart(cursor.getString(programmeStartCol));\n      oneProgramme.setStop(cursor.getString(programmeStopCol));\n      if (diffToApplyBetweenTZ != 0) {\n        try {\n          oneProgramme.setStart(\n              dateFormat.format(\n                  new Date(\n                      dateFormat.parse(oneProgramme.getStart()).getTime() - diffToApplyBetweenTZ)));\n          oneProgramme.setStop(\n              dateFormat.format(\n                  new Date(\n                      dateFormat.parse(oneProgramme.getStop()).getTime() - diffToApplyBetweenTZ)));\n        } catch (ParseException e) {\n          e.printStackTrace();\n        }\n      }\n      oneProgramme.setIcon(cursor.getString(programmeIconCol));\n      oneProgramme.setTitle(cursor.getString(programmeTitleCol));\n      oneProgramme.setDesc(cursor.getString(programmeDescCol));\n      oneProgramme.setCritique(cursor.getString(programmeCritiqueCol));\n      oneProgramme.setStarRating(cursor.getString(programmeStarRatingCol));\n      oneProgramme.setCsaRating(cursor.getString(programmeCsaRatingCol));\n      oneProgramme.setChannel(oneChannel.getId());\n      oneProgramme.fillDirectorsWithDb(cursor.getString(programmeDirectorsCol));\n      oneProgramme.fillActorsWithDb(cursor.getString(programmeActorsCol));\n      oneProgramme.fillWritersWithDb(cursor.getString(programmeWritersCol));\n      oneProgramme.fillPresentersWithDb(cursor.getString(programmePresentersCol));\n      oneProgramme.setDate(cursor.getString(programmeDateCol));\n      oneProgramme.fillCategoriesWithDb(cursor.getString(programmeCategoriesCol));\n\n      oneChannelWithProgramme.setProgramme(oneProgramme);\n\n      channels.add(oneChannelWithProgramme);\n    }\n\n    cursor.close();\n\n    Iterator<ChannelWithProgramme> iterator = channels.iterator();\n    Set<String> channelsAlreadyIn = new HashSet<String>();\n    while (iterator.hasNext()) {\n      ChannelWithProgramme currentChannel = iterator.next();\n      if (channelsAlreadyIn.contains(currentChannel.getChannel().getId())) {\n        iterator.remove();\n      } else {\n        channelsAlreadyIn.add(currentChannel.getChannel().getId());\n      }\n    }\n\n    return channels;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9256, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 265, "focalAPIEnd": 282, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tmobile/themes-platform-packages-apps-Email/tree/master/src/com/android/exchange/SyncManager.java", "rawCode": "    private void addAccountMailbox(long acctId) {\n      Account acct = Account.restoreAccountWithId(getContext(), acctId);\n      Mailbox main = new Mailbox();\n      main.mDisplayName = Eas.ACCOUNT_MAILBOX_PREFIX;\n      main.mServerId = Eas.ACCOUNT_MAILBOX_PREFIX + System.nanoTime();\n      main.mAccountKey = acct.mId;\n      main.mType = Mailbox.TYPE_EAS_ACCOUNT_MAILBOX;\n      main.mSyncInterval = Mailbox.CHECK_INTERVAL_PUSH;\n      main.mFlagVisible = false;\n      main.save(getContext());\n      log(\"Initializing account: \" + acct.mDisplayName);\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9257, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 994, "focalAPIEnd": 1011, "followUpCheck": "system.nanoTime() -  > MAX_PARSE_TIME", "checkType": "IF", "followUpCheckExpressionStart": 1418, "followUpCheckExpressionEnd": 1474, "followUpCheckBlockStart": 1418, "followUpCheckBlockEnd": 1534, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kkckkc/jsourcepad/tree/master/syntaxpane/src/main/java/kkckkc/syntaxpane/parse/Parser.java", "rawCode": "  public Pair<Interval, Interval> parse(int start, int end, ChangeEvent event) {\n    LineManager.Line line;\n    if (event == ChangeEvent.REMOVE) {\n      Pair<Line, Line> linePair = lineManager.intervalRemoved(new Interval(start, end));\n      line = linePair.getFirst();\n\n      foldManager.linesRemoved(linePair.getFirst(), linePair.getSecond());\n\n    } else if (event == ChangeEvent.ADD) {\n      Pair<Line, Line> linePair = lineManager.intervalAdded(new Interval(start, end));\n\n      if (linePair.getFirst() != linePair.getSecond()) {\n        foldManager.linesAdded(linePair.getFirst(), linePair.getSecond());\n      } else {\n        foldManager.linesUpdated(linePair.getFirst(), linePair.getSecond());\n      }\n\n      line = lineManager.getLineByPosition(start);\n    } else {\n      line = lineManager.getLineByPosition(start);\n      lineManager.intervalUpdated(new Interval(start, end));\n      foldManager.linesUpdated(line, lineManager.getLineByPosition(end));\n    }\n\n    long startTimestamp = System.nanoTime();\n\n    int i = 0;\n    boolean partialParse = false;\n    LineManager.Line previous = lineManager.getPrevious(line);\n    Scope scope = previous == null ? null : previous.getScope();\n    while (line != null) {\n      scope = parseLine(scope, line);\n\n      Scope origScope = line.getScope();\n      line.setScope(scope);\n\n      line = lineManager.getNext(line);\n\n      if ((++i % SAMPLE_INTERVAL) == 0) {\n        if (System.nanoTime() - startTimestamp > MAX_PARSE_TIME) {\n          partialParse = true;\n          break;\n        }\n      }\n\n      if (origScope == null) {\n        continue;\n      }\n\n      if (origScope.hasSameSignature(scope)) {\n        break;\n      }\n    }\n\n    return new Pair<Interval, Interval>(\n        new Interval(start, line == null ? Integer.MAX_VALUE : line.getStart()),\n        partialParse && line != null\n            ? new Interval(line.getStart(), end < line.getStart() ? line.getStart() + 1 : end)\n            : null);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9258, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 282, "focalAPIEnd": 299, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [823], "useEnd": [840], "hasFinally": 1, "cleanUpCall": ["cancelAcquire(Node)"], "finallyExpressionStart": 988, "finallyExpressionEnd": 996, "finallyBlockStart": 988, "finallyBlockEnd": 1042, "cleanUpCallStart": [1016], "cleanUpCallEnd": [1035], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java", "rawCode": "  /**\n   * Acquires in exclusive timed mode.\n   *\n   * @param arg the acquire argument\n   * @param nanosTimeout max wait time\n   * @return {@code true} if acquired\n   */\n  private boolean doAcquireNanos(long arg, long nanosTimeout) throws InterruptedException {\n    long lastTime = System.nanoTime();\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n      for (; ; ) {\n        final Node p = node.predecessor();\n        if (p == head && tryAcquire(arg)) {\n          setHead(node);\n          p.next = null; // help GC\n          failed = false;\n          return true;\n        }\n        if (nanosTimeout <= 0) return false;\n        if (shouldParkAfterFailedAcquire(p, node) && nanosTimeout > spinForTimeoutThreshold)\n          LockSupport.parkNanos(this, nanosTimeout);\n        long now = System.nanoTime();\n        nanosTimeout -= now - lastTime;\n        lastTime = now;\n        if (Thread.interrupted()) throw new InterruptedException();\n      }\n    } finally {\n      if (failed) cancelAcquire(node);\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9259, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 543, "focalAPIEnd": 560, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [628], "useEnd": [645], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lufenghuan/YCSB/tree/master/core/src/main/java/com/yahoo/ycsb/DBWrapper.java", "rawCode": "  /**\n   * Read a record from the database. Each field/value pair from the result will be stored in a\n   * HashMap.\n   *\n   * @param table The name of the table\n   * @param key The record key of the record to read.\n   * @param fields The list of fields to read, or null for all of them\n   * @param result A HashMap of field/value pairs for the result\n   * @return Zero on success, a non-zero error code on error\n   */\n  public int read(\n      String table, String key, Set<String> fields, HashMap<String, ByteIterator> result) {\n    long st = System.nanoTime();\n    int res = _db.read(table, key, fields, result);\n    long en = System.nanoTime();\n    _measurements.measure(\"READ\", (int) ((en - st) / 1000));\n    _measurements.reportReturnCode(\"READ\", res);\n    return res;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9260, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 168, "focalAPIEnd": 185, "followUpCheck": " > 5", "checkType": "IF", "followUpCheckExpressionStart": 205, "followUpCheckExpressionEnd": 218, "followUpCheckBlockStart": 205, "followUpCheckBlockEnd": 318, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/walware/statet/tree/master/de.walware.statet.r.ui/src/de/walware/statet/r/ui/dataeditor/RDataTableComposite.java", "rawCode": "  protected void updateSelection() {\n    final boolean checkLabel;\n    synchronized (this.selectionLock) {\n      final long diff = (this.selectionUpdateScheduleStamp - System.nanoTime()) / 1000000L;\n      if (diff > 5) {\n        this.display.timerExec((int) diff, this.selectionUpdateRunnable);\n        return;\n      }\n      checkLabel = this.selectionCheckLabel;\n      this.selectionCheckLabel = false;\n      this.selectionUpdateScheduled = false;\n    }\n    final RDataTableSelection selection;\n    if (this.tableLayers == null) {\n      selection = new RDataTableSelection(null, null, null, null);\n    } else {\n      final SelectionLayer selectionLayer = this.tableLayers.selectionLayer;\n      final PositionCoordinate anchor = selectionLayer.getSelectionAnchor();\n      PositionCoordinate lastSelected = selectionLayer.getLastSelectedCellPosition();\n      if (lastSelected.equals(anchor)) {\n        lastSelected = null;\n      }\n\n      final boolean anchorChanged;\n      if ((anchorChanged = !anchor.equals(this.currentAnchor))) {\n        this.currentAnchor = new PositionCoordinate(anchor);\n      }\n      final boolean lastSelectedChanged;\n      if ((lastSelectedChanged =\n          !((lastSelected != null)\n              ? lastSelected.equals(this.currentLastSelectedCell)\n              : null == this.currentLastSelectedCell))) {\n        this.currentLastSelectedCell =\n            (lastSelected != null) ? new PositionCoordinate(lastSelected) : null;\n      }\n\n      if (!checkLabel && !anchorChanged && !lastSelectedChanged) {\n        return;\n      }\n\n      String anchorRowLabel = null;\n      String anchorColumnLabel = null;\n      if (this.currentAnchor.columnPosition >= 0 && this.currentAnchor.rowPosition >= 0) {\n        if (anchorChanged || checkLabel) {\n          anchorRowLabel = getRowLabel(this.currentAnchor.rowPosition);\n          if (anchorRowLabel != null) {\n            anchorColumnLabel = getColumnLabel(this.currentAnchor.columnPosition);\n            if (anchorColumnLabel == null) {\n              anchorRowLabel = null;\n            }\n          }\n        } else if (this.selection != null) {\n          anchorRowLabel = this.selection.getAnchorRowLabel();\n          anchorColumnLabel = this.selection.getAnchorColumnLabel();\n        }\n      }\n\n      if (anchorRowLabel == null) {\n        return;\n      }\n\n      String lastSelectedRowLabel = null;\n      String lastSelectedColumnLabel = null;\n      if (this.currentLastSelectedCell != null\n          && this.currentLastSelectedCell.columnPosition >= 0\n          && this.currentLastSelectedCell.rowPosition >= 0) {\n        if (lastSelectedChanged || checkLabel) {\n          lastSelectedRowLabel = getRowLabel(this.currentLastSelectedCell.rowPosition);\n          if (lastSelectedRowLabel != null) {\n            lastSelectedColumnLabel = getColumnLabel(this.currentLastSelectedCell.columnPosition);\n            if (lastSelectedColumnLabel == null) {\n              lastSelectedRowLabel = null;\n            }\n          }\n        } else if (this.selection != null) {\n          lastSelectedRowLabel = this.selection.getLastSelectedCellRowLabel();\n          lastSelectedColumnLabel = this.selection.getLastSelectedCellColumnLabel();\n        }\n      }\n      selection =\n          new RDataTableSelection(\n              anchorRowLabel, anchorColumnLabel,\n              lastSelectedRowLabel, lastSelectedColumnLabel);\n    }\n\n    if (selection.equals(this.selection)) {\n      return;\n    }\n    this.selection = selection;\n    final SelectionChangedEvent event = new SelectionChangedEvent(this, this.selection);\n\n    for (final ISelectionChangedListener listener : this.selectionListeners.toArray()) {\n      listener.selectionChanged(event);\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9261, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 58, "focalAPIEnd": 75, "followUpCheck": "this.memwait + 30000000000L < ", "checkType": "IF", "followUpCheckExpressionStart": 3580, "followUpCheckExpressionEnd": 3639, "followUpCheckBlockStart": 3580, "followUpCheckBlockEnd": 4039, "use": ["system.nanoTime()", "printDebug()"], "useStart": [125, 9014], "useEnd": [142, 9034], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Nephyrin/WorldGenerationControl/tree/master/src/net/pointysoftware/worldgenerationcontrol/WorldGenerationControl.java", "rawCode": "    public boolean runStep(int queued) {\n      long now = System.nanoTime();\n      if (this.starttime == 0) this.starttime = System.nanoTime();\n\n      // Status message\n      String queuedtext = \"\";\n      if (queued > 0)\n        queuedtext =\n            ChatColor.DARK_GRAY\n                + \" {\"\n                + ChatColor.GRAY\n                + queued\n                + \" generations in queue\"\n                + ChatColor.DARK_GRAY\n                + \"}\";\n      if (queued == -1)\n        queuedtext =\n            ChatColor.DARK_GRAY\n                + \" {\"\n                + ChatColor.DARK_RED\n                + \"shutdown scheduled\"\n                + ChatColor.DARK_GRAY\n                + \"}\";\n\n      if (this.forcekeepup) {\n        if (this.iscraftbukkit) {\n          // See if this is CraftBukkit and we can fix the NextTickList leak\n          // otherwise it can mean lots of useless idle time while the server\n          // catches up slowly, see: https://github.com/Bukkit/CraftBukkit/pull/501\n          if (this.ticklist != null) {\n            try {\n              // Flush the list\n              // In CB1.1 processing will ramp up as the list grows to 5% of the list per tick\n              // but equilibrium isn't reached until the millions, so this is still of use for\n              // users with memory concerns.\n              // FIXME We shouldn't be linking directly against CraftWorld here\n              while (ticklist.size() > (this.speed == GenerationSpeed.ALLATONCE ? 0 : 200000))\n                ((CraftWorld) this.world).getHandle().a(true);\n            } catch (Exception e) {\n              // Probably CB version mismatch.\n              if (debug)\n                statusMsg(\n                    \"-- Warning: Failed to force server to keep up on ticklist processing. Probably unknown CraftBukkit version :(\");\n            }\n          }\n          // In 1.9+ the async chunk loader takes its sweet fuckin' time\n          try {\n            ((CraftWorld) this.world).getHandle().save(true, null);\n            ((CraftWorld) this.world).getHandle().saveLevel();\n          } catch (Exception e) {\n            statusMsg(\n                \"Warning: Unrecognized CraftBukkit build, cannot force saving. Async chunk loader will slow things down!\");\n            this.iscraftbukkit = false;\n          }\n        }\n        // With default java options, a moderately loaded server\n        // will simply not invoke the GC until it really needs\n        // to, meaning we can just sit above our memory limits\n        // forever if we don't force it\n        System.runFinalization();\n        System.gc();\n      }\n\n      // Check memory\n      String nag = null;\n      double pctusedmem =\n          ((double) (runtime.totalMemory() - runtime.freeMemory()) / runtime.maxMemory());\n      // max - total memory is how much memory is allowed to be used but not allocated,\n      // freeMemory is amount of allocated memory not in use. So not yet allocated + allocated but\n      // free == total free\n      long freemem = runtime.maxMemory() - runtime.totalMemory() + runtime.freeMemory();\n      // > 80% in use, or <200Megs free.\n      // Until we have better incremental generation, each step needs at least 200megs to not\n      // crash and burn.\n      if ((this.memwait > -1 && pctusedmem > 0.70D)\n          || pctusedmem > 0.80D\n          || freemem < (200 * 1024 * 1024)) {\n        nag =\n            \"Insufficient free memory (\"\n                + String.format(\"%.02f\", (double) freemem / (1024 * 1024))\n                + \"MiB)-- taking a break to let the server catch up\";\n        if (this.memwait > -1 && this.memwait + 30000000000L < now) {\n          this.memwait = now;\n          // It's fully possible for java, with default settings, to just sit at 85%\n          // memory without invoking GC. Even without /forceKeepUp, we should\n          // nudge the GC if its taking a while\n          if (debug) statusMsg(\"-- Been waiting on memory for a while, invoking a GC\");\n          System.runFinalization();\n          System.gc();\n        }\n        if (this.memwait == -1) this.memwait = now;\n      } else this.memwait = -1;\n\n      // Check for /onlyWhenEmpty\n      if (this.onlywhenempty && getServer().getOnlinePlayers().length > 0)\n        nag = \"Paused while players are present\";\n\n      // Status message\n      double pct = 1 - (double) queuedregions.size() / totalregions;\n      int region = totalregions - queuedregions.size() + 1;\n      String prefix =\n          ChatColor.DARK_GRAY\n              + \"[\"\n              + ChatColor.GOLD\n              + String.format(\"%.2f\", 100 * pct)\n              + \"%\"\n              + ChatColor.DARK_GRAY\n              + \"]\"\n              + ChatColor.GRAY\n              + \" \";\n\n      if (nag != null) {\n        // Should bail out\n        if (this.lastnag + 300000000000L < now) {\n          this.lastnag = now;\n          statusMsg(prefix + nag + queuedtext);\n        }\n        if (this.lastdebugnag + 3000000000L < now) {\n          if (debug) printDebug();\n          this.lastdebugnag = now;\n        }\n        return false;\n      } else this.lastnag = 0;\n\n      // Compute this before popping regions off stack\n      String statusmsg =\n          prefix\n              + ChatColor.GRAY\n              + \"Section \"\n              + ChatColor.WHITE\n              + region\n              + ChatColor.GRAY\n              + \"/\"\n              + ChatColor.WHITE\n              + totalregions\n              + queuedtext;\n\n      // Get next region\n      ArrayDeque<GenerationChunk> chunks = null;\n      while (queuedregions.size() > 0 && chunks == null)\n        chunks = queuedregions.pop().getChunks(this.world);\n\n      if (chunks == null) {\n        // Generation complete\n        long millis = (System.nanoTime() - this.starttime) / 1000000;\n        long seconds = millis / 1000;\n        long minutes = seconds / 60;\n        long hours = minutes / 60;\n        long days = hours / 24;\n        String took =\n            (days > 0 ? String.format(\"%d days, \", days) : \"\")\n                + (hours > 0 ? String.format(\"%d hours, \", hours % 24) : \"\")\n                + (minutes > 0 ? String.format(\"%d minutes, \", minutes % 60) : \"\")\n                + String.format(\"%d seconds\", seconds % 60);\n\n        statusMsg(\n            \"Generation complete in \"\n                + took\n                + \". \"\n                + (queued > 0 ? \"Loading next generation job\" : \"Have a nice day!\")\n                + queuedtext);\n        if (debug) printDebug();\n        return true;\n      } else statusMsg(statusmsg);\n\n      //\n      // Load Chunks\n      //\n      if (this.forceregeneration) {\n\n        // Force unload the area first, so all blocks only get populators\n        // run on them from their newly generated counterparts.\n        Iterator<GenerationChunk> i = chunks.iterator();\n        while (i.hasNext()) {\n          GenerationChunk gc = i.next();\n          gc.kickPlayers(\"The region you are in was regenerated. Please rejoin\");\n          gc.unload(true);\n        }\n      }\n      Iterator<GenerationChunk> iter = chunks.iterator();\n      ArrayDeque<GenerationChunk> rim = new ArrayDeque<GenerationChunk>();\n      while (iter.hasNext()) {\n        GenerationChunk c = iter.next();\n        // In force regeneration mode, we will load everything but the outer edge first, then load\n        // (not\n        // regenerate) that outer rim so populators trigger. Unless we're right at the edge of the\n        // requested\n        // generation area, those chunks will be non-edge-chunks in a QueuedRegion adjacent to this,\n        // due to\n        // overlap = 2\n        if (!this.forceregeneration || !c.isEdgeChunk()) {\n          c.load(this.forceregeneration);\n        } else {\n          rim.push(c);\n        }\n      }\n\n      // Now load rim if necessary\n      iter = rim.iterator();\n      while (iter.hasNext()) {\n        iter.next().load(false);\n      }\n\n      //\n      // Lighting\n      //\n      if (this.fixlighting != GenerationLighting.NONE) {\n        iter = chunks.iterator();\n        while (iter.hasNext()) {\n          GenerationChunk c = iter.next();\n          try {\n            c.fixLighting(fixlighting == GenerationLighting.EXTREME);\n          } catch (Exception e) {\n            // ClassCastException, MethodNotFound exception, or even an error inside craftbukkit.\n            // Either way, stop lighting for this generation.\n            if (e instanceof ClassCastException)\n              statusMsg(\n                  \"Error: WorldGenerationControl only supports lighting on CraftBukkit due to Bukkit API limitations. Disabling lighting for this generation.\");\n            else\n              statusMsg(\n                  \"Error: Error in CraftBukkit while generating lighting (probably an unsupported minecraft version). Disabling lighting for this generation.\");\n            this.fixlighting = GenerationLighting.NONE;\n          }\n        }\n      }\n\n      //\n      // Cleanup Chunks\n      //\n      while (chunks.size() > 0) {\n        chunks.pop().unload();\n      }\n\n      if (debug) this.printDebug(now);\n\n      return false;\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9262, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 79, "focalAPIEnd": 96, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonatas/mktc-platform/tree/master/source/core/src/test/java/org/marketcetera/metrics/ThreadedMetricTest.java", "rawCode": "  @Test\n  public void single() throws Exception {\n    final long currentTime = System.nanoTime();\n    String firstID = \"first\";\n    String secondID = \"second\";\n    String thirdID = \"third\";\n\n    // Run one iteration\n    oneIteration(TRUE, firstID, secondID, thirdID);\n\n    // Verify the summary\n    String[][][] sets = processCSV(summarize());\n    assertEquals(1, sets.length);\n    String[][] rows = sets[0];\n    assertOutput(\n        new Object[][] {\n          {\n            ThreadedMetric.BEGIN_IDENTIFIER,\n            firstID,\n            secondID,\n            thirdID,\n            ThreadedMetric.END_IDENTIFIER,\n            ThreadedMetric.ITERATIONS_HEADER\n          },\n          {currentTime, sleepInterval, sleepInterval, sleepInterval, sleepInterval, 1}\n        },\n        rows);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9263, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 44, "focalAPIEnd": 61, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()"], "useStart": [1731, 1870, 3149, 3265, 3740], "useEnd": [1748, 1887, 3166, 3282, 3757], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SANDAG/ABM/tree/master/src/main/java/org/sandag/abm/ctramp/HouseholdChoiceModelsTaskJppf.java", "rawCode": "  public void run() {\n\n    long startTime = System.nanoTime();\n\n    Logger logger = Logger.getLogger(this.getClass());\n\n    String threadName = null;\n    try {\n      threadName =\n          \"[\"\n              + java.net.InetAddress.getLocalHost().getHostName()\n              + \"] \"\n              + Thread.currentThread().getName();\n    } catch (UnknownHostException e1) {\n      // TODO Auto-generated catch block\n      e1.printStackTrace();\n    }\n\n    try {\n\n      DataProvider dataProvider = getDataProvider();\n\n      propertyMap = (HashMap<String, String>) dataProvider.getParameter(\"propertyMap\");\n      logResults =\n          Util.getStringValueFromPropertyMap(propertyMap, \"RunModel.LogResults\")\n              .equalsIgnoreCase(\"true\");\n      ms = (MatrixDataServerIf) dataProvider.getParameter(\"ms\");\n      hhDataManager = (HouseholdDataManagerIf) dataProvider.getParameter(\"hhDataManager\");\n      modelStructure = (ModelStructure) dataProvider.getParameter(\"modelStructure\");\n      dmuFactory = (CtrampDmuFactoryIf) dataProvider.getParameter(\"dmuFactory\");\n      restartModelString = (String) dataProvider.getParameter(\"restartModelString\");\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // get the factory object used to create and recycle\n    // HouseholdChoiceModels objects.\n    HouseholdChoiceModelsManager modelManager = HouseholdChoiceModelsManager.getInstance();\n    modelManager.managerSetup(\n        ms, hhDataManager, propertyMap, restartModelString, modelStructure, dmuFactory);\n\n    HouseholdChoiceModels hhModel = modelManager.getHouseholdChoiceModelsObject(taskIndex);\n\n    long setup1 = 0;\n    long setup2 = 0;\n    long setup3 = 0;\n    long setup4 = 0;\n    long setup5 = 0;\n\n    setup1 = (System.nanoTime() - startTime) / 1000000;\n\n    Household[] householdArray = hhDataManager.getHhArray(startIndex, endIndex);\n\n    setup2 = (System.nanoTime() - startTime) / 1000000;\n\n    boolean runDebugHouseholdsOnly =\n        Util.getBooleanValueFromPropertyMap(propertyMap, HouseholdDataManager.DEBUG_HHS_ONLY_KEY);\n\n    if (runWithTiming) hhModel.zeroTimes();\n    for (int i = 0; i < householdArray.length; i++) {\n\n      // for debugging only - process only household objects specified for\n      // debugging, if property key was set to true\n      if (runDebugHouseholdsOnly && !householdArray[i].getDebugChoiceModels()) continue;\n\n      try {\n        if (runWithTiming) hhModel.runModelsWithTiming(householdArray[i]);\n        else hhModel.runModels(householdArray[i]);\n      } catch (RuntimeException e) {\n        logger.fatal(\n            String.format(\n                \"exception caught in taskIndex=%d hhModel index=%d applying hh model for i=%d, hhId=%d.\",\n                taskIndex, hhModel.getModelIndex(), i, householdArray[i].getHhId()));\n        logger.fatal(\"Exception caught:\", e);\n        logger.fatal(\"Throwing new RuntimeException() to terminate.\");\n        throw new RuntimeException();\n      }\n    }\n\n    long[] componentTimes = hhModel.getTimes();\n    long[] partialStopTimes = hhModel.getPartialStopTimes();\n\n    if (hhModel.getMaxAlts() > maxAlts) maxAlts = hhModel.getMaxAlts();\n\n    setup3 = (System.nanoTime() - startTime) / 1000000;\n\n    hhDataManager.setHhArray(householdArray, startIndex);\n\n    setup4 = (System.nanoTime() - startTime) / 1000000;\n\n    logger.info(\n        String.format(\n            \"end of household choice model thread=%s, task[%d], hhModel[%d], startIndex=%d, endIndex=%d\",\n            threadName, taskIndex, hhModel.getModelIndex(), startIndex, endIndex));\n\n    setResult(\n        String.format(\n            \"taskIndex=%d, hhModelInstance=%d, startIndex=%d, endIndex=%d\",\n            taskIndex, hhModel.getModelIndex(), startIndex, endIndex));\n\n    setup5 = (System.nanoTime() - startTime) / 1000000;\n\n    if (logResults) {\n      logger.info(\n          \"task=\"\n              + taskIndex\n              + \", setup=\"\n              + setup1\n              + \", getHhs=\"\n              + (setup2 - setup1)\n              + \", processHhs=\"\n              + (setup3 - setup2)\n              + \", putHhs=\"\n              + (setup4 - setup3)\n              + \", return model=\"\n              + (setup5 - setup4)\n              + \".\");\n    }\n\n    if (runWithTiming)\n      logModelComponentTimes(componentTimes, partialStopTimes, logger, hhModel.getModelIndex());\n\n    // this has to be the last statement in this method.\n    // add this DestChoiceModel instance to the static queue shared by other\n    // tasks of this type\n    modelManager.returnHouseholdChoiceModelsObject(hhModel, startIndex, endIndex);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9264, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 53, "focalAPIEnd": 70, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [1442], "useEnd": [1459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gvtools/gvtools-legacy/tree/master/extensions/extSymbology/src-test/org/gvsig/remoteClient/sld/symbolizerTests/TestParseLineSymbolizer.java", "rawCode": "  public void testParsingMultiLine() {\n    long t1 = System.nanoTime();\n    try {\n      my_sld = SLDProtocolHandlerFactory.createVersionedProtocolHandler(f5);\n      ((SLDProtocolHandler) my_sld).parse(f5);\n\n      ArrayList<ISLDLayer> sldLayers = new ArrayList<ISLDLayer>();\n      sldLayers = my_sld.getLayers();\n      ArrayList<ISLDSymbolizer> symbolizers;\n      symbolizers = sldLayers.get(0).getSymbolizersByShapeType(FShape.LINE);\n      IMultiLayerSymbol multiLayerSymbol =\n          SymbologyFactory.createEmptyMultiLayerSymbol(FShape.LINE);\n\n      if (multiLayerSymbol != null) {\n        for (int i = 0; i < symbolizers.size(); i++) {\n          ISymbol sym = null;\n          sym = FMapSLDDriver.SLDSymbolizer2ISymbol(symbolizers.get(i));\n\n          multiLayerSymbol.addLayer(sym);\n        }\n        ISymbol defaultSym =\n            (multiLayerSymbol.getLayerCount() > 1)\n                ? multiLayerSymbol\n                : multiLayerSymbol.getLayer(0);\n\n        MultiLayerLineSymbol multiLine = (MultiLayerLineSymbol) defaultSym;\n\n        if (multiLine.getLayerCount() != 2) fail();\n      }\n    } catch (LegendDriverException e) {\n      e.printStackTrace();\n      fail();\n    } catch (IOException e) {\n      e.printStackTrace();\n      fail();\n    } catch (XmlPullParserException e) {\n      e.printStackTrace();\n      fail();\n    } catch (UnsupportedSLDVersionException e) {\n      e.printStackTrace();\n      fail();\n    }\n\n    long t2 = System.nanoTime();\n    System.out.println(\n        \"Test done with apparently no errors in \" + (t2 - (float) t1) / 1000 + \" nano-seconds\");\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9265, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "RegistryException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 320, "tryExpressionEnd": 324, "tryBlockStart": 320, "tryBlockEnd": 579, "catchExpressionStart": 513, "catchExpressionEnd": 541, "catchBlockStart": 513, "catchBlockEnd": 579, "exceptionHandlingCallStart": [551], "exceptionHandlingCallEnd": [570], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 351, "focalAPIEnd": 368, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [443], "useEnd": [460], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/commons/tree/master/qa/registry/performance-testing/wso2registry-perf-test-harness/src/org/wso2/registry/secure/AppDataPopulate.java", "rawCode": "  public void testrenamecollectiontime() throws RegistryException {\n\n    long totaltime = 0;\n    for (int i = 1; i <= maxFileToputCollections; i++) {\n\n      String path_1 = \"/dd\" + i;\n      String path_2 = path_1 + \"/bb\" + i;\n      String new_path_1 = \"/dd\" + i;\n      String new_path_2 = new_path_1 + \"/kk\" + i;\n\n      try {\n        long startTime = System.nanoTime();\n        adminRegistry.rename(path_2, new_path_2);\n        long runTime = System.nanoTime() - startTime;\n        totaltime += runTime;\n\n      } catch (RegistryException e) {\n        e.printStackTrace();\n      }\n    }\n    System.out.println(\n        \"Average time for collection rename: \"\n            + ((totaltime / 1000000) / maxFileToputResource)\n            + \" ms\");\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9266, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 418, "focalAPIEnd": 435, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srcvirus/floodlight/tree/master/src/test/java/net/floodlightcontroller/core/util/SingletonTaskTest.java", "rawCode": "  @Test\n  public void testDelay() throws InterruptedException {\n    ScheduledExecutorService ses = Executors.newSingleThreadScheduledExecutor();\n\n    SingletonTask st1 =\n        new SingletonTask(\n            ses,\n            new Runnable() {\n              @Override\n              public void run() {\n                ran += 1;\n                time = System.nanoTime();\n              }\n            });\n    long start = System.nanoTime();\n    st1.reschedule(10, TimeUnit.MILLISECONDS);\n    assertFalse(\"Check that task hasn't run yet\", ran > 0);\n\n    ses.shutdown();\n    ses.awaitTermination(5, TimeUnit.SECONDS);\n\n    assertEquals(\"Check that task ran\", 1, ran);\n    assertTrue(\n        \"Check that time passed appropriately\",\n        (time - start) >= TimeUnit.NANOSECONDS.convert(10, TimeUnit.MILLISECONDS));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9267, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["system.currentTimeMillis()"], "configurationStart": [142], "configurationEnd": [168], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 193, "focalAPIEnd": 210, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeLong()"], "useStart": [175], "useEnd": [211], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/peter-lawrey/Java-Chronicle/tree/master/chronicle/src/main/java/com/higherfrequencytrading/chronicle/tcp/gw/GatewayEntryWriter.java", "rawCode": "  @NotNull\n  public Excerpt startExceprt(int capacity, char type) {\n    excerpt.startExcerpt(HEADER_LENGTH + capacity);\n    excerpt.writeLong(System.currentTimeMillis());\n    excerpt.writeLong(System.nanoTime());\n    excerpt.writeLong(0L); // read timestamp\n    excerpt.writeInt24(0); // the length.\n    excerpt.writeByte(type); // the message type.\n    return excerpt;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9268, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 403, "focalAPIEnd": 420, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [571], "useEnd": [588], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wubs/485-Project/tree/master/pa6/hadoop/src/test/org/apache/hadoop/record/RecordBench.java", "rawCode": "  private static Record[] makeArray(String type, int numRecords, Times times) {\n    Method init = null;\n    try {\n      init =\n          RecordBench.class.getDeclaredMethod(\n              \"init\" + toCamelCase(type) + \"s\", new Class[] {Record[].class});\n    } catch (NoSuchMethodException ex) {\n      throw new RuntimeException(ex);\n    }\n\n    Record[] records = new Record[numRecords];\n    times.init = System.nanoTime();\n    try {\n      init.invoke(null, new Object[] {records});\n    } catch (Exception ex) {\n      throw new RuntimeException(ex);\n    }\n    times.init = System.nanoTime() - times.init;\n    return records;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9269, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 154, "focalAPIEnd": 171, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()", "report(,long)"], "useStart": [231, 255], "useEnd": [248, 273], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/davidbrazdil/dexter-backup/tree/master/cg_test/aosp-tests/028-array-write/src/Main.java", "rawCode": "  static void writeTest() {\n    long start, end;\n\n    writeArray(0); // touch all the memory\n\n    System.out.println(\"Running writeTest...\");\n    start = System.nanoTime();\n    for (int i = 1; i < 20; i++) writeArray(i);\n    end = System.nanoTime();\n\n    report(start, end);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9270, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 92, "focalAPIEnd": 109, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/element14/nocturne/tree/master/TestServer/src/org/tmatesoft/sqljet/core/internal/fs/SqlJetFile.java", "rawCode": "  /** */\n  private void TIMER_END() {\n    if (SQLJET_LOG_FILES_PERFORMANCE) timer_elapsed = System.nanoTime() - timer_start;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9271, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 671, "focalAPIEnd": 688, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [742], "useEnd": [759], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/lire/tree/master/src/test/java/net/semanticmetadata/lire/indexing/fastmap/FastMapTest.java", "rawCode": "  public void testAutoColorCorrelogramFastMap() {\n    // creating the list of user objects ...\n    LinkedList<LireFeature> objs = new LinkedList<LireFeature>();\n    for (Iterator<Document> documentIterator = docs.iterator(); documentIterator.hasNext(); ) {\n      Document document = documentIterator.next();\n      String[] cls = document.getValues(DocumentBuilder.FIELD_NAME_AUTOCOLORCORRELOGRAM);\n      if (cls.length > 0) {\n        AutoColorCorrelogram acc = new AutoColorCorrelogram();\n        acc.setStringRepresentation(cls[0]);\n        objs.add(acc);\n      }\n    }\n    System.out.println(\"--------------- < AutoColorCorrelogram > ---------------\");\n    long nano = System.nanoTime();\n    createFastMapForObjects(objs, null);\n    nano = System.nanoTime() - nano;\n    System.out.println(\"Time taken: ~ \" + (nano / (1000 * 1000)) + \" ms\");\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9272, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 509, "focalAPIEnd": 526, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeLong()", "system.nanoTime()"], "useStart": [491, 954], "useEnd": [527, 971], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/peter-lawrey/Java-Chronicle/tree/master/testing/src/main/java/com/higherfrequencytrading/chronicle/example/JETest.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    final String basePath = \"test\";\n    ChronicleTools.deleteOnExit(basePath);\n    final Chronicle chronicle = new IntIndexedChronicle(basePath);\n    final Excerpt excerpt = chronicle.createExcerpt();\n    final int[] consolidates = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n    int repeats = 10000;\n    for (int i = 0; i < repeats; i++) {\n      excerpt.startExcerpt(8 + 4 + 4 * consolidates.length);\n      excerpt.writeLong(System.nanoTime());\n      excerpt.writeInt(consolidates.length);\n      for (final int consolidate : consolidates) {\n        excerpt.writeInt(consolidate);\n      }\n      excerpt.finish();\n    }\n\n    long[] times = new long[repeats];\n    int[] nbcs = new int[repeats];\n    int count = 0;\n    final Excerpt excerpt2 = chronicle.createExcerpt();\n    while (excerpt2.nextIndex()) {\n      final long timestamp = excerpt2.readLong();\n      long time = System.nanoTime() - timestamp;\n      times[count] = time;\n      final int nbConsolidates = excerpt2.readInt();\n      nbcs[count] = nbConsolidates;\n      for (int i = 0; i < nbConsolidates; i++) {\n        excerpt2.readInt();\n      }\n      excerpt2.finish();\n      count++;\n    }\n    for (int i = 0; i < count; i++) {\n      System.out.print(\"latency: \" + times[i] / repeats / 1e3 + \" us average, \");\n      System.out.println(\"nbConsolidates: \" + nbcs[i]);\n    }\n    chronicle.close();\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9273, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 56, "focalAPIEnd": 73, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/metaborg/spoofax-debug/tree/master/org.strategoxt.imp.debug.stratego.transformer/editor/java/org/strategoxt/imp/debug/stratego/transformer/strategies/TimeMonitor.java", "rawCode": "  protected void end(String name) {\n    long endTimeN = System.nanoTime();\n    long endTime = System.currentTimeMillis();\n    long startTimeN = this.startMonitorsN.get(name);\n    long startTime = this.startMonitors.get(name);\n    long durationN = endTimeN - startTimeN;\n    long duration = endTime - startTime;\n    long totalDurationN = getDurationN(name) + durationN;\n    long totalDuration = getDuration(name) + duration;\n    this.timeMonitorsN.put(name, totalDurationN);\n    this.timeMonitors.put(name, totalDuration);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9274, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 577, "focalAPIEnd": 594, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()", "system.nanoTime()", "system.nanoTime()"], "useStart": [672, 848, 954], "useEnd": [689, 865, 971], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Johnmalc/Homeworks2/tree/master/Aufgabe9/src/de/aufgabe7/main/Search.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    // Auswahr der Art der Suche 0=linear, 1=binare\n    int choseSearch = Integer.parseInt(args[0]);\n\n    /*\n     * Anzahl der Elementen, die in der Liste geschpeichert werden von 0 bis\n     * yourNumber-1\n     */\n    int yourNumbers = Integer.parseInt(args[1]);\n\n    List<Integer> ls = new ArrayList<Integer>();\n    for (int n = 0; n < yourNumbers; n++) {\n      ls.add(n); // fuegt Elemente in die Liste ein\n    }\n\n    // decision based on \"choseSearch\" var.\n    if (choseSearch == 0) { // linear\n      long start = System.nanoTime();\n      System.out.println(Search.linear(ls, yourNumbers));\n      long stop = System.nanoTime();\n      System.out.printf(\"Elapsed time %1$1d ns\\n\", stop - start);\n    } else if (choseSearch == 1) { // binar\n      Collections.sort(ls);\n      long start = System.nanoTime();\n      System.out.println(Collections.binarySearch(ls, yourNumbers));\n      long stop = System.nanoTime();\n      System.out.printf(\"Elapsed time %1$1d ns\\n\", stop - start);\n    } else {\n      throw new Exception();\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9275, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 251, "focalAPIEnd": 268, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/feuyeux/quiland/tree/master/java/air-concurrent/src/main/java/creative/fire/concurrent/synchronizer/PhaserTest.java", "rawCode": "    @Override\n    public Long call() {\n      try {\n        System.out.println(sequence + \" ...\");\n        phaser.arriveAndAwaitAdvance();\n        doWork();\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n      return System.nanoTime();\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9276, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": -399, "focalAPIEnd": -382, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/util/concurrent/BlockingQueue/LoopHelpers.java", "rawCode": "    public void run() {\n      long t = System.nanoTime();\n      if (startTime == 0) startTime = t;\n      else endTime = t;\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9277, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 127, "focalAPIEnd": 144, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mkeesey/guava-for-small-classpaths/tree/master/guava-tests/test/com/google/common/util/concurrent/SimpleTimeLimiterTest.java", "rawCode": "  private static void assertTheCallTookBetween(\n      long startNanos, int atLeastMillis, int atMostMillis) {\n    long nanos = System.nanoTime() - startNanos;\n    assertTrue(nanos >= atLeastMillis * 1000000);\n    assertTrue(nanos <= atMostMillis * 1000000);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9278, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 438, "focalAPIEnd": 455, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [2893], "useEnd": [2910], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/oferfrid/PrecisExciteTCP/tree/master/sandboxScripts/GaussianFitStack_.java", "rawCode": "  public void run(String arg) {\n\n    gs_ = new GaussianResidual();\n    nm_ = new NelderMead();\n    convergedChecker_ = new SimpleScalarValueChecker(1e-5, -1);\n\n    // List with spot positions found through the Find Maxima command\n    Vector<Vector<SpotPoint>> spotList = new Vector<Vector<SpotPoint>>();\n    Vector<SpotPoint> frameSpotList;\n\n    // take the active ImageJ image\n    ImagePlus siPlus = IJ.getImage();\n\n    long startTime = System.nanoTime();\n\n    // first find local maxima\n    // MaximumFinder maxFinder = new MaximumFinder();\n    for (int i = 1; i <= siPlus.getStackSize(); i++) {\n      frameSpotList = new Vector<SpotPoint>();\n      siPlus.setSlice(i);\n      IJ.run(\"Find Maxima...\", \"noise=500 output=List\");\n      // maxFinder.findMaxima(siPlus.getStack().getProcessor(i), 500.0, ImageProcessor.NO_THRESHOLD,\n      // MaximumFinder.LIST, false, false);\n\n      ResultsTable rt = ResultsTable.getResultsTable();\n\n      for (int j = 0; j < rt.getCounter(); j++) {\n        int x = (int) rt.getValueAsDouble(0, j);\n        int y = (int) rt.getValueAsDouble(1, j);\n        SpotPoint thisSpot = new SpotPoint(x, y);\n        frameSpotList.add(thisSpot);\n      }\n      spotList.add(frameSpotList);\n    }\n\n    int halfSize = 8;\n    int i = 0;\n    int spotCount = 0;\n\n    ResultsTable rt = new ResultsTable();\n    rt.reset();\n\n    for (Vector<SpotPoint> frameList : spotList) {\n      int j = 0;\n      for (SpotPoint mySpot : frameList) {\n        // IJ.log (i + \" \" + j + \" \" + mySpot.getX() + \" \" + mySpot.getY());\n        Roi spotRoi =\n            new Roi(mySpot.getX() - halfSize, mySpot.getY() - halfSize, 2 * halfSize, 2 * halfSize);\n        siPlus.setSlice(i + 1);\n        siPlus.setRoi(spotRoi);\n        ImageProcessor ip = siPlus.getProcessor().crop();\n        double[] paramsOut = doGaussianFit(ip);\n\n        if (paramsOut.length >= 4) {\n          rt.incrementCounter();\n          double anormalized = paramsOut[0] * (2 * Math.PI * paramsOut[3] * paramsOut[3]);\n          rt.addValue(\"Frame\", i + 1);\n          rt.addValue(\"Spot\", j);\n          rt.addValue(\"Intensity\", anormalized);\n          rt.addValue(\"Background\", paramsOut[4]);\n          rt.addValue(\"X\", paramsOut[1] - halfSize + mySpot.getX());\n          rt.addValue(\"Y\", paramsOut[2] - halfSize + mySpot.getY());\n          rt.addValue(\"Sigma\", paramsOut[3]);\n        }\n\n        spotCount++;\n        j++;\n      }\n      i++;\n    }\n    String rtTitle = \"Gaussian Fit Result for \" + siPlus.getWindow().getTitle();\n    rt.show(rtTitle);\n    // Attach listener to TextPanel\n    TextPanel tp;\n    Frame frame = WindowManager.getFrame(rtTitle);\n    TextWindow win;\n    if (frame != null && frame instanceof TextWindow) {\n      win = (TextWindow) frame;\n      tp = win.getTextPanel();\n      MyK myk = new MyK(siPlus, rt, win, halfSize);\n      tp.addKeyListener(myk);\n      tp.addMouseListener(myk);\n    }\n\n    long endTime = System.nanoTime();\n    double took = (endTime - startTime) / 1E6;\n\n    print(\"Analyzed \" + spotCount + \" spots in \" + took + \" milliseconds\");\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9279, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "println(String)"], "tryExpressionStart": 74, "tryExpressionEnd": 78, "tryBlockStart": 74, "tryBlockEnd": 498, "catchExpressionStart": 352, "catchExpressionEnd": 372, "catchBlockStart": 352, "catchBlockEnd": 498, "exceptionHandlingCallStart": [384, 415], "exceptionHandlingCallEnd": [403, 458], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 184, "focalAPIEnd": 201, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setBlockingBaseTime()", "system.nanoTime()"], "useStart": [213, 288], "useEnd": [238, 305], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/lang/management/ThreadMXBean/SynchronizationStatistics.java", "rawCode": "    private void waitObj(long ms) {\n      synchronized (waiter) {\n        try {\n          // notify examinerabout to wait on a monitor\n          notifyWaiter();\n\n          long base = System.nanoTime();\n          setBlockingBaseTime(base);\n          waiter.wait(ms);\n          long now = System.nanoTime();\n          addWaitTime(now - base);\n        } catch (Exception e) {\n          e.printStackTrace();\n          System.out.println(\"Unexpected exception.\");\n          testFailed = true;\n        }\n      }\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9280, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 76, "focalAPIEnd": 93, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()", "system.nanoTime()", "system.nanoTime()", "system.nanoTime()"], "useStart": [141, 206, 271, 337], "useEnd": [158, 223, 288, 354], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/tests/055-enum-performance/src/Main.java", "rawCode": "  public static void run(boolean timing) {\n    preTest();\n\n    long time0 = System.nanoTime();\n    int count1 = test1(500);\n    long time1 = System.nanoTime();\n    int count2 = test2(500);\n    long time2 = System.nanoTime();\n    int count3 = test3(500);\n    long time3 = System.nanoTime();\n    int count4 = basis(2000);\n    long time4 = System.nanoTime();\n\n    System.out.println(\"basis: performed \" + count4 + \" iterations\");\n    System.out.println(\"test1: performed \" + count1 + \" iterations\");\n    System.out.println(\"test2: performed \" + count2 + \" iterations\");\n    System.out.println(\"test3: performed \" + count3 + \" iterations\");\n\n    double msec1 = (time1 - time0) / (double) count1 / 1000000;\n    double msec2 = (time2 - time1) / (double) count2 / 1000000;\n    double msec3 = (time3 - time2) / (double) count3 / 1000000;\n    double basisMsec = (time4 - time3) / (double) count4 / 1000000;\n\n    double avg = (msec1 + msec2 + msec3) / 3;\n    if (avg < (basisMsec * 25)) {\n      System.out.println(\"Timing is acceptable.\");\n    } else {\n      System.out.println(\"Iterations are taking too long!\");\n      timing = true;\n    }\n\n    if (timing) {\n      System.out.printf(\"basis time: %.3g msec\\n\", basisMsec);\n      System.out.printf(\"test1: %.3g msec per iteration\\n\", msec1);\n      System.out.printf(\"test2: %.3g msec per iteration\\n\", msec2);\n      System.out.printf(\"test3: %.3g msec per iteration\\n\", msec3);\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9281, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 1420, "focalAPIEnd": 1437, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/rt/libcore/luni/src/main/java/java/util/concurrent/SynchronousQueue.java", "rawCode": "    /**\n     * Spins/blocks until node s is matched by a fulfill operation.\n     *\n     * @param s the waiting node\n     * @param timed true if timed wait\n     * @param nanos timeout value\n     * @return matched node, or s if cancelled\n     */\n    SNode awaitFulfill(SNode s, boolean timed, long nanos) {\n      /*\n       * When a node/thread is about to block, it sets its waiter\n       * field and then rechecks state at least one more time\n       * before actually parking, thus covering race vs\n       * fulfiller noticing that waiter is non-null so should be\n       * woken.\n       *\n       * When invoked by nodes that appear at the point of call\n       * to be at the head of the stack, calls to park are\n       * preceded by spins to avoid blocking when producers and\n       * consumers are arriving very close in time. This can\n       * happen enough to bother only on multiprocessors.\n       *\n       * The order of checks for returning out of main loop\n       * reflects fact that interrupts have precedence over\n       * normal returns, which have precedence over\n       * timeouts. (So, on timeout, one last check for match is\n       * done before giving up.) Except that calls from untimed\n       * SynchronousQueue.{poll/offer} don't check interrupts\n       * and don't wait at all, so are trapped in transfer\n       * method rather than calling awaitFulfill.\n       */\n      final long deadline = timed ? System.nanoTime() + nanos : 0L;\n      Thread w = Thread.currentThread();\n      int spins = (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0);\n      for (; ; ) {\n        if (w.isInterrupted()) s.tryCancel();\n        SNode m = s.match;\n        if (m != null) return m;\n        if (timed) {\n          nanos = deadline - System.nanoTime();\n          if (nanos <= 0L) {\n            s.tryCancel();\n            continue;\n          }\n        }\n        if (spins > 0) spins = shouldSpin(s) ? (spins - 1) : 0;\n        else if (s.waiter == null) s.waiter = w; // establish waiter so can park next iter\n        else if (!timed) LockSupport.park(this);\n        else if (nanos > spinForTimeoutThreshold) LockSupport.parkNanos(this, nanos);\n      }\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9282, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 105, "focalAPIEnd": 122, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [784], "useEnd": [801], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/delleceste/it.giacomos.android.osmer/tree/master/Osmer/src/it/giacomos/android/osmer/observations/NearestObservationData.java", "rawCode": "  public ObservationData get(Location location, ObservationsCache observationsCache) {\n    long startT = System.nanoTime();\n    LatLng myLatLng = new LatLng(location.getLatitude(), location.getLongitude());\n    LocationNamesMap locationNamesMap = new LocationNamesMap();\n    ArrayList<LatLng> points = new ArrayList<LatLng>(locationNamesMap.getMap().values());\n    NearLocationFinder nearLocationFinder = new NearLocationFinder();\n    LatLng nearestLocation = nearLocationFinder.nearestLocation(myLatLng, points);\n    String nearestLocationName = locationNamesMap.getLocationName(nearestLocation);\n\n    HashMap<String, ObservationData> latestObsData = observationsCache.getLatestObservationData();\n    ObservationData obsData = latestObsData.get(nearestLocationName);\n    long endT = System.nanoTime();\n    return obsData;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9283, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 287, "focalAPIEnd": 304, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [1219], "useEnd": [1236], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FoxyCorndog/WorkspaceOld/tree/master/gafggfds/LWJGL/lwjgl-2.8.5/src/java/org/lwjgl/test/mapped/MappedObjectBench.java", "rawCode": "  static void benchmarkUnsafe() {\n    final int runs = 64;\n    final int iterations = 64 * 1024;\n\n    ByteBuffer bb = ByteBuffer.allocateDirect(200);\n    long addr = MemoryUtil.getAddress(bb);\n\n    long[] took = new long[runs];\n    for (int run = 0; run < runs; run++) {\n      long t0 = System.nanoTime();\n      for (int iteration = 0; iteration < iterations; iteration++) {\n        fput(13, addr + (1 * 3 + 0) * 4);\n        fput(\n            fget(addr + (1 * 3 + 1) * 4)\n                + fget(addr + (1 * 3 + 1) * 4) * fget(addr + (1 * 3 + 0) * 4)\n                + 0.3f,\n            addr + (1 * 3 + 1) * 4);\n        fput(\n            fget(addr + (1 * 3 + 2) * 4)\n                + fget(addr + (2 * 3 + 1) * 4)\n                + fget(addr + (1 * 3 + 0) * 4)\n                + 0.3f,\n            addr + (1 * 3 + 2) * 4);\n        fput(\n            fget(addr + (2 * 3 + 2) * 4)\n                + fget(addr + (2 * 3 + 1) * 4)\n                + fget(addr + (1 * 3 + 0) * 4),\n            addr + (2 * 3 + 2) * 4);\n        fput(\n            fget(addr + (3 * 3 + 2) * 4)\n                + fget(addr + (2 * 3 + 2) * 4)\n                + fget(addr + (2 * 3 + 1) * 4),\n            addr + (3 * 3 + 2) * 4);\n      }\n      long t1 = System.nanoTime();\n      took[run] = t1 - t0;\n    }\n\n    Arrays.sort(took);\n    System.out.println(\"unsafe took: \" + took[took.length / 2] / 1024 + \"us\");\n\n    System.out.println(bb);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9284, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 896, "focalAPIEnd": 913, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/djmailhot/CSE461projects/tree/master/util/src/edu/uw/cs/cse461/util/SampledStatistic.java", "rawCode": "    /**\n     * Indicates that the elapsed time since start() was called is no longer of interest, and so no\n     * new sample should be generated by ending the measurement interval. This might happen, for\n     * instance, if some exceptional condition occurs. Note that it is not an error to abort a timer\n     * that hasn't been started. (This makes it easier to catch errors over a long code sequence, as\n     * you don't have to keep track of just which timers have and which haven't yet been started.)\n     *\n     * @param key The name of a timer.\n     * @return The length of the measured interval, in msec.\n     */\n    public static double abort(String key) {\n      if (key == null) throw new RuntimeException(\"ElapsedTime key can't be null\");\n      ElapsedTimeInterval entry = mSampleSetManager.get(key);\n      if (entry == null || entry.mStartTime < 0) return 0.0;\n      double sample = (System.nanoTime() - entry.mStartTime) * MSEC_SCALE;\n      entry.mStartTime = -1;\n\n      entry.abort();\n      return sample;\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9285, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 674, "focalAPIEnd": 691, "followUpCheck": "(true || (nextschedule - ) <= 0)", "checkType": "IF", "followUpCheckExpressionStart": 703, "followUpCheckExpressionEnd": 756, "followUpCheckBlockStart": 703, "followUpCheckBlockEnd": 908, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wallnerryan/floodlight/tree/master/src/main/java/net/floodlightcontroller/core/util/SingletonTask.java", "rawCode": "    @Override\n    @LogMessageDoc(\n      level = \"ERROR\",\n      message = \"Exception while executing task\",\n      recommendation = LogMessageDoc.GENERIC_ACTION\n    )\n    public void run() {\n      synchronized (parent.context) {\n        if (canceled || !parent.context.taskShouldRun) return;\n\n        parent.context.taskRunning = true;\n        parent.context.taskShouldRun = false;\n      }\n\n      try {\n        parent.task.run();\n      } catch (Exception e) {\n        logger.error(\"Exception while executing task\", e);\n      }\n\n      synchronized (parent.context) {\n        parent.context.taskRunning = false;\n\n        if (parent.context.taskShouldRun) {\n          long now = System.nanoTime();\n          if ((nextschedule <= 0 || (nextschedule - now) <= 0)) {\n            parent.ses.execute(this);\n          } else {\n            parent.ses.schedule(this, nextschedule - now, TimeUnit.NANOSECONDS);\n          }\n        }\n      }\n    }\n"}, {"dataset": "nanoTime", "exampleID": 9286, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["system.currentTimeMillis()"], "configurationStart": [231], "configurationEnd": [257], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 290, "focalAPIEnd": 307, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["valueOf()"], "useStart": [268], "useEnd": [308], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/spring-insight-plugins/tree/master/collection-plugins/logging/src/test/java/com/springsource/insight/plugin/logging/Slf4jLoggingOperationCollectionAspectTest.java", "rawCode": "  @Test\n  public void testLogFormatErrorWith2Values() {\n    String msg = \"testLogFormatErrorWith2Values: %d/%d\";\n    Logger logger = LoggerFactory.getLogger(getClass());\n    logger.error(\n        msg,\n        Integer.valueOf((int) System.currentTimeMillis()),\n        Integer.valueOf((int) System.nanoTime()));\n    assertLoggingOperation(logger, \"ERROR\", msg, null);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9287, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 109, "focalAPIEnd": 126, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srcvirus/floodlight/tree/master/src/main/java/net/floodlightcontroller/perfmon/CumulativeTimeBucket.java", "rawCode": "  /** Resets all counters and counters for each component time */\n  public void reset() {\n    startTime_ns = System.nanoTime();\n    totalPktCnt = 0;\n    totalProcTimeNs = 0;\n    avgTotalProcTimeNs = 0;\n    sumSquaredProcTimeNs2 = 0;\n    maxTotalProcTimeNs = Long.MIN_VALUE;\n    minTotalProcTimeNs = Long.MAX_VALUE;\n    sigmaTotalProcTimeNs = 0;\n    for (OneComponentTime oct : compStats.values()) {\n      oct.resetAllCounters();\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9288, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 1873, "focalAPIEnd": 1890, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [2747], "useEnd": [2764], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/societies/SOCIETIES-Platform/tree/master/context-management/ContextBroker/src/main/java/org/societies/context/broker/impl/InternalCtxBroker.java", "rawCode": "  @Override\n  @Async\n  public Future<CtxModelObject> retrieve(final Requestor requestor, final CtxIdentifier ctxId)\n      throws CtxException {\n\n    if (requestor == null) {\n      throw new NullPointerException(\"requestor can't be null\");\n    }\n    if (ctxId == null) {\n      throw new NullPointerException(\"ctxId can't be null\");\n    }\n\n    LOG.debug(\"retrieve: requestor={}, ctxId={}\", requestor, ctxId);\n\n    CtxModelObject result = null;\n\n    // Extract target IIdentity\n    final IIdentity target = this.extractIIdentity(ctxId);\n\n    // Log with Privacy Log Appender\n    this.logRequest(requestor, target);\n\n    if (this.isLocalId(target)) { // L O C A L\n\n      // Check if access control is required.\n      if (!requestor.equals(this.getLocalRequestor())) {\n        // Check READ permission\n        this.ctxAccessController.checkPermission(requestor, ctxId, ActionConstants.READ);\n      }\n      // No CtxAccessControlException thrown implies READ access has been granted\n\n      if (IdentityType.CIS != target.getType()) { // U S E R\n\n        if (ctxId instanceof CtxAttributeIdentifier) { // I N F E R E N C E\n          result = this.inferUserAttribute((CtxAttributeIdentifier) ctxId);\n        } else {\n          result = this.userCtxDBMgr.retrieve(ctxId);\n        }\n\n      } else { // C O M M U N I T Y\n\n        if (ctxId instanceof CtxAttributeIdentifier) { // I N F E R E N C E\n          result = this.inferCommunityAttribute((CtxAttributeIdentifier) ctxId);\n        } else {\n          result = this.communityCtxDBMgr.retrieve(ctxId);\n        }\n      }\n\n      // Obfuscate non-null result if requestor is not local\n      if (result != null && !requestor.equals(this.getLocalRequestor())) {\n        result = this.ctxAccessController.obfuscate(requestor, result);\n      }\n\n    } else { // R E M O T E\n\n      // Needed for performance test\n      long initTimestamp = System.nanoTime();\n\n      final RetrieveCtxCallback callback = new RetrieveCtxCallback();\n      this.ctxBrokerClient.retrieve(requestor, ctxId, callback);\n      synchronized (callback) {\n        try {\n          callback.wait();\n          if (callback.getException() == null) {\n            result = callback.getResult();\n          } else {\n            throw callback.getException();\n          }\n\n          // Needed for performance test\n          if (PERF_LOG.isTraceEnabled()) {\n            final IPerformanceMessage m = new PerformanceMessage();\n            m.setTestContext(\"ContextBroker_Delay_RemoteContextRetrieval\");\n            m.setSourceComponent(this.getClass().getName());\n            m.setPerformanceType(IPerformanceMessage.Delay);\n            m.setOperationType(\"RemoteCSS_ContextRetrieval\");\n            m.setD82TestTableName(\"S11\");\n            long delay = System.nanoTime() - initTimestamp;\n            m.setPerformanceNameValue(\"Delay=\" + (delay));\n            PERF_LOG.trace(m.toString());\n          }\n\n        } catch (InterruptedException e) {\n\n          throw new CtxBrokerException(\"Interrupted while waiting for remote retrieve\");\n        }\n      }\n    }\n\n    LOG.debug(\"retrieve: result={}\", result);\n    return new AsyncResult<CtxModelObject>(result);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9289, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 103, "focalAPIEnd": 120, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ecki/seeburger-vfs2/tree/master/vfs2provider-jdbctable/src/test/java/com/seeburger/vfs2/provider/jdbctable/test/SimpleTestsBase.java", "rawCode": "  @Test\n  public void testRenameOverExisting() throws IOException, SQLException {\n    final long now = System.nanoTime();\n\n    // create two files\n    final FileObject testFile = manager.resolveFile(\"seejt:///key/testRenameOverExisting_A_\" + now);\n    final FileObject targetFile =\n        manager.resolveFile(\"seejt:///key/testRenameOverExisting_B_\" + now);\n\n    assertFalse(testFile.exists());\n    assertEquals(FileType.IMAGINARY, testFile.getType());\n\n    testFile.createFile();\n    assertTrue(testFile.exists());\n    assertEquals(FileType.FILE, testFile.getType());\n\n    assertEquals(FileType.IMAGINARY, targetFile.getType());\n    assertFalse(targetFile.exists());\n    targetFile.createFile();\n\n    assertTrue(targetFile.exists());\n    assertEquals(FileType.FILE, targetFile.getType());\n\n    // rename existing file over existing target\n    testFile.moveTo(targetFile); // TODO: make overwrites this atomic in the provider\n\n    assertFalse(testFile.exists());\n    assertEquals(FileType.IMAGINARY, testFile.getType());\n\n    assertTrue(targetFile.exists());\n    assertEquals(FileType.FILE, targetFile.getType());\n\n    verifyDatabase();\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9290, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 68, "focalAPIEnd": 85, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [164], "useEnd": [181], "hasFinally": 1, "cleanUpCall": ["nanoTime()", "toString()", "printf(String,*,long)"], "finallyExpressionStart": 126, "finallyExpressionEnd": 134, "finallyBlockStart": 126, "finallyBlockEnd": 325, "cleanUpCallStart": [164, 292, 260], "cleanUpCallEnd": [181, 302, 318], "url": "https://github.com/lowasser/guava-experimental/tree/master/guava-tests/test/com/google/common/util/concurrent/JSR166TestCase.java", "rawCode": "  protected void runTestProfiled() throws Throwable {\n    long t0 = System.nanoTime();\n    try {\n      super.runTest();\n    } finally {\n      long elapsedMillis = (System.nanoTime() - t0) / (1000L * 1000L);\n      if (elapsedMillis >= profileThreshold)\n        System.out.printf(\"%n%s: %d%n\", toString(), elapsedMillis);\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9291, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 54, "focalAPIEnd": 71, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [661], "useEnd": [678], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/PhiCode/philib/tree/master/src/test/java/ch/bind/philib/io/RingBufferTest.java", "rawCode": "  private void doBenchmark() {\n    final long start = System.nanoTime();\n    RingBuffer ringBuf = new RingBuffer();\n    byte[] buf = new byte[PERF_CHUNKSIZE];\n    ThreadLocalRandom.current().nextBytes(buf);\n    long performed = 0;\n    while (performed < PERF_SIZE) {\n      ringBuf.write(buf);\n      ringBuf.writeFront(buf);\n      ringBuf.read(buf);\n      ringBuf.writeFront(buf);\n      ringBuf.readBack(buf);\n      ringBuf.write(buf);\n      ringBuf.read(buf);\n      ringBuf.writeFront(buf);\n      ringBuf.readBack(buf);\n      ringBuf.read(buf);\n      performed += (PERF_CHUNKSIZE * 10);\n      assertEquals(0, ringBuf.available());\n    }\n    final long timeNs = System.nanoTime() - start;\n    double mib = ((double) performed / MB);\n    TestUtil.printBenchResults(RingBuffer.class, \"MiB\", \"MiB\", timeNs, mib);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9292, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 156, "focalAPIEnd": 173, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgothel/jogl/tree/master/src/newt/classes/jogamp/newt/ScreenImpl.java", "rawCode": "  @Override\n  public final synchronized void createNative() throws NativeWindowException {\n    if (null == aScreen) {\n      if (DEBUG) {\n        tCreated = System.nanoTime();\n        System.err.println(\n            \"Screen.createNative() START (\" + Display.getThreadName() + \", \" + this + \")\");\n      } else {\n        tCreated = 0;\n      }\n      display.addReference();\n\n      createNativeImpl();\n      if (null == aScreen) {\n        throw new NativeWindowException(\n            \"Screen.createNative() failed to instanciate an AbstractGraphicsScreen\");\n      }\n\n      initMonitorState();\n      synchronized (screenList) {\n        screensActive++;\n        if (DEBUG) {\n          System.err.println(\n              \"Screen.createNative() END (\"\n                  + Display.getThreadName()\n                  + \", \"\n                  + this\n                  + \"), active \"\n                  + screensActive\n                  + \", total \"\n                  + (System.nanoTime() - tCreated) / 1e6\n                  + \"ms\");\n        }\n      }\n      ScreenMonitorState.getScreenMonitorState(this.getFQName()).addListener(this);\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9293, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 238, "focalAPIEnd": 255, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/nio/channels/Selector/LotsOfCancels.java", "rawCode": "  /**\n   * Returns the elapsed time since startNanos, in milliseconds.\n   *\n   * @param startNanos the start time; this must be a value returned by {@link System.nanoTime}\n   */\n  static long durationMillis(long startNanos) {\n    return (System.nanoTime() - startNanos) / (1000L * 1000L);\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9294, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 54, "focalAPIEnd": 71, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Random()"], "useStart": [93], "useEnd": [109], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/proofpoint/kairosdb/tree/master/src/test/java/org/kairosdb/core/aggregator/StdAggregatorTest.java", "rawCode": "  @Test\n  public void test_random() {\n    long seed = System.nanoTime();\n    Random random = new Random(seed);\n\n    long[] values = new long[1000];\n    ListDataPointGroup group = new ListDataPointGroup(\"group\");\n    for (int i = 0; i < values.length; i++) {\n      long randomValue = random.nextLong();\n      group.addDataPoint(new LongDataPoint(1, randomValue));\n      values[i] = randomValue;\n    }\n\n    StdAggregator aggregator = new StdAggregator(new DoubleDataPointFactoryImpl());\n\n    DataPointGroup dataPointGroup = aggregator.aggregate(group);\n\n    DataPoint stdev = dataPointGroup.next();\n    double expected = naiveStdDev(values);\n    double epsilon = 0.001 * expected;\n    assertThat(stdev.getDoubleValue(), closeTo(expected, epsilon));\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9295, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 388, "focalAPIEnd": 405, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dianping/cat/tree/master/cat-client/src/main/java/com/dianping/cat/message/internal/DefaultTransaction.java", "rawCode": "  @Override\n  public void complete() {\n    try {\n      if (isCompleted()) {\n        // complete() was called more than once\n        DefaultEvent event = new DefaultEvent(\"cat\", \"BadInstrument\");\n\n        event.setStatus(\"TransactionAlreadyCompleted\");\n        event.complete();\n        addChild(event);\n      } else {\n        if (m_durationInMicro == -1) {\n          m_durationInMicro = (System.nanoTime() - m_durationStart) / 1000L;\n        }\n        setCompleted(true);\n        if (m_manager != null) {\n          m_manager.end(this);\n        }\n      }\n    } catch (Exception e) {\n      // ignore\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9296, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 933, "focalAPIEnd": 950, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new MockMarketDataFeedCredentials()", "assertEquals(,*)"], "useStart": [1015, 1059], "useEnd": [1053, 1098], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonatas/mktc-platform/tree/master/source/core/src/test/java/org/marketcetera/marketdata/AbstractMarketDataFeedCredentialsTest.java", "rawCode": "  @Test\n  public void testValidate() throws Exception {\n    MockMarketDataFeedCredentials.sValidateThrowsThrowable = true;\n    new ExpectedFailure<FeedException>(NULL_URL) {\n      @Override\n      protected void run() throws Exception {\n        new MockMarketDataFeedCredentials(null);\n      }\n    };\n    new ExpectedFailure<FeedException>(NULL_URL) {\n      @Override\n      protected void run() throws Exception {\n        new MockMarketDataFeedCredentials(\"\");\n      }\n    };\n    new ExpectedFailure<FeedException>(NULL_URL) {\n      @Override\n      protected void run() throws Exception {\n        new MockMarketDataFeedCredentials(\" \");\n      }\n    };\n    new ExpectedFailure<NullPointerException>() {\n      @Override\n      protected void run() throws Exception {\n        new MockMarketDataFeedCredentials(\"someURL\");\n      }\n    };\n    MockMarketDataFeedCredentials.sValidateThrowsThrowable = false;\n    String url = \"http://url-\" + System.nanoTime(); // $NON-NLS-1$\n    MockMarketDataFeedCredentials credentials = new MockMarketDataFeedCredentials(url);\n    assertEquals(url, credentials.getURL());\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9297, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 1127, "focalAPIEnd": 1144, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [1294], "useEnd": [1311], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seph-lang/seph/tree/master/src/main/seph/lang/Base.java", "rawCode": "  @SephMethod(evaluateArguments = false)\n  public static final SephObject benchmark(\n      SThread thread, LexicalScope scope, MethodHandle[] args) {\n    int count = args.length;\n    int repetitions = 10;\n    int iterations = 1;\n    String label = null;\n    int argsLeft = 0;\n    Object code = null;\n    if (count == 4) {\n      label =\n          ((Text) ControlDefaultBehavior.evaluateArgument(args[argsLeft++], scope, thread, true))\n              .text();\n    }\n    if (count > 1) {\n      repetitions =\n          ((gnu.math.IntNum)\n                  ControlDefaultBehavior.evaluateArgument(args[argsLeft++], scope, thread, true))\n              .intValue();\n    }\n    if (count > 2) {\n      iterations =\n          ((gnu.math.IntNum)\n                  ControlDefaultBehavior.evaluateArgument(args[argsLeft++], scope, thread, true))\n              .intValue();\n    }\n    code = args[argsLeft];\n\n    String separatorType = System.getProperty(\"seph.benchmark.format\");\n    if (separatorType == null || separatorType.equals(\"\")) {\n      separatorType = \"human\";\n    }\n\n    for (int i = 0; i < repetitions; i++) {\n      long before = System.nanoTime();\n      for (int j = 0; j < iterations; j++) {\n        ControlDefaultBehavior.evaluateArgument(code, scope, thread, true);\n      }\n      long after = System.nanoTime();\n      long time = after - before;\n      long secs = time / 1000000000;\n      long rest = time % 1000000000;\n\n      if (separatorType.equals(\"human\")) {\n        if (label != null) {\n          System.out.println(String.format(\"%-32.32s %.6s.%09d\", label, secs, rest));\n        } else {\n          System.out.println(String.format(\"%.6s.%09d\", secs, rest));\n        }\n      } else {\n        if (label != null) {\n          System.out.println(String.format(\"%s|%.6s.%09d\", label, secs, rest));\n        } else {\n          System.out.println(String.format(\"|%.6s.%09d\", secs, rest));\n        }\n      }\n    }\n\n    return Runtime.NIL;\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9298, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 332, "focalAPIEnd": 359, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/tools/org/h2/java/lang/System.java", "rawCode": "  /**\n   * Get the current time in milliseconds since 1970-01-01.\n   *\n   * @return the milliseconds\n   */\n  public static long nanoTime() {\n    /* c:\n    #if CLOCKS_PER_SEC == 1000000\n    return (jlong) clock() * 1000;\n    #else\n    return (jlong) clock() * 1000000 / CLOCKS_PER_SEC;\n    #endif\n    */\n    // c: return;\n    return java.lang.System.nanoTime();\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9299, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 88, "focalAPIEnd": 105, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Random()", "system.nanoTime()", "system.nanoTime()"], "useStart": [77, 2023, 2136], "useEnd": [106, 2040, 2153], "hasFinally": 1, "cleanUpCall": ["HttpClient.stop()"], "finallyExpressionStart": 3014, "finallyExpressionEnd": 3022, "finallyBlockStart": 3014, "finallyBlockEnd": 3058, "cleanUpCallStart": [3034], "cleanUpCallEnd": [3047], "url": "https://github.com/stas/pos/tree/master/jetty/contrib/terracotta/src/test/java/org/mortbay/terracotta/servlet/LightLoadTest.java", "rawCode": "  @Test\n  public void testLightLoad() throws Exception {\n    Random random = new Random(System.nanoTime());\n\n    String contextPath = \"\";\n    String servletMapping = \"/server\";\n    int port1 = random.nextInt(50000) + 10000;\n    TerracottaJettyServer server1 = new TerracottaJettyServer(port1);\n    server1.addContext(contextPath).addServlet(TestServlet.class, servletMapping);\n    server1.start();\n    try {\n      int port2 = random.nextInt(50000) + 10000;\n      TerracottaJettyServer server2 = new TerracottaJettyServer(port2);\n      server2.addContext(contextPath).addServlet(TestServlet.class, servletMapping);\n      server2.start();\n      try {\n        HttpClient client = new HttpClient();\n        client.setConnectorType(HttpClient.CONNECTOR_SOCKET);\n        client.start();\n        try {\n          String[] urls = new String[2];\n          urls[0] = \"http://localhost:\" + port1 + contextPath + servletMapping;\n          urls[1] = \"http://localhost:\" + port2 + contextPath + servletMapping;\n\n          ContentExchange exchange1 = new ContentExchange(true);\n          exchange1.setMethod(HttpMethods.GET);\n          exchange1.setURL(urls[0] + \"?action=init\");\n          client.send(exchange1);\n          exchange1.waitForDone();\n          assert exchange1.getResponseStatus() == HttpServletResponse.SC_OK;\n          String sessionCookie = exchange1.getResponseFields().getStringField(\"Set-Cookie\");\n          assert sessionCookie != null;\n\n          ExecutorService executor = Executors.newCachedThreadPool();\n          int clientsCount = 10;\n          CyclicBarrier barrier = new CyclicBarrier(clientsCount + 1);\n          int requestsCount = 100;\n          Worker[] workers = new Worker[clientsCount];\n          for (int i = 0; i < clientsCount; ++i) {\n            workers[i] = new Worker(barrier, requestsCount, sessionCookie, urls);\n            workers[i].start();\n            executor.execute(workers[i]);\n          }\n          // Wait for all workers to be ready\n          barrier.await();\n          long start = System.nanoTime();\n\n          // Wait for all workers to be done\n          barrier.await();\n          long end = System.nanoTime();\n          long elapsed = TimeUnit.NANOSECONDS.toMillis(end - start);\n          System.out.println(\"elapsed ms: \" + elapsed);\n\n          for (Worker worker : workers) worker.stop();\n          executor.shutdownNow();\n\n          // Perform one request to get the result\n          ContentExchange exchange2 = new ContentExchange(true);\n          exchange2.setMethod(HttpMethods.GET);\n          exchange2.setURL(urls[0] + \"?action=result\");\n          exchange2.getRequestFields().add(\"Cookie\", sessionCookie);\n          client.send(exchange2);\n          exchange2.waitForDone();\n          assert exchange2.getResponseStatus() == HttpServletResponse.SC_OK;\n          String response = exchange2.getResponseContent();\n          System.out.println(\"get = \" + response);\n          assert response.trim().equals(String.valueOf(clientsCount * requestsCount));\n        } finally {\n          client.stop();\n        }\n      } finally {\n        server2.stop();\n      }\n    } finally {\n      server1.stop();\n    }\n  }\n"}, {"dataset": "nanoTime", "exampleID": 9300, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = system.nanoTime()", "focalAPIStart": 870, "focalAPIEnd": 887, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["system.nanoTime()"], "useStart": [1207], "useEnd": [1224], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java", "rawCode": "    /**\n     * Implements timed condition wait.\n     *\n     * <ol>\n     *   <li>If current thread is interrupted, throw InterruptedException.\n     *   <li>Save lock state returned by {@link #getState}.\n     *   <li>Invoke {@link #release} with saved state as argument, throwing\n     *       IllegalMonitorStateException if it fails.\n     *   <li>Block until signalled, interrupted, or timed out.\n     *   <li>Reacquire by invoking specialized version of {@link #acquire} with saved state as\n     *       argument.\n     *   <li>If interrupted while blocked in step 4, throw InterruptedException.\n     * </ol>\n     */\n    public final long awaitNanos(long nanosTimeout) throws InterruptedException {\n      if (Thread.interrupted()) throw new InterruptedException();\n      Node node = addConditionWaiter();\n      long savedState = fullyRelease(node);\n      long lastTime = System.nanoTime();\n      int interruptMode = 0;\n      while (!isOnSyncQueue(node)) {\n        if (nanosTimeout <= 0L) {\n          transferAfterCancelledWait(node);\n          break;\n        }\n        LockSupport.parkNanos(this, nanosTimeout);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break;\n\n        long now = System.nanoTime();\n        nanosTimeout -= now - lastTime;\n        lastTime = now;\n      }\n      if (acquireQueued(node, savedState) && interruptMode != THROW_IE) interruptMode = REINTERRUPT;\n      if (node.nextWaiter != null) unlinkCancelledWaiters();\n      if (interruptMode != 0) reportInterruptAfterWait(interruptMode);\n      return nanosTimeout - (System.nanoTime() - lastTime);\n    }\n"}]