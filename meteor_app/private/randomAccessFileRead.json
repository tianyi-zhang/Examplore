[{"dataset": "randomAccessFileRead", "exampleID": 6701, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [80], "configurationEnd": [121], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 127, "focalAPIEnd": 157, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/retornaz/contiki-cc253x/tree/master/tools/coffee-manager/se/sics/coffee/CoffeeImageFile.java", "rawCode": "  public void read(byte[] bytes, int size, int offset) throws IOException {\n    imageFile.seek(conf.startOffset + offset);\n    imageFile.read(bytes, 0, size);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6702, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 129, "tryExpressionEnd": 133, "tryBlockStart": 129, "tryBlockEnd": 1288, "catchExpressionStart": 1230, "catchExpressionEnd": 1253, "catchBlockStart": 1230, "catchBlockEnd": 1288, "exceptionHandlingCallStart": [1261], "exceptionHandlingCallEnd": [1281], "configuration": ["randomAccessFile.getFilePointer()"], "configurationStart": [179], "configurationEnd": [200], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 240, "focalAPIEnd": 260, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/uKev/knipsX/tree/master/src/main/java/org/knipsX/utils/exifAdapter/jexifviewer/JIfd.java", "rawCode": "  public boolean readIFDTag(RandomAccessFile file, boolean bIntel, long tiffOffset, int tagMask) {\n    boolean flag = false;\n    try {\n      m_bIsIntel = bIntel;\n      m_offset = file.getFilePointer();\n      byte[] buf = new byte[2];\n      file.read(buf, 0, 2);\n      m_count = JDataFormatHelper.buf2ToInt(buf, 0, bIntel);\n      m_tagArray = new ArrayList<JExifTag>();\n      int i;\n      for (i = 0; i < m_count; i++) {\n        JExifTag exifTag = new JExifTag(tagMask);\n        if (exifTag.read(file, bIntel, tiffOffset)) {\n          m_tagArray.add(exifTag);\n          // if (Main.m_settings.isDebug())\n          // {\n          // System.err.println(exifTag.getTag());\n          // boolean _flag = false;\n          // if (JExifTag.isTagUsedByGeneric(exifTag.getTag()))\n          // _flag = true;\n          // else\n          // {\n          // for (int _i=0; _i<JExifDataModel.m_colTag.length; _i++)\n          // {\n          // if (JExifDataModel.m_colTag[_i] == exifTag.getTag())\n          // {\n          // _flag = true;\n          // break;\n          // }\n          // }\n          // }\n          // if (!_flag)\n          // System.err.println(\"!!! UNKOWN TAG FOUND !!!\");\n          // }\n        }\n      }\n      flag = true;\n    } catch (IOException ex) {\n      ex.printStackTrace();\n    }\n    return flag;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6703, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 52, "focalAPIEnd": 63, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Euphemiasan/Project_FrameData/tree/master/lib/hsqldb-2.2.8/hsqldb/src/org/hsqldb/persist/ScaledRAFileSimple.java", "rawCode": "  public int read() throws IOException {\n    return file.read();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6704, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [130], "configurationEnd": [142], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 166, "focalAPIEnd": 217, "followUpCheck": "byteCount == len", "checkType": "IF", "followUpCheckExpressionStart": 225, "followUpCheckExpressionEnd": 273, "followUpCheckBlockStart": 225, "followUpCheckBlockEnd": 852, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/camporter/mha-server/tree/master/src/myhomeaudio/server/mp3/Mp3File.java", "rawCode": "  protected int preScanFile(RandomAccessFile file) {\n    byte[] bytes = new byte[AbstractID3v2Tag.HEADER_LENGTH];\n    try {\n      file.seek(0);\n      int bytesRead = file.read(bytes, 0, AbstractID3v2Tag.HEADER_LENGTH);\n      if (bytesRead == AbstractID3v2Tag.HEADER_LENGTH) {\n        try {\n          ID3v2TagFactory.sanityCheckTag(bytes);\n          return AbstractID3v2Tag.HEADER_LENGTH\n              + BufferTools.unpackSynchsafeInteger(\n                  bytes[AbstractID3v2Tag.DATA_LENGTH_OFFSET],\n                  bytes[AbstractID3v2Tag.DATA_LENGTH_OFFSET + 1],\n                  bytes[AbstractID3v2Tag.DATA_LENGTH_OFFSET + 2],\n                  bytes[AbstractID3v2Tag.DATA_LENGTH_OFFSET + 3]);\n        } catch (NoSuchTagException e) {\n          // do nothing\n        } catch (UnsupportedTagException e) {\n          // do nothing\n        }\n      }\n    } catch (IOException e) {\n      // do nothing\n    }\n    return 0;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6705, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [860], "configurationEnd": [884], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 954, "focalAPIEnd": 978, "followUpCheck": "byteCount != byteCount", "checkType": "IF", "followUpCheckExpressionStart": 987, "followUpCheckExpressionEnd": 1014, "followUpCheckBlockStart": 987, "followUpCheckBlockEnd": 1275, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/image/src/au/gov/naa/digipres/xena/plugin/image/tiff/TiffToXenaPngNormaliser.java", "rawCode": "  /**\n   * Return a default String representation of an EXIF tag\n   *\n   * @param byteArr byte array\n   * @param tiffRAF RandomAccessFile of the original TIFF file\n   * @param dataCount data size of the tag value\n   * @param useBigEndianOrdering\n   * @return\n   * @throws IOException\n   */\n  private String getDefaultEXIFStringValue(\n      byte[] byteArr,\n      RandomAccessFile tiffRAF,\n      int dataType,\n      long dataCount,\n      boolean useBigEndianOrdering)\n      throws IOException {\n    StringBuilder retValueBuilder = new StringBuilder();\n    byte[] valueBytes;\n\n    // If the data takes up more than 4 bytes, then the array of bytes passed in contains an offset\n    // to the actual data\n    long byteCount = getByteCount(dataType, dataCount);\n    if (byteCount > 4) {\n      long dataOffset = getLongFromBytes(byteArr, useBigEndianOrdering);\n      tiffRAF.seek(dataOffset);\n      valueBytes = new byte[(int) byteCount];\n      int bytesRead = tiffRAF.read(valueBytes);\n\n      if (bytesRead != byteCount) {\n        throw new IOException(\n            \"Data Type \"\n                + dataType\n                + \" has a data count of \"\n                + dataCount\n                + \" but only \"\n                + bytesRead\n                + \" bytes were read\");\n      }\n    } else {\n      valueBytes = byteArr;\n    }\n\n    switch (dataType) {\n      case TIFFField.TIFF_UNDEFINED:\n        retValueBuilder.append(new String(valueBytes));\n        break;\n      case TIFFField.TIFF_ASCII:\n        // ASCII values are null-terminated\n        retValueBuilder.append(new String(valueBytes, 0, valueBytes.length - 1));\n        break;\n      case TIFFField.TIFF_FLOAT: // Not used by EXIF... just return byte representation\n      case TIFFField.TIFF_DOUBLE: // Not used by EXIF... just return byte representation\n      case TIFFField.TIFF_BYTE:\n      case TIFFField.TIFF_SBYTE:\n        for (int byteIndex = 0; byteIndex < dataCount; byteIndex++) {\n          retValueBuilder.append(valueBytes[byteIndex]);\n          if (byteIndex < dataCount - 1) {\n            retValueBuilder.append(\", \");\n          }\n        }\n        break;\n      case TIFFField.TIFF_SHORT:\n      case TIFFField.TIFF_SSHORT:\n        for (int shortIndex = 0; shortIndex < dataCount; shortIndex++) {\n          int tiffShort = getIntFromBytes(valueBytes, shortIndex * 2, useBigEndianOrdering);\n          retValueBuilder.append(tiffShort);\n          if (shortIndex < dataCount - 1) {\n            retValueBuilder.append(\", \");\n          }\n        }\n        break;\n      case TIFFField.TIFF_LONG:\n      case TIFFField.TIFF_SLONG:\n        for (int longIndex = 0; longIndex < dataCount; longIndex++) {\n          long tiffLong = getLongFromBytes(valueBytes, longIndex * 4, useBigEndianOrdering);\n          retValueBuilder.append(tiffLong);\n          if (longIndex < dataCount - 1) {\n            retValueBuilder.append(\", \");\n          }\n        }\n        break;\n      case TIFFField.TIFF_RATIONAL:\n      case TIFFField.TIFF_SRATIONAL:\n        for (int rationalIndex = 0; rationalIndex < dataCount; rationalIndex++) {\n          long tiffRationalFirstComponent =\n              getLongFromBytes(valueBytes, rationalIndex * 8, useBigEndianOrdering);\n          long tiffRationalSecondComponent =\n              getLongFromBytes(valueBytes, rationalIndex * 8 + 4, useBigEndianOrdering);\n          // retValueBuilder.append(new Rational(tiffRationalFirstComponent,\n          // tiffRationalSecondComponent));\n          // if (rationalIndex < dataCount - 1) {\n          // retValueBuilder.append(\", \");\n          // }\n        }\n        break;\n      default:\n        retValueBuilder.append(new String(valueBytes));\n    }\n    return retValueBuilder.toString();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6706, "initialization": ["int len = min(*,*)"], "initializationStart": [568], "initializationEnd": [599], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [492], "configurationEnd": [508], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 625, "focalAPIEnd": 647, "followUpCheck": "byteCount < off", "checkType": "IF", "followUpCheckExpressionStart": 659, "followUpCheckExpressionEnd": 669, "followUpCheckBlockStart": 659, "followUpCheckBlockEnd": 802, "use": ["OutputStream.write(byte[],int,byteCount)"], "useStart": [813], "useEnd": [833], "hasFinally": 1, "cleanUpCall": ["OutputStream.close()"], "finallyExpressionStart": 894, "finallyExpressionEnd": 902, "finallyBlockStart": 894, "finallyBlockEnd": 932, "cleanUpCallStart": [912], "cleanUpCallEnd": [923], "url": "https://github.com/chalstrick/jgit/tree/master/org.eclipse.jgit.http.server/src/org/eclipse/jgit/http/server/FileSender.java", "rawCode": "  void serve(final HttpServletRequest req, final HttpServletResponse rsp, final boolean sendBody)\n      throws IOException {\n    if (!initRangeRequest(req, rsp)) {\n      rsp.sendError(SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n      return;\n    }\n\n    rsp.setHeader(HDR_ACCEPT_RANGES, \"bytes\");\n    rsp.setHeader(HDR_CONTENT_LENGTH, Long.toString(end - pos));\n\n    if (sendBody) {\n      final OutputStream out = rsp.getOutputStream();\n      try {\n        final byte[] buf = new byte[4096];\n        source.seek(pos);\n        while (pos < end) {\n          final int r = (int) Math.min(buf.length, end - pos);\n          final int n = source.read(buf, 0, r);\n          if (n < 0) {\n            throw new EOFException(\n                MessageFormat.format(HttpServerText.get().unexpectedeOFOn, path));\n          }\n          out.write(buf, 0, n);\n          pos += n;\n        }\n        out.flush();\n      } finally {\n        out.close();\n      }\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6707, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()", "setEOF(boolean)"], "tryExpressionStart": 92, "tryExpressionEnd": 96, "tryBlockStart": 92, "tryBlockEnd": 568, "catchExpressionStart": 424, "catchExpressionEnd": 446, "catchBlockStart": 424, "catchBlockEnd": 568, "exceptionHandlingCallStart": [499, 528], "exceptionHandlingCallEnd": [518, 540], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "randomAccessFile!=null && b[off]!=FileEndOfLine.LF", "guardType": "IF {", "guardExpressionStart": 66, "guardExpressionEnd": 83, "guardBlockStart": 66, "guardBlockEnd": 574, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 220, "focalAPIEnd": 245, "followUpCheck": "byteCount != -len", "checkType": "IF", "followUpCheckExpressionStart": 257, "followUpCheckExpressionEnd": 279, "followUpCheckBlockStart": 257, "followUpCheckBlockEnd": 383, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/charleso/naca/tree/master/JLib/src/jlib/misc/DataFileReadWrite.java", "rawCode": "  private int readUnixLine(byte tBytes[], int nMaxLineSize) {\n    if (m_rw != null) {\n      try {\n        int n = 0;\n        m_t1Byte[0] = 0;\n        while (m_t1Byte[0] != FileEndOfLine.LF) {\n          int nNBytesRead = m_rw.read(m_t1Byte, 0, 1);\n          if (nNBytesRead != -1) tBytes[n++] = m_t1Byte[0];\n          else {\n            setEOF(true);\n            return n;\n          }\n        }\n        return n - 1;\n      } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        setEOF(true);\n        return -1;\n      }\n    }\n    return 0;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6708, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getFilePointer()"], "configurationStart": [695], "configurationEnd": [715], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 785, "focalAPIEnd": 795, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["readRAF(randomAccessFile,long,int)"], "useStart": [988], "useEnd": [1014], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crosswire/jsword/tree/master/src/main/java/org/crosswire/jsword/book/sword/SwordUtil.java", "rawCode": "  /**\n   * Read a RandomAccessFile until a particular byte is seen\n   *\n   * @param raf The file to read\n   * @param stopByte The point at which to stop reading\n   * @return the read data\n   * @throws IOException on error\n   */\n  protected static byte[] readUntilRAF(RandomAccessFile raf, byte stopByte) throws IOException {\n    // The strategy used here is to read the file twice.\n    // Once to determine how much to read and then getting the actual data.\n    // It may be more efficient to incrementally build up a byte buffer.\n    // Note: that growing a static array by 1 byte at a time is O(n**2)\n    // This is negligible when the n is small, but prohibitive otherwise.\n    long offset = raf.getFilePointer();\n    int size = 0;\n\n    int nextByte = -1;\n    do {\n      nextByte = raf.read();\n\n      size++;\n    } while (nextByte != -1 && nextByte != stopByte);\n\n    // Note: we allow for nextByte == -1 to be included in size\n    // so that readRAF will report EOF errors\n    return readRAF(raf, offset, size);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6709, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 480, "focalAPIEnd": 499, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fluffy88/OCJD/tree/master/code/suncertify/db/io/DBParser.java", "rawCode": "  /**\n   * Simple implementation of a RandomAccessFile#readString() as it's not included by default.\n   *\n   * @param n The number of bytes to be read for the String.\n   * @return The trimmed result of reading n bytes from the RandomAccessFile and converting to a\n   *     String.\n   * @throws IOException If something goes wrong when reading from the RandomAccessFile.\n   */\n  private String readString(final int n) throws IOException {\n    final byte[] bytes = new byte[n];\n    this.is.read(bytes);\n    return new String(bytes, US_ASCII).trim();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6710, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [396], "initializationEnd": [424], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [433], "configurationEnd": [468], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 476, "focalAPIEnd": 490, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [498], "useEnd": [508], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ntietz/virtualdisk/tree/master/src/com/virtualdisk/datanode/Drive.java", "rawCode": "  /**\n   * Reads a block in from the disk at the supplied physical offset.\n   *\n   * @param physicalOffset the physical offset we wish to read from\n   * @return the block at the given location, or null if there is any disk-read error\n   */\n  public byte[] read(long physicalOffset) {\n    byte[] block = new byte[blockSize];\n\n    try {\n      File f = new File(handle);\n      RandomAccessFile in = new RandomAccessFile(f, \"r\");\n\n      in.seek(physicalOffset * blockSize);\n      in.read(block);\n      in.close();\n    } catch (Exception e) {\n      // e.printStackTrace();\n      return null;\n    }\n\n    return block;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6711, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [411], "initializationEnd": [474], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 99, "tryExpressionEnd": 103, "tryBlockStart": 99, "tryBlockEnd": 741, "catchExpressionStart": 660, "catchExpressionEnd": 680, "catchBlockStart": 660, "catchBlockEnd": 741, "exceptionHandlingCallStart": [688], "exceptionHandlingCallEnd": [707], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 543, "focalAPIEnd": 568, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ConatyConsulting/jaudiotagger/tree/master/srctest/org/jaudiotagger/tag/mp4/M4aWriteTagTest.java", "rawCode": "  public void testWriteMuchLargerWhenFreeIsAfterMdat() {\n    Exception exceptionCaught = null;\n    try {\n      File orig = new File(\"testdata\", \"unable_to_write.m4p\");\n      if (!orig.isFile()) {\n        return;\n      }\n      File testFile = AbstractTestCase.copyAudioToTmp(\"unable_to_write.m4p\");\n\n      AudioFile f = AudioFileIO.read(testFile);\n      Tag tag = f.getTag();\n\n      RandomAccessFile imageFile = new RandomAccessFile(new File(\"testdata\", \"coverart.png\"), \"r\");\n      byte[] imagedata = new byte[(int) imageFile.length()];\n      imageFile.read(imagedata);\n      tag.addField(((Mp4Tag) tag).createArtworkField(imagedata));\n      f.commit();\n    } catch (Exception e) {\n      e.printStackTrace();\n      exceptionCaught = e;\n    }\n    assertNull(exceptionCaught);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6712, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 52, "focalAPIEnd": 67, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BertrandDechoux/Heritrix-3/tree/master/commons/src/main/java/org/archive/io/RandomAccessInputStream.java", "rawCode": "  public int read() throws IOException {\n    return this.raf.read();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6713, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["w(String,String,*)"], "tryExpressionStart": 98, "tryExpressionEnd": 102, "tryBlockStart": 98, "tryBlockEnd": 453, "catchExpressionStart": 150, "catchExpressionEnd": 172, "catchBlockStart": 150, "catchBlockEnd": 265, "exceptionHandlingCallStart": [180], "exceptionHandlingCallEnd": [241], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 110, "focalAPIEnd": 123, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()", "randomAccessFile.close()"], "useStart": [131, 325], "useEnd": [142, 336], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 266, "finallyExpressionEnd": 274, "finallyBlockStart": 266, "finallyBlockEnd": 453, "cleanUpCallStart": [131], "cleanUpCallEnd": [142], "url": "https://github.com/embest-tech/rowboat-frameworks-base/tree/master/core/java/android/os/NetStat.java", "rawCode": "  private static synchronized long getNumberFromFile(RandomAccessFile raf, String filename) {\n    try {\n      raf.read(buf);\n      raf.close();\n    } catch (IOException e) {\n      Log.w(TAG, \"Exception getting TCP bytes from \" + filename, e);\n      return 0L;\n    } finally {\n      if (raf != null) {\n        try {\n          raf.close();\n        } catch (IOException e) {\n          Log.w(TAG, \"Exception closing \" + filename, e);\n        }\n      }\n    }\n\n    long num = 0L;\n    for (int i = 0; i < buf.length; i++) {\n      if (buf[i] < '0' || buf[i] > '9') {\n        break;\n      }\n      num *= 10;\n      num += buf[i] - '0';\n    }\n    return num;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6714, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getBytes()"], "tryExpressionStart": 319, "tryExpressionEnd": 323, "tryBlockStart": 319, "tryBlockEnd": 994, "catchExpressionStart": 937, "catchExpressionEnd": 959, "catchBlockStart": 937, "catchBlockEnd": 994, "exceptionHandlingCallStart": [974], "exceptionHandlingCallEnd": [987], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [803], "configurationEnd": [828], "guardCondition": "!(randomAccessFile==null||true)", "guardType": "IF {", "guardExpressionStart": 130, "guardExpressionEnd": 159, "guardBlockStart": 130, "guardBlockEnd": 213, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 881, "focalAPIEnd": 908, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alevy/comet/tree/master/vuze/org/gudy/azureus2/core3/ipfilter/impl/IpFilterManagerImpl.java", "rawCode": "  public byte[] getDescription(Object info) {\n    // if cached, info is an object array, with the first index being the descr\n    if (info instanceof Object[]) {\n      return (byte[]) (((Object[]) info)[0]);\n    }\n\n    if (rafDescriptions == null || !(info instanceof Integer)) {\n      return \"\".getBytes();\n    }\n\n    try {\n      int posInfo = ((Integer) info).intValue();\n      int pos = posInfo & 0x1FFFFFF;\n      int len = posInfo >> 25;\n\n      if (len < 0) {\n        throw new IllegalArgumentException(\n            getClass().getName()\n                + \": invalid posInfo [\"\n                + posInfo\n                + \"], pos [\"\n                + pos\n                + \"], len [\"\n                + len\n                + \"]\");\n      }\n\n      if (rafDescriptions.getFilePointer() != pos) {\n        rafDescriptions.seek(pos);\n      }\n\n      byte[] bytes = new byte[len];\n      rafDescriptions.read(bytes);\n\n      return bytes;\n    } catch (IOException e) {\n      return \"\".getBytes();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6715, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [168], "configurationEnd": [179], "guardCondition": "!(randomAccessFile.length()==0)", "guardType": "IF {", "guardExpressionStart": 89, "guardExpressionEnd": 111, "guardBlockStart": 89, "guardBlockEnd": 163, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 240, "focalAPIEnd": 251, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.read(byte[])", "handleVorbisComment(MetadataBlockHeader,randomAccessFile)", "randomAccessFile.getFilePointer()", "randomAccessFile.seek(long)"], "useStart": [550, 778, 1001, 992], "useEnd": [561, 807, 1021, 1044], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeyboy/MUSIC/tree/master/lib/outag/outag/audioformats/flac/util/FlacTagReader.java", "rawCode": "  public OggTag read(RandomAccessFile raf) throws CannotReadException, IOException {\n    if (raf.length() == 0) throw new CannotReadException(\"Error: File empty\");\n    raf.seek(0);\n\n    // FLAC Header string\n    byte[] b = new byte[4];\n    raf.read(b);\n    String flac = new String(b);\n    if (!flac.equals(\"fLaC\"))\n      throw new CannotReadException(\"fLaC Header not found, not a flac file\");\n\n    OggTag tag = null;\n\n    // Seems like we hava a valid stream\n    boolean isLastBlock = false;\n    while (!isLastBlock) {\n      b = new byte[4];\n      raf.read(b);\n      MetadataBlockHeader mbh = new MetadataBlockHeader(b);\n\n      switch (mbh.getBlockType()) {\n          // We got a vorbis comment block, parse it\n        case MetadataBlockHeader.VORBIS_COMMENT:\n          tag = handleVorbisComment(mbh, raf);\n          mbh = null;\n          return tag; // We have it, so no need to go further\n\n          // This is not a vorbis comment block, we skip to next block\n        default:\n          raf.seek(raf.getFilePointer() + mbh.getDataLength());\n          break;\n      }\n\n      isLastBlock = mbh.isLastBlock();\n      mbh = null;\n    }\n    // FLAC not found...\n    throw new CannotReadException(\"FLAC Tag could not be found or read..\");\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6716, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 76, "tryExpressionEnd": 80, "tryBlockStart": 76, "tryBlockEnd": 376, "catchExpressionStart": 320, "catchExpressionEnd": 342, "catchBlockStart": 320, "catchBlockEnd": 376, "exceptionHandlingCallStart": [350], "exceptionHandlingCallEnd": [369], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 156, "focalAPIEnd": 207, "followUpCheck": "byteCount < mbuf.len - i", "checkType": "IF", "followUpCheckExpressionStart": 217, "followUpCheckExpressionEnd": 238, "followUpCheckBlockStart": 217, "followUpCheckBlockEnd": 305, "use": ["randomAccessFile.seek(int)"], "useStart": [251], "useEnd": [266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_3_2_4/appia/src/org/continuent/appia/test/perf/PerfSession.java", "rawCode": "  private void writePayload(MsgBuffer mbuf, RandomAccessFile payload) {\n    try {\n      int i, r = 0;\n      for (i = 0; i < mbuf.len; i += r) {\n        r = payload.read(mbuf.data, mbuf.off + i, mbuf.len - i);\n        if (r < mbuf.len - i) {\n          payload.seek(0);\n          if (r < 0) r = 0;\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6717, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 76, "tryExpressionEnd": 80, "tryBlockStart": 76, "tryBlockEnd": 376, "catchExpressionStart": 320, "catchExpressionEnd": 342, "catchBlockStart": 320, "catchBlockEnd": 376, "exceptionHandlingCallStart": [350], "exceptionHandlingCallEnd": [369], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 156, "focalAPIEnd": 207, "followUpCheck": "byteCount < mbuf.len - i", "checkType": "IF", "followUpCheckExpressionStart": 217, "followUpCheckExpressionEnd": 238, "followUpCheckBlockStart": 217, "followUpCheckBlockEnd": 305, "use": ["randomAccessFile.seek(int)"], "useStart": [251], "useEnd": [266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_3_1_1/appia/src/org/continuent/appia/test/perf/PerfSession.java", "rawCode": "  private void writePayload(MsgBuffer mbuf, RandomAccessFile payload) {\n    try {\n      int i, r = 0;\n      for (i = 0; i < mbuf.len; i += r) {\n        r = payload.read(mbuf.data, mbuf.off + i, mbuf.len - i);\n        if (r < mbuf.len - i) {\n          payload.seek(0);\n          if (r < 0) r = 0;\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6718, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 88, "focalAPIEnd": 100, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["calculateDataSize(byteCount)", "randomAccessFile.readFully(byte[],int,int)"], "useStart": [121, 275], "useEnd": [160, 316], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/geotools/geotools/tree/master/modules/unsupported/vpf/src/main/java/org/geotools/data/vpf/io/VPFInputStream.java", "rawCode": "  protected TripletId readTripletId() throws IOException {\n    byte tripletDef = (byte) input.read();\n    int dataSize = TripletId.calculateDataSize(tripletDef);\n    byte[] tripletData = new byte[dataSize + 1];\n    tripletData[0] = tripletDef;\n\n    if (dataSize > 0) {\n      input.readFully(tripletData, 1, dataSize);\n    }\n\n    return new TripletId(tripletData);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6719, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 579, "focalAPIEnd": 612, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stephenc/java-iso-tools/tree/master/sabre/src/main/java/com/github/stephenc/javaisotools/udflib/structures/PartitionHeaderDescriptor.java", "rawCode": "  public void read(RandomAccessFile myRandomAccessFile) throws IOException {\n    UnallocatedSpaceTable = new Short_ad();\n    UnallocatedSpaceTable.read(myRandomAccessFile);\n\n    UnallocatedSpaceBitmap = new Short_ad();\n    UnallocatedSpaceBitmap.read(myRandomAccessFile);\n\n    PartitionIntegrityTable = new Short_ad();\n    PartitionIntegrityTable.read(myRandomAccessFile);\n\n    FreedSpaceTable = new Short_ad();\n    FreedSpaceTable.read(myRandomAccessFile);\n\n    FreedSpaceBitmap = new Short_ad();\n    FreedSpaceBitmap.read(myRandomAccessFile);\n\n    Reserved = new byte[88];\n    myRandomAccessFile.read(Reserved);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6720, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [124], "configurationEnd": [154], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 266, "focalAPIEnd": 294, "followUpCheck": "byteCount != size", "checkType": "IF", "followUpCheckExpressionStart": 300, "followUpCheckExpressionEnd": 321, "followUpCheckBlockStart": 300, "followUpCheckBlockEnd": 616, "use": ["randomAccessFile.length()", "randomAccessFile.seek(long)"], "useStart": [706, 683], "useEnd": [732, 733], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/quickfixj/mirror/tree/master/core/src/main/java/quickfix/FileStore.java", "rawCode": "  private String getMessage(long[] offsetAndSize, int i) throws IOException {\n    final long offset = offsetAndSize[0];\n    messageFileReader.seek(offset);\n    final int size = (int) offsetAndSize[1];\n    final byte[] data = new byte[size];\n    final int sizeRead = messageFileReader.read(data);\n    if (sizeRead != size) {\n      throw new IOException(\n          \"Truncated input while reading message: messageIndex=\"\n              + i\n              + \", offset=\"\n              + offset\n              + \", expected size=\"\n              + size\n              + \", size read from file=\"\n              + sizeRead);\n    }\n    final String message = new String(data, charsetEncoding);\n    messageFileReader.seek(messageFileReader.length());\n    return message;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6721, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 110, "focalAPIEnd": 124, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Mega-Mario/Whitehole/tree/master/src/whitehole/fileio/ExternalFile.java", "rawCode": "  @Override\n  public byte[] readBytes(int length) throws IOException {\n    byte[] ret = new byte[length];\n    file.read(ret);\n    return ret;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6722, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [243], "initializationEnd": [282], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 347, "focalAPIEnd": 368, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/astanway/cannon-torrent/tree/master/utils/Helpers.java", "rawCode": "  /**\n   * Changes the torrentfile into a bytearray\n   *\n   * @param torrentFile the file to be read\n   * @return byte array from the file\n   */\n  public static byte[] readTorrent(String torrentFile) {\n    try {\n      RandomAccessFile rFile = new RandomAccessFile(torrentFile, \"rw\");\n      byte[] fileBytes = new byte[(int) rFile.length()];\n      rFile.read(fileBytes);\n      return fileBytes;\n    } catch (IOException e) {\n      // e.printStackTrace();\n      return null;\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6723, "initialization": ["int len = min(*,*)"], "initializationStart": [568], "initializationEnd": [599], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [492], "configurationEnd": [508], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 625, "focalAPIEnd": 647, "followUpCheck": "byteCount < off", "checkType": "IF", "followUpCheckExpressionStart": 659, "followUpCheckExpressionEnd": 669, "followUpCheckBlockStart": 659, "followUpCheckBlockEnd": 802, "use": ["OutputStream.write(byte[],int,byteCount)"], "useStart": [813], "useEnd": [833], "hasFinally": 1, "cleanUpCall": ["OutputStream.close()"], "finallyExpressionStart": 894, "finallyExpressionEnd": 902, "finallyBlockStart": 894, "finallyBlockEnd": 932, "cleanUpCallStart": [912], "cleanUpCallEnd": [923], "url": "https://github.com/jdcasey/JGit/tree/master/org.eclipse.jgit.http.server/src/org/eclipse/jgit/http/server/FileSender.java", "rawCode": "  void serve(final HttpServletRequest req, final HttpServletResponse rsp, final boolean sendBody)\n      throws IOException {\n    if (!initRangeRequest(req, rsp)) {\n      rsp.sendError(SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n      return;\n    }\n\n    rsp.setHeader(HDR_ACCEPT_RANGES, \"bytes\");\n    rsp.setHeader(HDR_CONTENT_LENGTH, Long.toString(end - pos));\n\n    if (sendBody) {\n      final OutputStream out = rsp.getOutputStream();\n      try {\n        final byte[] buf = new byte[4096];\n        source.seek(pos);\n        while (pos < end) {\n          final int r = (int) Math.min(buf.length, end - pos);\n          final int n = source.read(buf, 0, r);\n          if (n < 0) {\n            throw new EOFException(\n                MessageFormat.format(HttpServerText.get().unexpectedeOFOn, path));\n          }\n          out.write(buf, 0, n);\n          pos += n;\n        }\n        out.flush();\n      } finally {\n        out.close();\n      }\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6724, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(len<scanLineSize*biHeight)", "guardType": "IF {", "guardExpressionStart": 258, "guardExpressionEnd": 293, "guardBlockStart": 258, "guardBlockEnd": 331, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 415, "focalAPIEnd": 443, "followUpCheck": "byteCount < b.length", "checkType": "IF", "followUpCheckExpressionStart": 449, "followUpCheckExpressionEnd": 472, "followUpCheckBlockStart": 449, "followUpCheckBlockEnd": 542, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fiji/imagej1/tree/master/ij/plugin/AVI_Reader.java", "rawCode": "  /**\n   * Read a fixed-length frame (RandomAccessFile rFile, long filePos, int size) return the pixels\n   * array of the resulting image\n   */\n  private Object readFixedLengthFrame(RandomAccessFile rFile, int size)\n      throws Exception, IOException {\n    if (size < scanLineSize * biHeight)\n      size = scanLineSize * biHeight; // bugfix for RGB odd-width files\n    byte[] rawData = new byte[size];\n    int n = rFile.read(rawData, 0, size);\n    if (n < rawData.length) throw new Exception(\"Frame ended prematurely after \" + n + \" bytes\");\n\n    boolean topDown = flipVertical ? !dataTopDown : dataTopDown;\n    Object pixels = null;\n    byte[] bPixels = null;\n    int[] cPixels = null;\n    short[] sPixels = null;\n    if (biBitCount <= 8 || convertToGray) {\n      bPixels = new byte[dwWidth * biHeight];\n      pixels = bPixels;\n    } else if (biBitCount == 16 && dataCompression == NO_COMPRESSION) {\n      sPixels = new short[dwWidth * biHeight];\n      pixels = sPixels;\n    } else {\n      cPixels = new int[dwWidth * biHeight];\n      pixels = cPixels;\n    }\n    if (isPlanarFormat && !convertToGray) unpackPlanarImage(rawData, cPixels, topDown);\n    else {\n      int offset = topDown ? 0 : (biHeight - 1) * dwWidth;\n      int rawOffset = 0;\n      for (int i = biHeight - 1; i >= 0; i--) { // for all lines\n        if (biBitCount <= 8 || isPlanarFormat)\n          unpack8bit(rawData, rawOffset, bPixels, offset, dwWidth);\n        else if (convertToGray) unpackGray(rawData, rawOffset, bPixels, offset, dwWidth);\n        else if (biBitCount == 16 && dataCompression == NO_COMPRESSION)\n          unpackShort(rawData, rawOffset, sPixels, offset, dwWidth);\n        else unpack(rawData, rawOffset, cPixels, offset, dwWidth);\n        rawOffset += isPlanarFormat ? dwWidth : scanLineSize;\n        offset += topDown ? dwWidth : -dwWidth;\n      }\n    }\n    return pixels;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6725, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getFilePointer()"], "configurationStart": [208], "configurationEnd": [228], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 291, "focalAPIEnd": 314, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(long)"], "useStart": [320], "useEnd": [335], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craigpetchell/Jaudiotagger/tree/master/src/org/jaudiotagger/tag/id3/AbstractID3v2Tag.java", "rawCode": "  /**\n   * True if files has a ID3v2 header\n   *\n   * @param raf\n   * @return\n   * @throws IOException\n   */\n  private static boolean isID3V2Header(RandomAccessFile raf) throws IOException {\n    long start = raf.getFilePointer();\n    byte[] tagIdentifier = new byte[FIELD_TAGID_LENGTH];\n    raf.read(tagIdentifier);\n    raf.seek(start);\n    if (!(Arrays.equals(tagIdentifier, TAG_ID))) {\n      return false;\n    }\n    return true;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6726, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 56, "focalAPIEnd": 66, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/soartech/soar/tree/master/Domains/RoomsWorld/april/java/src/april/util/EndianDataInputStream.java", "rawCode": "    public int read() throws IOException {\n      return raf.read();\n    }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6727, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [185], "configurationEnd": [201], "guardCondition": "randomAccessFile.len()>offset", "guardType": "IF {", "guardExpressionStart": 145, "guardExpressionEnd": 171, "guardBlockStart": 145, "guardBlockEnd": 261, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 222, "focalAPIEnd": 249, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alevy/comet/tree/master/vuze/com/aelitis/azureus/core/download/DiskManagerFileInfoStream.java", "rawCode": "    protected int read(byte[] buffer, long offset, int length) throws IOException {\n\n      AESemaphore sem;\n\n      synchronized (lock) {\n        if (raf.length() > offset) {\n\n          raf.seek(offset);\n\n          return (raf.read(buffer, 0, length));\n        }\n\n        if (stream_details == null) {\n\n          if (stream_got_eof) {\n\n            return (-1);\n          }\n\n          throw (new IOException(\"Premature end of stream (read)\"));\n        }\n\n        sem = new AESemaphore(\"DMS:block\");\n\n        waiters.add(sem);\n      }\n\n      try {\n        sem.reserve(1000);\n\n      } finally {\n\n        synchronized (lock) {\n          waiters.remove(sem);\n        }\n      }\n\n      return (0);\n    }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6728, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getFilePointer()", "randomAccessFile.readByte()", "randomAccessFile.seek(long)"], "configurationStart": [231, 264, 372], "configurationEnd": [252, 279, 394], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 506, "focalAPIEnd": 529, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getFilePointer()", "randomAccessFile.seek(long)", "randomAccessFile.getFilePointer()", "randomAccessFile.skipBytes(int)", "randomAccessFile.read(byte[],int,int)", "randomAccessFile.seek(long)", "readBody(String,randomAccessFile)"], "useStart": [699, 689, 835, 891, 942, 1661, 1702], "useEnd": [720, 725, 856, 908, 965, 1683, 1728], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lboynton/XMPP-Client/tree/master/lib/mp3tag/src/org/farng/mp3/id3/ID3v2_4Frame.java", "rawCode": "  public void read(final RandomAccessFile file) throws IOException, InvalidTagException {\n    long filePointer;\n    final byte[] buffer = new byte[4];\n    byte b;\n\n    // lets scan for a non-zero byte;\n    do {\n      filePointer = file.getFilePointer();\n      b = file.readByte();\n      org.farng.mp3.id3.AbstractID3v2.incrementPaddingCounter();\n    } while (b == 0);\n    file.seek(filePointer);\n    org.farng.mp3.id3.AbstractID3v2.decrementPaddingCounter();\n\n    // read the four character identifier\n    file.read(buffer, 0, 4);\n    final String identifier = new String(buffer, 0, 4);\n\n    // is this a valid identifier?\n    if (isValidID3v2FrameIdentifier(identifier) == false) {\n      file.seek(file.getFilePointer() - 3);\n      throw new InvalidTagException(identifier + \" is not a valid ID3v2.40 frame\");\n    }\n    filePointer = file.getFilePointer();\n\n    // skip the 4 byte size\n    file.skipBytes(4);\n\n    // read the flag bytes\n    file.read(buffer, 0, 2);\n    this.tagAlterPreservation = (buffer[0] & TagConstant.MASK_V24_TAG_ALTER_PRESERVATION) != 0;\n    this.fileAlterPreservation = (buffer[0] & TagConstant.MASK_V24_FILE_ALTER_PRESERVATION) != 0;\n    this.readOnly = (buffer[0] & TagConstant.MASK_V24_READ_ONLY) != 0;\n    this.groupingIdentity = (buffer[1] & TagConstant.MASK_V24_GROUPING_IDENTITY) != 0;\n    this.compression = (buffer[1] & TagConstant.MASK_V24_COMPRESSION) != 0;\n    this.encryption = (buffer[1] & TagConstant.MASK_V24_ENCRYPTION) != 0;\n    this.unsynchronization = (buffer[1] & TagConstant.MASK_V24_FRAME_UNSYNCHRONIZATION) != 0;\n    this.dataLengthIndicator = (buffer[1] & TagConstant.MASK_V24_DATA_LENGTH_INDICATOR) != 0;\n    file.seek(filePointer);\n    this.setBody(readBody(identifier, file));\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6729, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 86, "focalAPIEnd": 96, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.read()"], "useStart": [192], "useEnd": [202], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/main/java/ucar/nc2/stream/NcStreamIosp.java", "rawCode": "  private int readVInt(RandomAccessFile raf) throws IOException {\n    byte b = (byte) raf.read();\n    int i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = (byte) raf.read();\n      i |= (b & 0x7F) << shift;\n    }\n    return i;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6730, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 216, "focalAPIEnd": 234, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdeolive/geotools-old/tree/master/modules/unsupported/vpf/src/main/java/org/geotools/data/vpf/file/VPFFile.java", "rawCode": "  /**\n   * Reads a single byte as a character value\n   *\n   * @return a <code>char</code> value\n   * @exception IOException if an error occurs\n   */\n  protected char readChar() throws IOException {\n    return (char) inputStream.read();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6731, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,*,int)"], "initializationStart": [1876], "initializationEnd": [1941], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 896, "tryExpressionEnd": 900, "tryBlockStart": 896, "tryBlockEnd": 3660, "catchExpressionStart": 3606, "catchExpressionEnd": 3626, "catchBlockStart": 3606, "catchBlockEnd": 3660, "exceptionHandlingCallStart": [3634], "exceptionHandlingCallEnd": [3653], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [2277], "configurationEnd": [2295], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 2305, "focalAPIEnd": 2323, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(int)", "randomAccessFile.read(byte[])", "randomAccessFile.close()"], "useStart": [3134, 3162, 3583], "useEnd": [3152, 3180, 3597], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/systemsgenetics/tree/master/genetica-libraries/src/main/java/umcg/genetica/io/bin/RandomAccessFile.java", "rawCode": "  /**\n   * Test the block operations of the RandomAccessFile class. These are the methods that read/write\n   * blocks of data. The following checks are made:\n   *\n   * <ul>\n   *   <li>Writing blocks of data that are smaller than the buffer size.\n   *   <li>Writing blocks of data that are larger than the buffer size.\n   *   <li>Checking the size of the file is correct.\n   *   <li>Reading small blocks of the file back in and verifying its contents.\n   *   <li>Reading large blocks of the file back in and verifying its contents.\n   * </ul>\n   *\n   * @param filename the name of the test file to generate.\n   */\n  public static void testBlocks(String filename) {\n\n    System.err.println(\"\\nTesting block operations...\");\n\n    // Generate the data.\n    int bufferSize = 10;\n    byte data[] = new byte[256];\n    for (int i = 0; i < data.length; i++) {\n      data[i] = (byte) (i % 256);\n    }\n\n    try {\n\n      // Write the data in small and large blocks.\n      RandomAccessFile outFile =\n          new RandomAccessFile(\n              filename, RandomAccessFile.WRITE | RandomAccessFile.CREATE, bufferSize);\n      for (int i = 0; i < data.length; ) {\n        int blockSize = (i < data.length / 2) ? 3 : 13;\n        blockSize = (i + blockSize >= data.length) ? (data.length - i) : blockSize;\n        outFile.write(data, i, blockSize);\n        i += blockSize;\n      }\n\n      outFile.close();\n\n      // Check that the file length is correct.\n      if ((new File(filename)).length() != data.length) {\n        System.out.println(\n            \"X New file size incorrect (should be \"\n                + data.length\n                + \", but is \"\n                + (new File(filename)).length()\n                + \").\");\n      } else {\n        System.out.println(\". File size correct (\" + data.length + \").\");\n      }\n\n      // Reopen the file for reading.\n      RandomAccessFile inFile = new RandomAccessFile(filename, RandomAccessFile.READ, bufferSize);\n\n      // Read and check random small blocks of data.\n      boolean verified = true;\n      int firstFailure = 256;\n      Random random = new Random(0);\n      byte block[] = new byte[(int) (bufferSize * 0.5)];\n      for (int i = 0; i < 100; i++) {\n        int index = Math.abs(random.nextInt()) % (data.length - block.length);\n        inFile.seek(index);\n        inFile.read(block);\n\n        // Verify the block of data.\n        for (int j = 0; j < block.length; j++) {\n          if (block[j] != data[index + j]) {\n            verified = false;\n            if (index + j < firstFailure) {\n              firstFailure = index + j;\n            }\n          }\n        }\n      }\n      if (verified) {\n        System.err.println(\". Reading small blocks verified.\");\n      } else {\n        System.err.println(\"X Reading small blocks failed (byte \" + firstFailure + \").\");\n      }\n\n      // Read and check random large (bigger than the bufferSize) blocks\n      // of data.\n      verified = true;\n      random = new Random(0);\n      block = new byte[(int) (bufferSize * 1.5)];\n      for (int i = 0; i < 100; i++) {\n        int index = Math.abs(random.nextInt()) % (data.length - block.length);\n        inFile.seek(index);\n        inFile.read(block);\n\n        // Verify the block of data.\n        for (int j = 0; j < block.length; j++) {\n          if (block[j] != data[j + index]) {\n            verified = false;\n          }\n        }\n      }\n      if (verified) {\n        System.err.println(\". Reading large blocks verified.\");\n      } else {\n        System.err.println(\"X Reading large blocks failed.\");\n      }\n\n      // Close the input file.\n      inFile.close();\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6732, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [618], "initializationEnd": [652], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [1286], "configurationEnd": [1299], "guardCondition": "!(randomAccessFile==null)", "guardType": "IF {", "guardExpressionStart": 983, "guardExpressionEnd": 998, "guardBlockStart": 983, "guardBlockEnd": 1091, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 1309, "focalAPIEnd": 1321, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1406], "useEnd": [1416], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JohannesBuchner/Jarsync/tree/master/jarsync/src/main/java/org/metastatic/rsync/Rebuilder.java", "rawCode": "  /**\n   * Reconstruct a file into <code>newFile</code>.\n   *\n   * @param oldFile The original file.\n   * @param newFile The file to write the reconstruction to. This must be a different file than\n   *     <code>oldFile</code>\n   * @param deltas The {@link Delta}s to apply.\n   */\n  public static void rebuildFile(File oldFile, File newFile, List<Delta> deltas)\n      throws IOException {\n    if (oldFile.equals(newFile)) {\n      throw new IOException(\"cannot read and write to the same file\");\n    }\n    RandomAccessFile out = new RandomAccessFile(newFile, \"rw\");\n    RandomAccessFile in = null;\n    try {\n      in = new RandomAccessFile(oldFile, \"r\");\n    } catch (IOException ignore) {\n    }\n\n    for (Iterator i = deltas.iterator(); i.hasNext(); ) {\n      Object o = i.next();\n      if (o instanceof DataBlock) {\n        long off = ((DataBlock) o).getOffset();\n        out.seek(off);\n        out.write(((DataBlock) o).getData());\n      } else if (o instanceof Offsets) {\n        if (in == null) {\n          throw new IOException(\"original file does not exist or not readable\");\n        }\n        int len = ((Offsets) o).getBlockLength();\n        long off1 = ((Offsets) o).getOldOffset();\n        long off2 = ((Offsets) o).getNewOffset();\n        byte[] buf = new byte[len];\n        in.seek(off1);\n        in.read(buf);\n        out.seek(off2);\n        out.write(buf);\n      }\n    }\n\n    if (in != null) in.close();\n    out.close();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6733, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [140], "initializationEnd": [184], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 301, "focalAPIEnd": 321, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.readInt()", "randomAccessFile.read(byte[])", "randomAccessFile.close()"], "useStart": [476, 624, 906], "useEnd": [489, 643, 917], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mgarber/scriptureV2/tree/master/src/java/broad/core/sequence/FastaQualityBinaryIO.java", "rawCode": "  public void createAsciiFromBinary(String binaryQualityFile, int numQualBasesPerRow)\n      throws IOException {\n    RandomAccessFile raf = new RandomAccessFile(binaryQualityFile, \"r\");\n    byte[] seqIdBytes = new byte[SEQ_ID_REC_LENGTH];\n    System.out.println(\"offset \" + raf.getFilePointer());\n    raf.read(seqIdBytes);\n    System.out.println(\"offset after reading seq name \" + raf.getFilePointer());\n    String seqId = new String(seqIdBytes).trim();\n    int seqIdLength = raf.readInt();\n    System.out.println(\"offset after reading seq length \" + raf.getFilePointer());\n    byte[] firstQual = new byte[seqIdLength];\n    raf.read(firstQual);\n\n    System.out.println(\"got seq id \" + seqId + \" of length \" + seqIdLength);\n    for (int i = 0; i < firstQual.length; i++) {\n      if (i > 0 && i % 26 == 0) {\n        System.out.print(\"\\n\");\n      }\n      System.out.print((int) firstQual[i] + \" \");\n    }\n    raf.close();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6734, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)", "int len = min(*,*)"], "initializationStart": [1691, 2937], "initializationEnd": [1739, 2999], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [2717], "configurationEnd": [2770], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 3015, "focalAPIEnd": 3077, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [3409], "useEnd": [3424], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 3354, "finallyExpressionEnd": 3362, "finallyBlockStart": 3354, "finallyBlockEnd": 3521, "cleanUpCallStart": [3409], "cleanUpCallEnd": [3424], "url": "https://github.com/commoncrawl/commoncrawl-crawler/tree/master/src/org/commoncrawl/service/listcrawler/CacheManager.java", "rawCode": "  private final void flushLocalLog(\n      final long bytesToRemove,\n      final int itemsToRemove,\n      final List<FingerprintAndOffsetTuple> flushedTupleList,\n      final ArrayList<IndexDataFileTriple> tempFileTriples) {\n\n    LOG.info(\"Acquiring Log Access Semaphores\");\n    // first boost this thread's priority ...\n    int originalThreadPriority = Thread.currentThread().getPriority();\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n    // next acquire all permits to the local access log ... block until we get there ...\n    getLocalLogAccessSemaphore().acquireUninterruptibly(LOG_ACCESS_SEMAPHORE_COUNT);\n    // now that we have all the semaphores we need, reduce the thread's priority to normal\n    Thread.currentThread().setPriority(originalThreadPriority);\n    LOG.info(\"Acquired ALL Log Access Semaphores\");\n\n    long timeStart = System.currentTimeMillis();\n\n    // now we have exclusive access to the local transaction log ...\n    File activeLogFilePath = getActiveLogFilePath();\n    File checkpointLogFilePath = getCheckpointLogFilePath();\n    try {\n      // delete checkpoint file if it existed ...\n      checkpointLogFilePath.delete();\n      // now rename activelog to checkpoint path\n      activeLogFilePath.renameTo(checkpointLogFilePath);\n\n      long logFileConsolidationStartTime = System.currentTimeMillis();\n      // now trap for exceptions in case something fails\n      try {\n        // fix up the header ...\n        _header._fileSize -= bytesToRemove;\n        _header._itemCount -= itemsToRemove;\n\n        // open a old file and new file\n        RandomAccessFile newFile = new RandomAccessFile(activeLogFilePath, \"rw\");\n        RandomAccessFile oldFile = new RandomAccessFile(checkpointLogFilePath, \"r\");\n\n        LOG.info(\n            \"Opened new and old files. New Header FileSize is:\"\n                + _header._fileSize\n                + \" ItemCount:\"\n                + _header._itemCount);\n        try {\n          // write out header ...\n          long bytesRemainingInLogFile = _header._fileSize;\n\n          LOG.info(\n              \"Writing Header to New File. Bytes Remaining for Data are:\"\n                  + bytesRemainingInLogFile);\n          // write header to new file ...\n          _header.writeHeader(newFile);\n          // decrement bytes available ...\n          bytesRemainingInLogFile -= LocalLogFileHeader.SIZE;\n\n          if (bytesRemainingInLogFile != 0) {\n            byte transferBuffer[] = new byte[(1 << 20) * 16];\n            LOG.info(\n                \"Seeking old file past flushed data (pos:\"\n                    + LocalLogFileHeader.SIZE\n                    + bytesToRemove\n                    + \")\");\n            // seek past old data ...\n            oldFile.seek(LocalLogFileHeader.SIZE + bytesToRemove);\n            // and copy across remaining data\n            while (bytesRemainingInLogFile != 0) {\n              int bytesToReadWriteThisIteration =\n                  Math.min((int) bytesRemainingInLogFile, transferBuffer.length);\n              oldFile.read(transferBuffer, 0, bytesToReadWriteThisIteration);\n              newFile.write(transferBuffer, 0, bytesToReadWriteThisIteration);\n              LOG.info(\"Copied \" + bytesToReadWriteThisIteration + \" from Old to New\");\n              bytesRemainingInLogFile -= bytesToReadWriteThisIteration;\n            }\n          }\n        } finally {\n          if (newFile != null) {\n            newFile.close();\n          }\n          if (oldFile != null) {\n            oldFile.close();\n          }\n        }\n        // if we reached here then checkpoint was successfull ...\n        LOG.info(\n            \"Checkpoint - Log Consolidation Successfull! TOOK:\"\n                + (System.currentTimeMillis() - logFileConsolidationStartTime));\n\n        LOG.info(\"Loading Index Files\");\n        for (IndexDataFileTriple triple : tempFileTriples) {\n          LOG.info(\"Loading Index File:\" + triple._localIndexFilePath);\n          final HDFSFileIndex fileIndex =\n              new HDFSFileIndex(\n                  _remoteFileSystem, triple._localIndexFilePath, triple._dataFilePath);\n          LOG.info(\"Loaded Index File\");\n          // update hdfs index list ...\n          synchronized (CacheManager.this) {\n            LOG.info(\"Adding HDFS Index to list\");\n            _hdfsIndexList.addElement(fileIndex);\n          }\n        }\n\n        // create a semaphore to wait on\n        final Semaphore semaphore = new Semaphore(0);\n\n        LOG.info(\"Scheduling Async Event\");\n        // now we need to schedule an async call to main thread to update data structures safely ...\n        _eventLoop.setTimer(\n            new Timer(\n                0,\n                false,\n                new Timer.Callback() {\n\n                  @Override\n                  public void timerFired(Timer timer) {\n                    LOG.info(\"Cleaning Map\");\n\n                    synchronized (CacheManager.this) {\n                      // walk tuples\n                      for (FingerprintAndOffsetTuple tuple : flushedTupleList) {\n                        // TODO: HACK!\n                        // remove from collection ...\n                        _fingerprintToLocalLogPos.removeAll(tuple._fingerprint);\n                      }\n                    }\n                    LOG.info(\"Increment Offset Info\");\n                    // finally increment locallog offset by bytes removed ...\n                    _localLogStartOffset += bytesToRemove;\n\n                    LOG.info(\"Releasing Wait Semaphore\");\n                    // release wait sempahore\n                    semaphore.release();\n                  }\n                }));\n\n        LOG.info(\"Waiting for Async Event to Complete\");\n        // wait for async operation to complete ...\n        semaphore.acquireUninterruptibly();\n\n        LOG.info(\"Async Event to Completed\");\n      } catch (IOException e) {\n        LOG.error(\"Checkpoint Failed with Exception:\" + CCStringUtils.stringifyException(e));\n        // delete new file ...\n        activeLogFilePath.delete();\n        // and rename checkpoint file to active file ...\n        checkpointLogFilePath.renameTo(activeLogFilePath);\n      }\n    } finally {\n      LOG.info(\n          \"Releasing ALL Log Access Semaphores. HELD FOR:\"\n              + (System.currentTimeMillis() - timeStart));\n      getLocalLogAccessSemaphore().release(LOG_ACCESS_SEMAPHORE_COUNT);\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6735, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [299], "initializationEnd": [339], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.readLong()", "randomAccessFile.readInt()", "randomAccessFile.readInt()"], "configurationStart": [367, 561, 668], "configurationEnd": [381, 574, 681], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 756, "focalAPIEnd": 778, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1271], "useEnd": [1282], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 1206, "finallyExpressionEnd": 1214, "finallyBlockStart": 1206, "finallyBlockEnd": 1374, "cleanUpCallStart": [1271], "cleanUpCallEnd": [1282], "url": "https://github.com/bocchino/DPJ-UR/tree/master/Implementation/Compiler/src/share/classes/com/sun/tools/javac/zip/ZipFileIndex.java", "rawCode": "  private boolean readIndex() {\n    if (triedToReadIndex || !usePreindexedCache) {\n      return false;\n    }\n\n    boolean ret = false;\n    lock.lock();\n    try {\n      triedToReadIndex = true;\n      RandomAccessFile raf = null;\n      try {\n        File indexFileName = getIndexFile();\n        raf = new RandomAccessFile(indexFileName, \"r\");\n\n        long fileStamp = raf.readLong();\n        if (zipFile.lastModified() != fileStamp) {\n          ret = false;\n        } else {\n          directories = new HashMap<String, DirectoryEntry>();\n          int numDirs = raf.readInt();\n          for (int nDirs = 0; nDirs < numDirs; nDirs++) {\n            int dirNameBytesLen = raf.readInt();\n            byte[] dirNameBytes = new byte[dirNameBytesLen];\n            raf.read(dirNameBytes);\n\n            String dirNameStr = new String(dirNameBytes, \"UTF-8\");\n            DirectoryEntry de = new DirectoryEntry(dirNameStr, this);\n            de.numEntries = raf.readInt();\n            de.writtenOffsetOffset = raf.readLong();\n            directories.put(dirNameStr, de);\n          }\n          ret = true;\n          zipFileLastModified = fileStamp;\n        }\n      } catch (Throwable t) {\n        // Do nothing\n      } finally {\n        if (raf != null) {\n          try {\n            raf.close();\n          } catch (Throwable tt) {\n            // Do nothing\n          }\n        }\n      }\n      if (ret == true) {\n        readFromIndex = true;\n      }\n    } finally {\n      lock.unlock();\n    }\n\n    return ret;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6736, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(randomAccessFile.length()<12)", "guardType": "IF {", "guardExpressionStart": 222, "guardExpressionEnd": 244, "guardBlockStart": 222, "guardBlockEnd": 327, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 361, "focalAPIEnd": 372, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.read(byte[])"], "useStart": [474], "useEnd": [485], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craigpetchell/Jaudiotagger/tree/master/src/org/jaudiotagger/audio/wav/util/WavInfoReader.java", "rawCode": "  public GenericAudioHeader read(RandomAccessFile raf) throws CannotReadException, IOException {\n    // Reads wav header----------------------------------------\n    GenericAudioHeader info = new GenericAudioHeader();\n\n    if (raf.length() < 12) {\n      throw new CannotReadException(\"This is not a WAV File (<12 bytes)\");\n    }\n    byte[] b = new byte[12];\n    raf.read(b);\n\n    WavRIFFHeader wh = new WavRIFFHeader(b);\n    if (wh.isValid()) {\n      b = new byte[24];\n      raf.read(b);\n\n      WavFormatHeader wfh = new WavFormatHeader(b);\n      if (wfh.isValid()) {\n        // Populates\n        // encodingInfo----------------------------------------------------\n        info.setPreciseLength(((float) raf.length() - (float) 36) / wfh.getBytesPerSecond());\n        info.setChannelNumber(wfh.getChannelNumber());\n        info.setSamplingRate(wfh.getSamplingRate());\n        info.setEncodingType(\"WAV-RIFF \" + wfh.getBitrate() + \" bits\");\n        info.setExtraEncodingInfos(\"\");\n        info.setBitrate(wfh.getBytesPerSecond() * 8 / 1000);\n        info.setVariableBitRate(false);\n      } else {\n        throw new CannotReadException(\"Wav Format Header not valid\");\n      }\n    } else {\n      throw new CannotReadException(\"Wav RIFF Header not valid\");\n    }\n\n    return info;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6737, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [397], "initializationEnd": [445], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 521, "focalAPIEnd": 555, "followUpCheck": "byteCount <= off", "checkType": "IF", "followUpCheckExpressionStart": 582, "followUpCheckExpressionEnd": 595, "followUpCheckBlockStart": 582, "followUpCheckBlockEnd": 626, "use": ["randomAccessFile.close()"], "useStart": [563], "useEnd": [574], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/munjeni/miui_sony_xperia/tree/master/miui/src/frameworks/base/core/java/com/android/internal/widget/LockPatternUtils.java", "rawCode": "  /**\n   * Check to see if a password matches the saved password. If no password exists, always returns\n   * true.\n   *\n   * @param password The password to check.\n   * @return Whether the password matches the stored one.\n   */\n  @MiuiHook(MiuiHookType.CHANGE_CODE)\n  public boolean checkPassword(String password) {\n    try {\n      // Read all the bytes from the file\n      RandomAccessFile raf = new RandomAccessFile(sLockPasswordFilename, \"r\");\n      final byte[] stored = new byte[(int) raf.length()];\n      int got = raf.read(stored, 0, stored.length);\n      raf.close();\n      if (got <= 0) {\n        return true;\n      }\n      // Compare the hash from the file with the entered password's hash\n      return Arrays.equals(stored, passwordToHash(stored, password));\n    } catch (FileNotFoundException fnfe) {\n      return true;\n    } catch (IOException ioe) {\n      return true;\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6738, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [1431], "initializationEnd": [1469], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.length()", "randomAccessFile.seek(long)"], "configurationStart": [1487, 1527], "configurationEnd": [1499, 1544], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 1563, "focalAPIEnd": 1573, "followUpCheck": "byteCount != '\\n'", "checkType": "IF", "followUpCheckExpressionStart": 1581, "followUpCheckExpressionEnd": 1598, "followUpCheckBlockStart": 1581, "followUpCheckBlockEnd": 1615, "use": ["randomAccessFile.write(char)", "randomAccessFile.write(int)", "randomAccessFile.close()"], "useStart": [1599, 1627, 1684], "useEnd": [1614, 1678, 1695], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kyau/connectbot/tree/master/src/com/trilead/ssh2/KnownHosts.java", "rawCode": "  /**\n   * Adds a single public key entry to the a known_hosts file. This method is designed to be used in\n   * a {@link ServerHostKeyVerifier}.\n   *\n   * @param knownHosts the file where the publickey entry will be appended.\n   * @param hostnames a list of hostname patterns - at least one most be specified. Check out the\n   *     OpenSSH sshd man page for a description of the pattern matching algorithm.\n   * @param serverHostKeyAlgorithm as passed to the {@link ServerHostKeyVerifier}.\n   * @param serverHostKey as passed to the {@link ServerHostKeyVerifier}.\n   * @throws IOException\n   */\n  public static final void addHostkeyToFile(\n      File knownHosts, String[] hostnames, String serverHostKeyAlgorithm, byte[] serverHostKey)\n      throws IOException {\n    if ((hostnames == null) || (hostnames.length == 0))\n      throw new IllegalArgumentException(\"Need at least one hostname specification\");\n\n    if ((serverHostKeyAlgorithm == null) || (serverHostKey == null))\n      throw new IllegalArgumentException();\n\n    CharArrayWriter writer = new CharArrayWriter();\n\n    for (int i = 0; i < hostnames.length; i++) {\n      if (i != 0) writer.write(',');\n      writer.write(hostnames[i]);\n    }\n\n    writer.write(' ');\n    writer.write(serverHostKeyAlgorithm);\n    writer.write(' ');\n    writer.write(Base64.encode(serverHostKey));\n    writer.write(\"\\n\");\n\n    char[] entry = writer.toCharArray();\n\n    RandomAccessFile raf = new RandomAccessFile(knownHosts, \"rw\");\n\n    long len = raf.length();\n\n    if (len > 0) {\n      raf.seek(len - 1);\n      int last = raf.read();\n      if (last != '\\n') raf.write('\\n');\n    }\n\n    raf.write(new String(entry).getBytes(\"ISO-8859-1\"));\n    raf.close();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6739, "initialization": ["byte[] b = temp()"], "initializationStart": [125], "initializationEnd": [131], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["make(*)"], "tryExpressionStart": 46, "tryExpressionEnd": 50, "tryBlockStart": 46, "tryBlockEnd": 633, "catchExpressionStart": 468, "catchExpressionEnd": 490, "catchBlockStart": 468, "catchBlockEnd": 524, "exceptionHandlingCallStart": [504], "exceptionHandlingCallEnd": [517], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 278, "focalAPIEnd": 343, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["MessageDigest.update(byte[],int,byteCount)"], "useStart": [353], "useEnd": [374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xored/f4/tree/master/com.xored.f4.fantom/fantom/src/sys/java/fan/sys/FileBuf.java", "rawCode": "  public Buf toDigest(String algorithm) {\n    try {\n      long oldPos = pos();\n      long size = size();\n      byte[] temp = temp();\n      MessageDigest md = MessageDigest.getInstance(algorithm);\n\n      pos(0);\n      long total = 0;\n      while (total < size) {\n        int n = fp.read(temp, 0, (int) Math.min(temp.length, (int) size - total));\n        md.update(temp, 0, n);\n        total += n;\n      }\n\n      pos(oldPos);\n      return new MemBuf(md.digest());\n    } catch (IOException e) {\n      throw IOErr.make(e);\n    } catch (NoSuchAlgorithmException e) {\n      throw ArgErr.make(\"Unknown digest algorthm: \" + algorithm);\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6740, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 76, "tryExpressionEnd": 80, "tryBlockStart": 76, "tryBlockEnd": 376, "catchExpressionStart": 320, "catchExpressionEnd": 342, "catchBlockStart": 320, "catchBlockEnd": 376, "exceptionHandlingCallStart": [350], "exceptionHandlingCallEnd": [369], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 156, "focalAPIEnd": 207, "followUpCheck": "byteCount < mbuf.len - i", "checkType": "IF", "followUpCheckExpressionStart": 217, "followUpCheckExpressionEnd": 238, "followUpCheckBlockStart": 217, "followUpCheckBlockEnd": 305, "use": ["randomAccessFile.seek(int)"], "useStart": [251], "useEnd": [266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_4_0_RC3/appia/src/net/sf/appia/test/perf/PerfSession.java", "rawCode": "  private void writePayload(MsgBuffer mbuf, RandomAccessFile payload) {\n    try {\n      int i, r = 0;\n      for (i = 0; i < mbuf.len; i += r) {\n        r = payload.read(mbuf.data, mbuf.off + i, mbuf.len - i);\n        if (r < mbuf.len - i) {\n          payload.seek(0);\n          if (r < 0) r = 0;\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6741, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [178], "initializationEnd": [209], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 336, "tryExpressionEnd": 340, "tryBlockStart": 336, "tryBlockEnd": 591, "catchExpressionStart": 440, "catchExpressionEnd": 464, "catchBlockStart": 440, "catchBlockEnd": 591, "exceptionHandlingCallStart": [472], "exceptionHandlingCallEnd": [520], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 395, "focalAPIEnd": 413, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [421], "useEnd": [432], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/dalvik/src/main/java/dalvik/system/TouchDexLoader.java", "rawCode": "  private byte[] loadFromDirectory(String path) {\n    RandomAccessFile raf;\n    byte[] fileData;\n\n    // System.out.println(\"Trying to load from \" + path);\n    try {\n      raf = new RandomAccessFile(path, \"r\");\n    } catch (FileNotFoundException fnfe) {\n      // System.out.println(\" Not found: \" + path);\n      return null;\n    }\n\n    try {\n      fileData = new byte[(int) raf.length()];\n      raf.read(fileData);\n      raf.close();\n    } catch (IOException ioe) {\n      System.err.println(\"Error reading from \" + path);\n      // swallow it, return null instead\n      fileData = null;\n    }\n\n    return fileData;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6742, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [171], "configurationEnd": [194], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 209, "focalAPIEnd": 221, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fanhongtao/JDK/tree/master/src/javax/imageio/stream/FileCacheImageInputStream.java", "rawCode": "  public int read() throws IOException {\n    checkClosed();\n    bitOffset = 0;\n    long next = streamPos + 1;\n    long pos = readUntil(next);\n    if (pos >= next) {\n      cache.seek(streamPos++);\n      return cache.read();\n    } else {\n      return -1;\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6743, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [298], "initializationEnd": [338], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.readLong()", "randomAccessFile.readInt()", "randomAccessFile.readInt()"], "configurationStart": [366, 571, 678], "configurationEnd": [380, 584, 691], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 766, "focalAPIEnd": 788, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1314], "useEnd": [1325], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 1249, "finallyExpressionEnd": 1257, "finallyBlockStart": 1249, "finallyBlockEnd": 1417, "cleanUpCallStart": [1314], "cleanUpCallEnd": [1325], "url": "https://github.com/openjdk-mirror/jdk7u-langtools/tree/master/src/share/classes/com/sun/tools/javac/file/ZipFileIndex.java", "rawCode": "  private boolean readIndex() {\n    if (triedToReadIndex || !usePreindexedCache) {\n      return false;\n    }\n\n    boolean ret = false;\n    synchronized (this) {\n      triedToReadIndex = true;\n      RandomAccessFile raf = null;\n      try {\n        File indexFileName = getIndexFile();\n        raf = new RandomAccessFile(indexFileName, \"r\");\n\n        long fileStamp = raf.readLong();\n        if (zipFile.lastModified() != fileStamp) {\n          ret = false;\n        } else {\n          directories = new HashMap<RelativeDirectory, DirectoryEntry>();\n          int numDirs = raf.readInt();\n          for (int nDirs = 0; nDirs < numDirs; nDirs++) {\n            int dirNameBytesLen = raf.readInt();\n            byte[] dirNameBytes = new byte[dirNameBytesLen];\n            raf.read(dirNameBytes);\n\n            RelativeDirectory dirNameStr = getRelativeDirectory(new String(dirNameBytes, \"UTF-8\"));\n            DirectoryEntry de = new DirectoryEntry(dirNameStr, this);\n            de.numEntries = raf.readInt();\n            de.writtenOffsetOffset = raf.readLong();\n            directories.put(dirNameStr, de);\n          }\n          ret = true;\n          zipFileLastModified = fileStamp;\n        }\n      } catch (Throwable t) {\n        // Do nothing\n      } finally {\n        if (raf != null) {\n          try {\n            raf.close();\n          } catch (Throwable tt) {\n            // Do nothing\n          }\n        }\n      }\n      if (ret == true) {\n        readFromIndex = true;\n      }\n    }\n\n    return ret;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6744, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [178], "initializationEnd": [209], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 336, "tryExpressionEnd": 340, "tryBlockStart": 336, "tryBlockEnd": 591, "catchExpressionStart": 440, "catchExpressionEnd": 464, "catchBlockStart": 440, "catchBlockEnd": 591, "exceptionHandlingCallStart": [472], "exceptionHandlingCallEnd": [520], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 395, "focalAPIEnd": 413, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [421], "useEnd": [432], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/dalvik/src/main/java/dalvik/system/TouchDexLoader.java", "rawCode": "  private byte[] loadFromDirectory(String path) {\n    RandomAccessFile raf;\n    byte[] fileData;\n\n    // System.out.println(\"Trying to load from \" + path);\n    try {\n      raf = new RandomAccessFile(path, \"r\");\n    } catch (FileNotFoundException fnfe) {\n      // System.out.println(\" Not found: \" + path);\n      return null;\n    }\n\n    try {\n      fileData = new byte[(int) raf.length()];\n      raf.read(fileData);\n      raf.close();\n    } catch (IOException ioe) {\n      System.err.println(\"Error reading from \" + path);\n      // swallow it, return null instead\n      fileData = null;\n    }\n\n    return fileData;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6745, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.length()", "randomAccessFile.seek(long)"], "configurationStart": [949, 1099], "configurationEnd": [960, 1115], "guardCondition": "!(seekloc+compressedsize>randomAccessFile.length()) && !(index>randomAccessFile.length())", "guardType": "IF {", "guardExpressionStart": 117, "guardExpressionEnd": 141, "guardBlockStart": 117, "guardBlockEnd": 212, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 1121, "focalAPIEnd": 1136, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/systemsgenetics/tree/master/genetica-libraries/src/main/java/umcg/genetica/io/trityper/bin/BinaryGZipFloatMatrix.java", "rawCode": "  public Float[] read(long index, long nextIndex, int numElems)\n      throws IOException, DataFormatException {\n\n    if (index > ra.length()) {\n      throw new IOException(\"IO Error: SNP ID out of scope!\");\n    }\n\n    long seekloc = index;\n\n    int compressedsize = 0;\n\n    // if this is the last element, read to the end\n    if (nextIndex == -1) {\n      long curpos = seekloc;\n      long nextpos = ra.length();\n      compressedsize =\n          (int)\n              (nextpos\n                  - curpos); // TODO: watch out for buffer overruns here --> size might be greater\n                             // than int.maxvalue\n    } else {\n      long curpos = seekloc;\n      long nextpos = nextIndex;\n      compressedsize =\n          (int)\n              (nextpos\n                  - curpos); // TODO: watch out for buffer overruns here --> size might be greater\n                             // than int.maxvalue\n    }\n    if (seekloc + compressedsize > ra.length()) {\n      throw new IOException(\"IO Error: buffer to be loaded is out of scope\");\n    }\n\n    byte[] buffer = new byte[compressedsize];\n    ra.seek(seekloc);\n    ra.read(buffer);\n    inflater.setInput(buffer);\n    inflater.finished();\n    byte[] decompressed = new byte[numElems * 4];\n    inflater.inflate(decompressed);\n\n    long actuallydecompressed = inflater.getBytesWritten();\n    if (actuallydecompressed != numElems * 4) {\n      throw new IOException(\n          \"IO Error: uncompressed data does not correspond to the size requested\\t\"\n              + actuallydecompressed\n              + \"\\t\"\n              + numElems * 4\n              + \"\\t Index: \"\n              + index);\n    }\n\n    inflater.reset();\n\n    ByteBuffer bytebuffer = ByteBuffer.wrap(decompressed);\n\n    Float[] output = new Float[numElems];\n    for (int i = 0; i < numElems; i++) {\n      output[i] = bytebuffer.getFloat();\n    }\n\n    return output;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6746, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 269, "focalAPIEnd": 283, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/rt.equinox.p2/tree/master/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/pde/internal/swt/tools/IconExe.java", "rawCode": "  static byte[] loadData(BITMAPINFOHEADER bih, RandomAccessFile raf, int stride)\n      throws IOException {\n    int dataSize = bih.biHeight * stride;\n    byte[] data = new byte[dataSize];\n    int cmp = bih.biCompression;\n    if (cmp == 0) { // BMP_NO_COMPRESSION\n      raf.read(data);\n    } else {\n      if (DEBUG) System.out.println(\"ICO cannot be compressed?\"); // $NON-NLS-1$\n    }\n    return data;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6747, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getFilePointer()", "randomAccessFile.seek(long)"], "configurationStart": [82, 224], "configurationEnd": [102, 243], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 289, "focalAPIEnd": 323, "followUpCheck": "byteCount > -1 && br < len", "checkType": "LOOP {", "followUpCheckExpressionStart": 329, "followUpCheckExpressionEnd": 363, "followUpCheckBlockStart": 329, "followUpCheckBlockEnd": 440, "use": ["randomAccessFile.read(byte[],int,int)"], "useStart": [393], "useEnd": [433], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/igorhvr/bedlam/tree/master/sisc/sisc-cvs/src/sisc/ser/BufferedRandomAccessInputStream.java", "rawCode": "  protected final void advance() throws IOException {\n    flush(0);\n    long cp = raf.getFilePointer();\n    if (offset[0] == -1) offset[0] = cp;\n    else {\n      offset[0] += bufferSize;\n      if (cp != offset[0]) {\n        raf.seek(offset[0]);\n      }\n    }\n\n    int br = 0;\n    int rv = raf.read(buffer[0], 0, bufferSize);\n    while (rv > -1 && br < bufferSize) {\n      br += rv;\n      rv = raf.read(buffer[0], br, bufferSize - br);\n    }\n    if (br < bufferSize) eofAt[0] = br;\n    else {\n      eofAt[0] = -1;\n    }\n    bufferPtr = 0;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6748, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.skipBytes(int)"], "configurationStart": [207], "configurationEnd": [299], "guardCondition": "off<size", "guardType": "LOOP {", "guardExpressionStart": 361, "guardExpressionEnd": 382, "guardBlockStart": 361, "guardBlockEnd": 520, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 405, "focalAPIEnd": 454, "followUpCheck": "byteCount == -1", "checkType": "IF", "followUpCheckExpressionStart": 464, "followUpCheckExpressionEnd": 480, "followUpCheckBlockStart": 464, "followUpCheckBlockEnd": 487, "use": ["randomAccessFile.skipBytes(int)", "randomAccessFile.readFully(byte[],int,int)"], "useStart": [630, 728], "useEnd": [722, 767], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-langtools/tree/master/src/share/classes/com/sun/tools/javac/file/ZipFileIndex.java", "rawCode": "  /** */\n  private int readBytes(Entry entry, byte[] buffer) throws IOException {\n    byte[] header = getHeader(entry);\n\n    // entry is not compressed?\n    if (get2ByteLittleEndian(header, 8) == 0) {\n      zipRandomFile.skipBytes(get2ByteLittleEndian(header, 26) + get2ByteLittleEndian(header, 28));\n      int offset = 0;\n      int size = buffer.length;\n      while (offset < size) {\n        int count = zipRandomFile.read(buffer, offset, size - offset);\n        if (count == -1) break;\n        offset += count;\n      }\n      return entry.size;\n    }\n\n    int csize = entry.compressedSize;\n    byte[] cbuf = new byte[csize];\n    zipRandomFile.skipBytes(get2ByteLittleEndian(header, 26) + get2ByteLittleEndian(header, 28));\n    zipRandomFile.readFully(cbuf, 0, csize);\n\n    int count = inflate(cbuf, buffer);\n    if (count == -1) throw new ZipException(\"corrupted zip file\");\n\n    return entry.size;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6749, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.io.RandomAccessFile.seek(long)"], "configurationStart": [89], "configurationEnd": [103], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 117, "focalAPIEnd": 142, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/visad/visad/tree/master/deps/src/ucar/netcdf/RandomAccessFile.java", "rawCode": "  protected int read_(long pos, byte[] b, int offset, int len) throws IOException {\n\n    file.seek(pos);\n    int n = file.read(b, offset, len);\n\n    // System.out.println(\" want = \"+len+\" at \"+pos+\"; got = \"+n);\n    return n;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6750, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 76, "tryExpressionEnd": 80, "tryBlockStart": 76, "tryBlockEnd": 376, "catchExpressionStart": 320, "catchExpressionEnd": 342, "catchBlockStart": 320, "catchBlockEnd": 376, "exceptionHandlingCallStart": [350], "exceptionHandlingCallEnd": [369], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 156, "focalAPIEnd": 207, "followUpCheck": "byteCount < mbuf.len - i", "checkType": "IF", "followUpCheckExpressionStart": 217, "followUpCheckExpressionEnd": 238, "followUpCheckBlockStart": 217, "followUpCheckBlockEnd": 305, "use": ["randomAccessFile.seek(int)"], "useStart": [251], "useEnd": [266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_4_1_2/appia/src/test/net/sf/appia/test/perf/PerfSession.java", "rawCode": "  private void writePayload(MsgBuffer mbuf, RandomAccessFile payload) {\n    try {\n      int i, r = 0;\n      for (i = 0; i < mbuf.len; i += r) {\n        r = payload.read(mbuf.data, mbuf.off + i, mbuf.len - i);\n        if (r < mbuf.len - i) {\n          payload.seek(0);\n          if (r < 0) r = 0;\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6751, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 232, "focalAPIEnd": 262, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new String(byte[],int,byteCount)"], "useStart": [368], "useEnd": [400], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/roskens/jrobin/tree/master/src/main/java/org/jrobin/core/jrrd/RRDFile.java", "rawCode": "  String readString(int maxLength) throws IOException, RrdException {\n    if (this.debug) {\n      System.out.print(\n          \"Read \" + maxLength + \" bytes (string) from offset \" + ras.getFilePointer() + \":\");\n    }\n    maxLength = ras.read(buffer, 0, maxLength);\n    if (maxLength == -1) {\n      throw new RrdException(\"Invalid RRD file\");\n    }\n\n    String result = new String(buffer, 0, maxLength).trim();\n    if (this.debug) {\n      System.out.println(result + \":\");\n    }\n    return result;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6752, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [298], "initializationEnd": [338], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.readLong()", "randomAccessFile.readInt()", "randomAccessFile.readInt()"], "configurationStart": [366, 571, 678], "configurationEnd": [380, 584, 691], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 766, "focalAPIEnd": 788, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1314], "useEnd": [1325], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 1249, "finallyExpressionEnd": 1257, "finallyBlockStart": 1249, "finallyBlockEnd": 1417, "cleanUpCallStart": [1314], "cleanUpCallEnd": [1325], "url": "https://github.com/tmyroadctfig/unexceptional-javac/tree/master/src/share/classes/com/sun/tools/javac/file/ZipFileIndex.java", "rawCode": "  private boolean readIndex() {\n    if (triedToReadIndex || !usePreindexedCache) {\n      return false;\n    }\n\n    boolean ret = false;\n    synchronized (this) {\n      triedToReadIndex = true;\n      RandomAccessFile raf = null;\n      try {\n        File indexFileName = getIndexFile();\n        raf = new RandomAccessFile(indexFileName, \"r\");\n\n        long fileStamp = raf.readLong();\n        if (zipFile.lastModified() != fileStamp) {\n          ret = false;\n        } else {\n          directories = new HashMap<RelativeDirectory, DirectoryEntry>();\n          int numDirs = raf.readInt();\n          for (int nDirs = 0; nDirs < numDirs; nDirs++) {\n            int dirNameBytesLen = raf.readInt();\n            byte[] dirNameBytes = new byte[dirNameBytesLen];\n            raf.read(dirNameBytes);\n\n            RelativeDirectory dirNameStr = getRelativeDirectory(new String(dirNameBytes, \"UTF-8\"));\n            DirectoryEntry de = new DirectoryEntry(dirNameStr, this);\n            de.numEntries = raf.readInt();\n            de.writtenOffsetOffset = raf.readLong();\n            directories.put(dirNameStr, de);\n          }\n          ret = true;\n          zipFileLastModified = fileStamp;\n        }\n      } catch (Throwable t) {\n        // Do nothing\n      } finally {\n        if (raf != null) {\n          try {\n            raf.close();\n          } catch (Throwable tt) {\n            // Do nothing\n          }\n        }\n      }\n      if (ret == true) {\n        readFromIndex = true;\n      }\n    }\n\n    return ret;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6753, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [592], "configurationEnd": [615], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 701, "focalAPIEnd": 719, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getFilePointer()"], "useStart": [1015], "useEnd": [1034], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/oVirt/ovirt-dwh/tree/master/ovirt-engine-dwh/advancedPersistentLookupLib/src/main/java/org/talend/designer/components/thash/io/hashimpl/SortedMultipleHashFile.java", "rawCode": "  public Object get(String container, long cursorPosition, int hashcode)\n      throws IOException, ClassNotFoundException {\n\n    if (raArray == null) {\n      throw new IllegalStateException(\n          \"Call initGet(..) one time before all call on get(..) method\"); // $NON-NLS-1$\n    }\n\n    // System.out.println(\"GET cursorPosition=\"+cursorPosition + \" hashcode=\"+hashcode);\n\n    int fileNumber = getFileNumber(hashcode);\n\n    // System.out.println(fileNumber);\n\n    RandomAccessFile ra = raArray[fileNumber];\n\n    if (cursorPosition != lastRetrievedCursorPositionArray[fileNumber]) {\n      ra.seek(cursorPosition);\n      int readInt = ra.readInt();\n      byte[] byteArray = new byte[readInt];\n      ra.read(byteArray);\n\n      lastRetrievedObjectArray[fileNumber] = iLightSerializable.createInstance(byteArray);\n      lastRetrievedCursorPositionArray[fileNumber] = cursorPosition;\n\n      DataInputStream dis = disArray[fileNumber];\n\n      long disPosition = disPositionsArray[fileNumber];\n\n      long raPosition = ra.getFilePointer();\n\n      if (raPosition < disPosition) {\n\n      } else {\n\n        if (raPosition > disPosition) {\n          dis.skip(raPosition - disPosition);\n        }\n\n        try {\n          // readInt = ra.readInt();\n          // byteArray = new byte[readInt];\n          // ra.read(byteArray);\n          readInt = dis.readInt();\n          byteArray = new byte[readInt];\n          dis.read(byteArray);\n\n          disPositionsArray[fileNumber] += 4 + byteArray.length;\n\n          nextObjectsArray[fileNumber] = iLightSerializable.createInstance(byteArray);\n        } catch (IOException e) {\n          // EOF\n          nextObjectsArray[fileNumber] = null;\n        }\n      }\n    }\n    // System.out.println(\"Found:\" + lastRetrievedObjectArray[fileNumber]);\n    return lastRetrievedObjectArray[fileNumber];\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6754, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [92], "initializationEnd": [122], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 245, "focalAPIEnd": 264, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [322], "useEnd": [337], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.engine/tree/master/tests/org.eclipse.birt.core.tests/test/org/eclipse/birt/core/archive/ArchiveFileSaveTest.java", "rawCode": "  void copyFile(String src, String tgt) throws IOException {\n    RandomAccessFile srcFile = new RandomAccessFile(src, \"r\");\n    RandomAccessFile tgtFile = new RandomAccessFile(tgt, \"rw\");\n    byte[] bytes = new byte[(int) srcFile.length()];\n    srcFile.read(bytes);\n    tgtFile.setLength(0);\n    tgtFile.write(bytes);\n    srcFile.close();\n    tgtFile.close();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6755, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 176, "focalAPIEnd": 187, "followUpCheck": "byteCount == -1", "checkType": "IF", "followUpCheckExpressionStart": 193, "followUpCheckExpressionEnd": 211, "followUpCheckBlockStart": 193, "followUpCheckBlockEnd": 336, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/imsaguy/bitcoinj/tree/master/core/src/main/java/com/google/bitcoin/store/DiskBlockStore.java", "rawCode": "  private void load(File theFile) throws IOException, BlockStoreException {\n    log.info(\"Reading block store from {}\", theFile);\n    // Read a version byte.\n    int version = file.read();\n    if (version == -1) {\n      // No such file or the file was empty.\n      throw new FileNotFoundException(theFile.getName() + \" is empty\");\n    }\n    if (version != 1) {\n      throw new BlockStoreException(\"Bad version number: \" + version);\n    }\n    // Chain head pointer is the first thing in the file.\n    byte[] chainHeadHash = new byte[32];\n    if (file.read(chainHeadHash) < chainHeadHash.length)\n      throw new BlockStoreException(\"Truncated block store: cannot read chain head hash\");\n    this.chainHead = new Sha256Hash(chainHeadHash);\n    log.info(\"Read chain head from disk: {}\", this.chainHead);\n    long now = System.currentTimeMillis();\n    // Rest of file is raw block headers.\n    byte[] headerBytes = new byte[Block.HEADER_SIZE];\n    try {\n      while (true) {\n        // Read a block from disk.\n        int read = file.read(headerBytes);\n        if (read == -1) {\n          // End of file.\n          break;\n        }\n        if (read < headerBytes.length) {\n          throw new BlockStoreException(\"Truncated block store: partial block read\");\n        }\n        // Parse it.\n        Block b = new Block(params, headerBytes);\n        // Look up the previous block it connects to.\n        StoredBlock prev = get(b.getPrevBlockHash());\n        StoredBlock s;\n        if (prev == null) {\n          // First block in the stored chain has to be treated specially.\n          if (b.equals(params.genesisBlock)) {\n            s =\n                new StoredBlock(\n                    params.genesisBlock.cloneAsHeader(), params.genesisBlock.getWork(), 0);\n          } else {\n            throw new BlockStoreException(\n                \"Could not connect \"\n                    + b.getHash().toString()\n                    + \" to \"\n                    + b.getPrevBlockHash().toString());\n          }\n        } else {\n          // Don't try to verify the genesis block to avoid upsetting the unit tests.\n          b.verifyHeader();\n          // Calculate its height and total chain work.\n          s = prev.build(b);\n        }\n        // Save in memory.\n        blockMap.put(b.getHash(), s);\n      }\n    } catch (ProtocolException e) {\n      // Corrupted file.\n      throw new BlockStoreException(e);\n    } catch (VerificationException e) {\n      // Should not be able to happen unless the file contains bad blocks.\n      throw new BlockStoreException(e);\n    }\n    long elapsed = System.currentTimeMillis() - now;\n    log.info(\"Block chain read complete in {}ms\", elapsed);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6756, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 529, "focalAPIEnd": 592, "followUpCheck": "byteCount == -1", "checkType": "IF", "followUpCheckExpressionStart": 598, "followUpCheckExpressionEnd": 615, "followUpCheckBlockStart": 598, "followUpCheckBlockEnd": 694, "use": ["randomAccessFile.read(byte[],int,int)"], "useStart": [1119], "useEnd": [1192], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/leif81/openmap-maven/tree/master/src/openmap/com/bbn/openmap/layer/shape/ShapeFile.java", "rawCode": "  /**\n   * Returns the next record from the shape file as an <code>ESRIRecord</code>. Each successive call\n   * gets the next record. There is no way to go back a record. When there are no more records,\n   * <code>null</code> is returned.\n   *\n   * @return a record, or null if there are no more records\n   * @exception IOException if something goes wrong reading the file\n   */\n  public ESRIRecord getNextRecord() throws IOException {\n    // Debug.output(\"getNextRecord: ptr = \" +\n    // raf.getFilePointer());\n    int result = raf.read(recHdr, 0, ShapeUtils.SHAPE_FILE_RECORD_HEADER_LENGTH);\n    if (result == -1) { // EOF\n      // Debug.output(\"getNextRecord: EOF\");\n      return null;\n    }\n\n    int contentLength = ShapeUtils.readBEInt(recHdr, 4);\n    int bytesToRead = contentLength * 2;\n    int fullRecordSize = bytesToRead + 8;\n    if (recBuf.length < fullRecordSize) {\n      if (Debug.debugging(\"shape\")) {\n        Debug.output(\"record size: \" + fullRecordSize);\n      }\n      recBuf = new byte[fullRecordSize];\n    }\n    System.arraycopy(recHdr, 0, recBuf, 0, ShapeUtils.SHAPE_FILE_RECORD_HEADER_LENGTH);\n    raf.read(recBuf, ShapeUtils.SHAPE_FILE_RECORD_HEADER_LENGTH, bytesToRead);\n\n    switch (fileShapeType) {\n      case ShapeUtils.SHAPE_TYPE_NULL:\n        throw new IOException(\"Can't parse NULL shape type\");\n\n      case ShapeUtils.SHAPE_TYPE_POINT:\n        return new ESRIPointRecord(recBuf, 0);\n\n      case ShapeUtils.SHAPE_TYPE_ARC:\n        // case ShapeUtils.SHAPE_TYPE_POLYLINE:\n        return new ESRIPolygonRecord(recBuf, 0);\n\n      case ShapeUtils.SHAPE_TYPE_POLYGON:\n        return new ESRIPolygonRecord(recBuf, 0);\n\n      case ShapeUtils.SHAPE_TYPE_MULTIPOINT:\n        throw new IOException(\"Multipoint shape not yet implemented\");\n\n      default:\n        throw new IOException(\"Unknown shape type: \" + fileShapeType);\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6757, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [177], "configurationEnd": [198], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 311, "focalAPIEnd": 344, "followUpCheck": "byteCount < len", "checkType": "IF", "followUpCheckExpressionStart": 352, "followUpCheckExpressionEnd": 381, "followUpCheckBlockStart": 352, "followUpCheckBlockEnd": 399, "use": ["scanBlockForStart(byte[],byteCount,int,int)", "scanBlock(byte[],byteCount,int,int)", "randomAccessFile.seek(int)", "randomAccessFile.seek(int)"], "useStart": [573, 796, 891, 1353], "useEnd": [628, 843, 912, 1374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/camporter/mha-server/tree/master/src/myhomeaudio/server/mp3/Mp3File.java", "rawCode": "  private void scanFile(RandomAccessFile file) throws IOException, InvalidDataException {\n    byte[] bytes = new byte[bufferLength];\n    int fileOffset = preScanFile(file);\n    file.seek(fileOffset);\n    boolean lastBlock = false;\n    int lastOffset = fileOffset;\n    while (!lastBlock) {\n      int bytesRead = file.read(bytes, 0, bufferLength);\n      if (bytesRead < bufferLength) lastBlock = true;\n      if (bytesRead >= MINIMUM_BUFFER_LENGTH) {\n        while (true) {\n          try {\n            int offset = 0;\n            if (startOffset < 0) {\n              offset = scanBlockForStart(bytes, bytesRead, fileOffset, offset);\n              if (startOffset >= 0 && !scanFile) {\n                return;\n              }\n              lastOffset = startOffset;\n            }\n            offset = scanBlock(bytes, bytesRead, fileOffset, offset);\n            fileOffset += offset;\n            file.seek(fileOffset);\n            break;\n          } catch (InvalidDataException e) {\n            if (frameCount < 2) {\n              startOffset = -1;\n              xingOffset = -1;\n              frameCount = 0;\n              bitrates.clear();\n              lastBlock = false;\n              fileOffset = lastOffset + 1;\n              if (fileOffset == 0)\n                throw new InvalidDataException(\"Valid start of mpeg frames not found\", e);\n              file.seek(fileOffset);\n              break;\n            }\n            return;\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6758, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 219, "focalAPIEnd": 231, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/unsupported/vpf/src/main/java/org/geotools/data/vpf/io/VPFInputStream.java", "rawCode": "  /**\n   * Describe <code>readChar</code> method here.\n   *\n   * @return a <code>char</code> value\n   * @exception IOException if an error occurs\n   */\n  protected char readChar() throws IOException {\n    return (char) input.read();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6759, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.readUnsignedByte()", "randomAccessFile.readUnsignedByte()"], "configurationStart": [502, 579], "configurationEnd": [539, 616], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 1660, "focalAPIEnd": 1703, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.read(byte[])"], "useStart": [1785], "useEnd": [1831], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stephenc/java-iso-tools/tree/master/sabre/src/main/java/com/github/stephenc/javaisotools/udflib/structures/FileEntry.java", "rawCode": "  public void read(RandomAccessFile myRandomAccessFile) throws IOException {\n    DescriptorTag = new Tag();\n    DescriptorTag.read(myRandomAccessFile);\n\n    ICBTag = new IcbTag();\n    ICBTag.read(myRandomAccessFile);\n\n    Uid = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n    Gid = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n    Permissions = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n    FileLinkCount = BinaryTools.readUInt16AsInt(myRandomAccessFile);\n    RecordFormat = (short) myRandomAccessFile.readUnsignedByte();\n    RecordDisplayAttributes = (short) myRandomAccessFile.readUnsignedByte();\n    RecordLength = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n    InformationLength = BinaryTools.readUInt64AsLong(myRandomAccessFile);\n    LogicalBlocksRecorded = BinaryTools.readUInt64AsLong(myRandomAccessFile);\n\n    AccessTime = new Timestamp();\n    AccessTime.read(myRandomAccessFile);\n\n    ModificationTime = new Timestamp();\n    ModificationTime.read(myRandomAccessFile);\n\n    AttributeTime = new Timestamp();\n    AttributeTime.read(myRandomAccessFile);\n\n    Checkpoint = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n\n    ExtendedAttributeICB = new Long_ad();\n    ExtendedAttributeICB.read(myRandomAccessFile);\n\n    ImplementationIdentifier = new EntityID();\n    ImplementationIdentifier.read(myRandomAccessFile);\n\n    UniqueID = BinaryTools.readUInt64AsLong(myRandomAccessFile);\n\n    LengthofExtendedAttributes = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n    LengthofAllocationDescriptors = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n\n    ExtendedAttributes = new byte[(int) LengthofExtendedAttributes];\n    myRandomAccessFile.read(ExtendedAttributes);\n\n    AllocationDescriptors = new byte[(int) LengthofAllocationDescriptors];\n    myRandomAccessFile.read(AllocationDescriptors);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6760, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [366], "initializationEnd": [413], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 489, "focalAPIEnd": 523, "followUpCheck": "byteCount <= off", "checkType": "IF", "followUpCheckExpressionStart": 550, "followUpCheckExpressionEnd": 563, "followUpCheckBlockStart": 550, "followUpCheckBlockEnd": 594, "use": ["randomAccessFile.close()"], "useStart": [531], "useEnd": [542], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victoryckl/android-demos/tree/master/LockPattern/src/com/way/view/LockPatternUtils.java", "rawCode": "  /**\n   * Check to see if a pattern matches the saved pattern. If no pattern exists, always returns true.\n   *\n   * @param pattern The pattern to check.\n   * @return Whether the pattern matches the stored one.\n   */\n  public boolean checkPattern(List<LockPatternView.Cell> pattern) {\n    try {\n      // Read all the bytes from the file\n      RandomAccessFile raf = new RandomAccessFile(sLockPatternFilename, \"r\");\n      final byte[] stored = new byte[(int) raf.length()];\n      int got = raf.read(stored, 0, stored.length);\n      raf.close();\n      if (got <= 0) {\n        return true;\n      }\n      // Compare the hash from the file with the entered pattern's hash\n      return Arrays.equals(stored, LockPatternUtils.patternToHash(pattern));\n    } catch (FileNotFoundException fnfe) {\n      return true;\n    } catch (IOException ioe) {\n      return true;\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6761, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [216], "configurationEnd": [230], "guardCondition": "randomAccessFile.read()==0&&randomAccessFile.read()==0&&randomAccessFile.read()==0", "guardType": "IF {", "guardExpressionStart": 322, "guardExpressionEnd": 455, "guardBlockStart": 322, "guardBlockEnd": 756, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 616, "focalAPIEnd": 635, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eswartz/emul/tree/master/v9t9/v9t9-java/v9t9-engine/src/v9t9/engine/files/image/RawTrackDiskImage.java", "rawCode": "  /**\n   * @param handle\n   * @return\n   * @throws IOException\n   */\n  private static byte[] readSector0(RandomAccessFile handle) throws IOException {\n    int ch;\n    int beforeMarkerSeen = 0;\n    int count = 0;\n    handle.seek(0);\n    while ((ch = handle.read()) >= 0 && count < 18 && ++beforeMarkerSeen < 65536) {\n      if (ch == 0xfe // ID\n          && handle.read() == 0 // track\n          && handle.read() == 0 // ...\n          && handle.read() == 0) // sector\n      {\n        while ((ch = handle.read()) != 0xfb && ch >= 0) /* */ ;\n        if (ch < 0) continue;\n\n        byte[] sector = new byte[256];\n        handle.read(sector);\n\n        if (new String(sector).contains(\"DSK\")) return sector;\n        count++;\n\n        beforeMarkerSeen = 0;\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6762, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 195, "focalAPIEnd": 218, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lboynton/XMPP-Client/tree/master/lib/mp3tag/src/org/farng/mp3/lyrics3/AbstractLyrics3v2FieldBody.java", "rawCode": "  protected int readHeader(final RandomAccessFile file) throws InvalidTagException, IOException {\n    final int size;\n    final byte[] buffer = new byte[5];\n\n    // read the 5 character size\n    file.read(buffer, 0, 5);\n    size = Integer.parseInt(new String(buffer, 0, 5));\n    if ((size == 0)\n        && (TagOptionSingleton.getInstance().isLyrics3KeepEmptyFieldIfRead() == false)) {\n      throw new InvalidTagException(\"Lyircs3v2 Field has size of zero.\");\n    }\n    return size;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6763, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 132, "focalAPIEnd": 145, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/molgenis_apps-legacy/tree/master/modules/xgap/matrix/implementations/binary/BinaryDataMatrixInstance.java", "rawCode": "  private Double[] readNextDoublesFromRAF(RandomAccessFile raf, int nr) throws IOException {\n    byte[] arr = new byte[nr * 8];\n    raf.read(arr);\n    return byteArrayToDoubles(arr);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6764, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [435], "initializationEnd": [498], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 95, "tryExpressionEnd": 99, "tryBlockStart": 95, "tryBlockEnd": 1536, "catchExpressionStart": 1482, "catchExpressionEnd": 1502, "catchBlockStart": 1482, "catchBlockEnd": 1536, "exceptionHandlingCallStart": [1510], "exceptionHandlingCallEnd": [1529], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 567, "focalAPIEnd": 592, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craigpetchell/Jaudiotagger/tree/master/srctest/org/jaudiotagger/tag/vorbiscomment/VorbisImageTest.java", "rawCode": "  /** Write and read image using lowest level methods */\n  public void testWriteImage1() {\n    try {\n      File testFile = AbstractTestCase.copyAudioToTmp(\"test.ogg\", new File(\"testWriteImage1.ogg\"));\n      AudioFile f = AudioFileIO.read(testFile);\n      VorbisCommentTag tag = (VorbisCommentTag) f.getTag();\n\n      // Add new image, requires two fields in oggVorbis with data in base64 encoded form\n      RandomAccessFile imageFile = new RandomAccessFile(new File(\"testdata\", \"coverart.png\"), \"r\");\n      byte[] imagedata = new byte[(int) imageFile.length()];\n      imageFile.read(imagedata);\n      char[] testdata = Base64Coder.encode(imagedata);\n      String base64image = new String(testdata);\n      tag.setField(tag.createField(VorbisCommentFieldKey.COVERART, base64image));\n      tag.setField(tag.createField(VorbisCommentFieldKey.COVERARTMIME, \"image/png\"));\n      f.commit();\n\n      f = AudioFileIO.read(testFile);\n      tag = (VorbisCommentTag) f.getTag();\n\n      // VorbisImage base64 image, and reconstruct\n      assertEquals(base64image, tag.getFirst(VorbisCommentFieldKey.COVERART));\n      assertEquals(\"image/png\", tag.getFirst(VorbisCommentFieldKey.COVERARTMIME));\n      BufferedImage bi =\n          ImageIO.read(\n              ImageIO.createImageInputStream(\n                  new ByteArrayInputStream(\n                      Base64Coder.decode(\n                          tag.getFirst(VorbisCommentFieldKey.COVERART).toCharArray()))));\n      assertNotNull(bi);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6765, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [438], "initializationEnd": [501], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 98, "tryExpressionEnd": 102, "tryBlockStart": 98, "tryBlockEnd": 1342, "catchExpressionStart": 1288, "catchExpressionEnd": 1308, "catchBlockStart": 1288, "catchBlockEnd": 1342, "exceptionHandlingCallStart": [1316], "exceptionHandlingCallEnd": [1335], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 570, "focalAPIEnd": 595, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craigpetchell/Jaudiotagger/tree/master/srctest/org/jaudiotagger/tag/vorbiscomment/VorbisImageTest.java", "rawCode": "  /** Write Image using lowlevel , read using new method */\n  public void testWriteImage3() {\n    try {\n      File testFile = AbstractTestCase.copyAudioToTmp(\"test.ogg\", new File(\"testWriteImage3.ogg\"));\n      AudioFile f = AudioFileIO.read(testFile);\n      VorbisCommentTag tag = (VorbisCommentTag) f.getTag();\n\n      // Add new image, requires two fields in oggVorbis with data in base64 encoded form\n      RandomAccessFile imageFile = new RandomAccessFile(new File(\"testdata\", \"coverart.png\"), \"r\");\n      byte[] imagedata = new byte[(int) imageFile.length()];\n      imageFile.read(imagedata);\n      char[] testdata = Base64Coder.encode(imagedata);\n      String base64image = new String(testdata);\n      tag.setField(tag.createField(VorbisCommentFieldKey.COVERART, base64image));\n      tag.setField(tag.createField(VorbisCommentFieldKey.COVERARTMIME, \"image/png\"));\n      f.commit();\n\n      f = AudioFileIO.read(testFile);\n      tag = (VorbisCommentTag) f.getTag();\n\n      // VorbisImage base64 image, and reconstruct\n      assertEquals(\"image/png\", tag.getArtworkMimeType());\n      byte[] newImageData = tag.getArtworkBinaryData();\n      BufferedImage bi =\n          ImageIO.read(ImageIO.createImageInputStream(new ByteArrayInputStream(newImageData)));\n      assertNotNull(bi);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6766, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [397], "initializationEnd": [460], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 97, "tryExpressionEnd": 101, "tryBlockStart": 97, "tryBlockEnd": 1382, "catchExpressionStart": 1328, "catchExpressionEnd": 1348, "catchBlockStart": 1328, "catchBlockEnd": 1382, "exceptionHandlingCallStart": [1356], "exceptionHandlingCallEnd": [1375], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 529, "focalAPIEnd": 554, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craigpetchell/Jaudiotagger/tree/master/srctest/org/jaudiotagger/tag/vorbiscomment/VorbisImageTest.java", "rawCode": "  /** Write Image using new method, read using lowlevel */\n  public void testWriteImage2() {\n    try {\n      File testFile = AbstractTestCase.copyAudioToTmp(\"test.ogg\", new File(\"testWriteImage2.ogg\"));\n      AudioFile f = AudioFileIO.read(testFile);\n      VorbisCommentTag tag = (VorbisCommentTag) f.getTag();\n\n      // Add new image using purpose built method\n      RandomAccessFile imageFile = new RandomAccessFile(new File(\"testdata\", \"coverart.png\"), \"r\");\n      byte[] imagedata = new byte[(int) imageFile.length()];\n      imageFile.read(imagedata);\n\n      tag.setArtworkField(imagedata, \"image/png\");\n      f.commit();\n\n      f = AudioFileIO.read(testFile);\n      tag = (VorbisCommentTag) f.getTag();\n\n      // VorbisImage base64 image, and reconstruct\n      char[] testdata = Base64Coder.encode(imagedata);\n      String base64image = new String(testdata);\n      assertEquals(base64image, tag.getFirst(VorbisCommentFieldKey.COVERART));\n      assertEquals(\"image/png\", tag.getFirst(VorbisCommentFieldKey.COVERARTMIME));\n      BufferedImage bi =\n          ImageIO.read(\n              ImageIO.createImageInputStream(\n                  new ByteArrayInputStream(\n                      Base64Coder.decode(\n                          tag.getFirst(VorbisCommentFieldKey.COVERART).toCharArray()))));\n      assertNotNull(bi);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6767, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 342, "focalAPIEnd": 373, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stephenc/java-iso-tools/tree/master/sabre/src/main/java/com/github/stephenc/javaisotools/udflib/structures/SpaceBitmapDescriptor.java", "rawCode": "  public void read(RandomAccessFile myRandomAccessFile) throws IOException {\n    DescriptorTag = new Tag();\n    DescriptorTag.read(myRandomAccessFile);\n\n    NumberOfBits = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n\n    NumberOfBytes = BinaryTools.readUInt32AsLong(myRandomAccessFile);\n\n    Bitmap = new byte[(int) NumberOfBytes];\n    myRandomAccessFile.read(Bitmap);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6768, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)", "randomAccessFile.seek(long)"], "configurationStart": [255, 346], "configurationEnd": [289, 380], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 440, "focalAPIEnd": 450, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/main/java/ucar/nc2/iosp/BitReader.java", "rawCode": "  /**\n   * Position file at bitOffset from startPos\n   *\n   * @param bitOffset bit offset from starting position\n   * @throws IOException on io error\n   */\n  public void setBitOffset(int bitOffset) throws IOException {\n    if (bitOffset % 8 == 0) {\n      raf.seek(startPos + bitOffset / 8);\n      bitPos = 0;\n      bitBuf = 0;\n    } else {\n      raf.seek(startPos + bitOffset / 8);\n      bitPos = 8 - (bitOffset % 8);\n      bitBuf = (byte) raf.read();\n      bitBuf &= 0xff >> (8 - bitPos); // mask off consumed bits\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6769, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [178], "initializationEnd": [209], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 336, "tryExpressionEnd": 340, "tryBlockStart": 336, "tryBlockEnd": 591, "catchExpressionStart": 440, "catchExpressionEnd": 464, "catchBlockStart": 440, "catchBlockEnd": 591, "exceptionHandlingCallStart": [472], "exceptionHandlingCallEnd": [520], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 395, "focalAPIEnd": 413, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [421], "useEnd": [432], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java", "rawCode": "  private byte[] loadFromDirectory(String path) {\n    RandomAccessFile raf;\n    byte[] fileData;\n\n    // System.out.println(\"Trying to load from \" + path);\n    try {\n      raf = new RandomAccessFile(path, \"r\");\n    } catch (FileNotFoundException fnfe) {\n      // System.out.println(\" Not found: \" + path);\n      return null;\n    }\n\n    try {\n      fileData = new byte[(int) raf.length()];\n      raf.read(fileData);\n      raf.close();\n    } catch (IOException ioe) {\n      System.err.println(\"Error reading from \" + path);\n      // swallow it, return null instead\n      fileData = null;\n    }\n\n    return fileData;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6770, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [823], "initializationEnd": [862], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 922, "focalAPIEnd": 938, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/osi/mulgara/tree/master/src/jar/rdql/java/org/mulgara/rdql/RdqlInterpreterTest.java", "rawCode": "  /**\n   * Test for {@link RdqlInterpreter#parseQuery}.\n   *\n   * @throws Exception EXCEPTION TO DO\n   */\n  public void testParseQuery() throws Exception {\n    File dir = new File(System.getProperty(\"cvs.root\"));\n    dir = new File(dir, \"test\");\n    dir = new File(dir, \"RDQL\");\n    File testFiles[] =\n        dir.listFiles(\n            new FilenameFilter() {\n              public boolean accept(File dir, String name) {\n                return name.startsWith(\"test-\");\n              }\n            });\n    for (int i = 0; i < testFiles.length; i++) {\n      System.err.println(\"Testing \" + testFiles[i]);\n      if (testFiles[i].getName().equals(\"test-8-04\")\n          || testFiles[i].getName().equals(\"test-8-05\")) {\n        continue;\n      }\n\n      // Read the file into a string and parse it\n      RandomAccessFile file = new RandomAccessFile(testFiles[i], \"r\");\n      byte[] bytes = new byte[(int) file.length()];\n      file.read(bytes);\n      // interpreter.parseQuery((new String(bytes))+\";\");\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6771, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(len<=off)", "guardType": "IF {", "guardExpressionStart": 224, "guardExpressionEnd": 244, "guardBlockStart": 224, "guardBlockEnd": 267, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 371, "focalAPIEnd": 398, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/haizi-zh/Bioscope/tree/master/ImageJ_src/plugins_install/Input-Output/DM3_Reader.java", "rawCode": "  String readStringData(int stringSize) throws IOException {\n    // Does the actual reading of string data types\n    // These should be written as Unicode which can be directly\n    // converted by the String constructor\n    if (stringSize <= 0) return new String(\"\");\n\n    // Read the string data into a temporary byte buffer.\n    byte[] temp = new byte[stringSize];\n    f.read(temp, 0, stringSize);\n\n    // Now convert these unicode bytes into a real string\n    String rString;\n\n    // Note that I can't get UTF encoding to work on MRJ 2.2.5 =\n    // JDK 1.1.7 even though I think it should\n    // so I have put together a kludge\n    if (littleEndian) {\n      // Use UTF-16LE encoding (this seems to fail with MacOS 9 Java 1.1.7)\n      try {\n        rString = new String(temp, \"UTF-16LE\");\n      } catch (Exception e) {\n        // Manual conversion of the string if the above fails\n        rString = \"\";\n        for (int i = 0; i < stringSize; i += 2) {\n          rString += new Character((char) ((temp[i + 1] & 0xFF) << 8 | (temp[i] & 0xFF)));\n        }\n      }\n\n    } else {\n      // use UTF-16BE encoding (this seems to fail with MacOS 9 Java 1.1.7)\n      try {\n        rString = new String(temp, \"UTF-16BE\");\n      } catch (Exception e) {\n        // Manual conversion of the string if the above fails\n        rString = \"\";\n        for (int i = 0; i < stringSize; i += 2) {\n          rString += new Character((char) ((temp[i] & 0xFF) << 8 | (temp[i + 1] & 0xFF)));\n        }\n      }\n    }\n\n    if (debugLevel > 0) IJ.write(\"StringVal: \" + rString);\n\n    // Store the value of this tag\n    storeTag(curTagName, rString);\n\n    return rString;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6772, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [709], "initializationEnd": [772], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 349, "tryExpressionEnd": 353, "tryBlockStart": 349, "tryBlockEnd": 9131, "catchExpressionStart": 9050, "catchExpressionEnd": 9070, "catchBlockStart": 9050, "catchBlockEnd": 9131, "exceptionHandlingCallStart": [9078], "exceptionHandlingCallEnd": [9097], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 841, "focalAPIEnd": 866, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ConatyConsulting/jaudiotagger/tree/master/srctest/org/jaudiotagger/tag/mp4/M4aWriteTagTest.java", "rawCode": "  /**\n   * Test to write tag data, new tagdata is a larger size than existing data, and too large to fit\n   * into the space already allocated to meta (ilst + free atom) and is even too large to fit into\n   * the second free atom, so mdat data gets moved\n   */\n  public void testWriteFileMuchLargerSize() {\n    Exception exceptionCaught = null;\n    try {\n      File testFile =\n          AbstractTestCase.copyAudioToTmp(\"test.m4a\", new File(\"testWriteFileMuchLargerSize.m4a\"));\n\n      // Starting filesize\n      assertEquals(TEST_FILE1_SIZE, testFile.length());\n\n      AudioFile f = AudioFileIO.read(testFile);\n      Mp4Tag tag = (Mp4Tag) f.getTag();\n\n      // Add new image\n      RandomAccessFile imageFile = new RandomAccessFile(new File(\"testdata\", \"coverart.png\"), \"r\");\n      byte[] imagedata = new byte[(int) imageFile.length()];\n      imageFile.read(imagedata);\n      tag.addField(((Mp4Tag) tag).createArtworkField(imagedata));\n\n      // Save changes and reread from disk\n      f.commit();\n      f = AudioFileIO.read(testFile);\n      tag = (Mp4Tag) f.getTag();\n\n      // Total FileSize should now be larger\n      assertEquals(3901001, testFile.length());\n\n      // AudioInfo\n      // Time in seconds\n      assertEquals(241, f.getAudioHeader().getTrackLength());\n      assertEquals(44100, f.getAudioHeader().getSampleRateAsNumber());\n\n      // Ease of use methods for common fields\n\n      assertEquals(\"Artist\", tag.getFirst(FieldKey.ARTIST));\n      assertEquals(\"Album\", tag.getFirst(FieldKey.ALBUM));\n      assertEquals(\"title\", tag.getFirst(FieldKey.TITLE));\n      assertEquals(\"comments\", tag.getFirst(FieldKey.COMMENT));\n      assertEquals(\"1971\", tag.getFirst(FieldKey.YEAR));\n      assertEquals(\"1\", tag.getFirst(FieldKey.TRACK));\n      assertEquals(\"1\", tag.getFirst(FieldKey.DISC_NO));\n      assertEquals(\"10\", tag.getFirst(FieldKey.TRACK_TOTAL));\n      assertEquals(\"10\", tag.getFirst(FieldKey.DISC_TOTAL));\n\n      assertEquals(\"composer\", tag.getFirst(FieldKey.COMPOSER));\n      assertEquals(\"Sortartist\", tag.getFirst(FieldKey.ARTIST_SORT));\n      assertEquals(\"lyrics\", tag.getFirst(FieldKey.LYRICS));\n      assertEquals(\"199\", tag.getFirst(FieldKey.BPM));\n      assertEquals(\"Albumartist\", tag.getFirst(FieldKey.ALBUM_ARTIST));\n      assertEquals(\"Sortalbumartist\", tag.getFirst(FieldKey.ALBUM_ARTIST_SORT));\n      assertEquals(\"Sortalbum\", tag.getFirst(FieldKey.ALBUM_SORT));\n      assertEquals(\"GROUping\", tag.getFirst(FieldKey.GROUPING));\n      assertEquals(\"Sortcomposer\", tag.getFirst(FieldKey.COMPOSER_SORT));\n      assertEquals(\"sorttitle\", tag.getFirst(FieldKey.TITLE_SORT));\n      assertEquals(\"1\", tag.getFirst(FieldKey.IS_COMPILATION));\n      assertEquals(\"66027994-edcf-9d89-bec8-0d30077d888c\", tag.getFirst(FieldKey.MUSICIP_ID));\n      assertEquals(\n          \"e785f700-c1aa-4943-bcee-87dd316a2c30\", tag.getFirst(FieldKey.MUSICBRAINZ_TRACK_ID));\n      assertEquals(\n          \"989a13f6-b58c-4559-b09e-76ae0adb94ed\", tag.getFirst(FieldKey.MUSICBRAINZ_ARTISTID));\n      assertEquals(\n          \"989a13f6-b58c-4559-b09e-76ae0adb94ed\",\n          tag.getFirst(FieldKey.MUSICBRAINZ_RELEASEARTISTID));\n      assertEquals(\n          \"19c6f0f6-3d6d-4b02-88c7-ffb559d52be6\", tag.getFirst(FieldKey.MUSICBRAINZ_RELEASEID));\n\n      // Cast to format specific tag\n      Mp4Tag mp4tag = (Mp4Tag) tag;\n      // Lookup by mp4 key\n      assertEquals(\"Artist\", mp4tag.getFirst(Mp4FieldKey.ARTIST));\n      assertEquals(\"Album\", mp4tag.getFirst(Mp4FieldKey.ALBUM));\n      assertEquals(\"title\", mp4tag.getFirst(Mp4FieldKey.TITLE));\n      assertEquals(\"comments\", mp4tag.getFirst(Mp4FieldKey.COMMENT));\n      assertEquals(\"1971\", mp4tag.getFirst(Mp4FieldKey.DAY));\n      // Not sure why there are 4 values, only understand 2nd and third\n      assertEquals(\"1/10\", mp4tag.getFirst(Mp4FieldKey.TRACK));\n      assertEquals(\n          \"1/10\", ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.TRACK).get(0)).getContent());\n      assertEquals(\n          new Short(\"0\"),\n          ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.TRACK).get(0)).getNumbers().get(0));\n      assertEquals(\n          new Short(\"1\"),\n          ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.TRACK).get(0)).getNumbers().get(1));\n      assertEquals(\n          new Short(\"10\"),\n          ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.TRACK).get(0)).getNumbers().get(2));\n      assertEquals(\n          new Short(\"0\"),\n          ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.TRACK).get(0)).getNumbers().get(3));\n\n      // Not sure why there are 4 values, only understand 2nd and third\n      assertEquals(\"1/10\", mp4tag.getFirst(Mp4FieldKey.DISCNUMBER));\n      assertEquals(\n          \"1/10\", ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.DISCNUMBER).get(0)).getContent());\n      assertEquals(\n          new Short(\"0\"),\n          ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.DISCNUMBER).get(0)).getNumbers().get(0));\n      assertEquals(\n          new Short(\"1\"),\n          ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.DISCNUMBER).get(0)).getNumbers().get(1));\n      assertEquals(\n          new Short(\"10\"),\n          ((Mp4TagTextNumberField) mp4tag.get(Mp4FieldKey.DISCNUMBER).get(0)).getNumbers().get(2));\n\n      assertEquals(\"composer\", mp4tag.getFirst(Mp4FieldKey.COMPOSER));\n      assertEquals(\"Sortartist\", mp4tag.getFirst(Mp4FieldKey.ARTIST_SORT));\n      assertEquals(\"lyrics\", mp4tag.getFirst(Mp4FieldKey.LYRICS));\n      assertEquals(\"199\", mp4tag.getFirst(Mp4FieldKey.BPM));\n      assertEquals(\"Albumartist\", mp4tag.getFirst(Mp4FieldKey.ALBUM_ARTIST));\n      assertEquals(\"Sortalbumartist\", mp4tag.getFirst(Mp4FieldKey.ALBUM_ARTIST_SORT));\n      assertEquals(\"Sortalbum\", mp4tag.getFirst(Mp4FieldKey.ALBUM_SORT));\n      assertEquals(\"GROUping\", mp4tag.getFirst(Mp4FieldKey.GROUPING));\n      assertEquals(\"Sortcomposer\", mp4tag.getFirst(Mp4FieldKey.COMPOSER_SORT));\n      assertEquals(\"sorttitle\", mp4tag.getFirst(Mp4FieldKey.TITLE_SORT));\n      assertEquals(\"1\", mp4tag.getFirst(Mp4FieldKey.COMPILATION));\n      assertEquals(\n          \"66027994-edcf-9d89-bec8-0d30077d888c\", mp4tag.getFirst(Mp4FieldKey.MUSICIP_PUID));\n      assertEquals(\n          \"e785f700-c1aa-4943-bcee-87dd316a2c30\", mp4tag.getFirst(Mp4FieldKey.MUSICBRAINZ_TRACKID));\n      assertEquals(\n          \"989a13f6-b58c-4559-b09e-76ae0adb94ed\",\n          mp4tag.getFirst(Mp4FieldKey.MUSICBRAINZ_ARTISTID));\n      assertEquals(\n          \"989a13f6-b58c-4559-b09e-76ae0adb94ed\",\n          mp4tag.getFirst(Mp4FieldKey.MUSICBRAINZ_ALBUMARTISTID));\n      assertEquals(\n          \"19c6f0f6-3d6d-4b02-88c7-ffb559d52be6\", mp4tag.getFirst(Mp4FieldKey.MUSICBRAINZ_ALBUMID));\n      Mp4TagReverseDnsField rvs =\n          (Mp4TagReverseDnsField) mp4tag.getFirstField(Mp4FieldKey.MUSICBRAINZ_ALBUMID);\n      assertEquals(\"com.apple.iTunes\", rvs.getIssuer());\n      assertEquals(\"MusicBrainz Album Id\", rvs.getDescriptor());\n      assertEquals(\"19c6f0f6-3d6d-4b02-88c7-ffb559d52be6\", rvs.getContent());\n\n      // Lookup by mp4key (no generic key mapping for these yet)\n      assertEquals(\n          \" 000002C0 00000298 00004210 00002FD5 0001CB31 0001CB48 0000750D 00007C4A 000291A8 00029191\",\n          mp4tag.getFirst(Mp4FieldKey.ITUNES_NORM));\n      assertEquals(\n          \" 00000000 00000840 000000E4 0000000000A29EDC 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\",\n          mp4tag.getFirst(Mp4FieldKey.ITUNES_SMPB));\n      assertEquals(\"0\", mp4tag.getFirst(Mp4FieldKey.PART_OF_GAPLESS_ALBUM));\n      assertEquals(\"iTunes v7.4.3.1, QuickTime 7.2\", mp4tag.getFirst(Mp4FieldKey.ENCODER));\n      assertEquals(\"sortshow\", mp4tag.getFirst(Mp4FieldKey.SHOW_SORT));\n      assertEquals(\"show\", mp4tag.getFirst(Mp4FieldKey.SHOW));\n      assertEquals(\"Genre\", mp4tag.getFirst(Mp4FieldKey.GENRE_CUSTOM));\n      assertEquals(\n          String.valueOf(Mp4RatingValue.EXPLICIT.getId()), mp4tag.getFirst(Mp4FieldKey.RATING));\n      assertEquals(\n          String.valueOf(Mp4ContentTypeValue.BOOKLET.getId()),\n          mp4tag.getFirst(Mp4FieldKey.CONTENT_TYPE));\n\n      List coverart = mp4tag.get(Mp4FieldKey.ARTWORK);\n      // Should be one image\n      assertEquals(2, coverart.size());\n\n      Mp4TagCoverField coverArtField = (Mp4TagCoverField) coverart.get(0);\n      // Check type png\n      assertEquals(Mp4FieldType.COVERART_JPEG, coverArtField.getFieldType());\n      // Just check png signature\n      assertEquals(0xff, coverArtField.getData()[0] & 0xff);\n      assertEquals(0xd8, coverArtField.getData()[1] & 0xff);\n      assertEquals(0xff, coverArtField.getData()[2] & 0xff);\n      assertEquals(0xe0, coverArtField.getData()[3] & 0xff);\n\n      coverArtField = (Mp4TagCoverField) coverart.get(1);\n      // Check type png\n      assertEquals(Mp4FieldType.COVERART_PNG, coverArtField.getFieldType());\n      // Just check png signature\n      assertEquals(0x89, coverArtField.getData()[0] & 0xff);\n      assertEquals(0x50, coverArtField.getData()[1] & 0xff);\n      assertEquals(0x4e, coverArtField.getData()[2] & 0xff);\n      assertEquals(0x47, coverArtField.getData()[3] & 0xff);\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      exceptionCaught = e;\n    }\n    assertNull(exceptionCaught);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6773, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [2720], "initializationEnd": [2751], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 2980, "focalAPIEnd": 3002, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [3691], "useEnd": [3702], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/besuikerd/vip/tree/master/shared/src/net/majorkernelpanic/streaming/audio/AACStream.java", "rawCode": "  /**\n   * Records a short sample of AAC ADTS from the microphone to find out what the sampling rate\n   * really is On some phone indeed, no error will be reported if the sampling rate used differs\n   * from the one selected with setAudioSamplingRate\n   *\n   * @throws IOException\n   * @throws IllegalStateException\n   */\n  @SuppressLint(\"InlinedApi\")\n  private void testADTS() throws IllegalStateException, IOException {\n\n    setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n    try {\n      Field name = MediaRecorder.OutputFormat.class.getField(\"AAC_ADTS\");\n      setOutputFormat(name.getInt(null));\n    } catch (Exception ignore) {\n      setOutputFormat(6);\n    }\n\n    // Checks if the user has supplied an exotic sampling rate\n    int i = 0;\n    for (; i < AUDIO_SAMPLING_RATES.length; i++) {\n      if (AUDIO_SAMPLING_RATES[i] == mQuality.samplingRate) {\n        break;\n      }\n    }\n    // If he did, we force a reasonable one: 16 kHz\n    if (i > 12) {\n      Log.e(TAG, \"Not a valid sampling rate: \" + mQuality.samplingRate);\n      mQuality.samplingRate = 16000;\n    }\n\n    if (mSettings != null) {\n      if (mSettings.contains(\"aac-\" + mQuality.samplingRate)) {\n        String[] s = mSettings.getString(\"aac-\" + mQuality.samplingRate, \"\").split(\",\");\n        mActualSamplingRate = Integer.valueOf(s[0]);\n        mConfig = Integer.valueOf(s[1]);\n        mChannel = Integer.valueOf(s[2]);\n        return;\n      }\n    }\n\n    final String TESTFILE =\n        Environment.getExternalStorageDirectory().getPath() + \"/spydroid-test.adts\";\n\n    if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n      throw new IllegalStateException(\"No external storage or external storage not ready !\");\n    }\n\n    // The structure of an ADTS packet is described here:\n    // http://wiki.multimedia.cx/index.php?title=ADTS\n\n    // ADTS header is 7 or 9 bytes long\n    byte[] buffer = new byte[9];\n\n    mMediaRecorder = new MediaRecorder();\n    mMediaRecorder.setAudioSource(mAudioSource);\n    mMediaRecorder.setOutputFormat(mOutputFormat);\n    mMediaRecorder.setAudioEncoder(mAudioEncoder);\n    mMediaRecorder.setAudioChannels(1);\n    mMediaRecorder.setAudioSamplingRate(mQuality.samplingRate);\n    mMediaRecorder.setAudioEncodingBitRate(mQuality.bitRate);\n    mMediaRecorder.setOutputFile(TESTFILE);\n    mMediaRecorder.setMaxDuration(1000);\n    mMediaRecorder.prepare();\n    mMediaRecorder.start();\n\n    // We record for 1 sec\n    // TODO: use the MediaRecorder.OnInfoListener\n    try {\n      Thread.sleep(2000);\n    } catch (InterruptedException e) {\n    }\n\n    mMediaRecorder.stop();\n    mMediaRecorder.release();\n    mMediaRecorder = null;\n\n    File file = new File(TESTFILE);\n    RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n\n    // ADTS packets start with a sync word: 12bits set to 1\n    while (true) {\n      if ((raf.readByte() & 0xFF) == 0xFF) {\n        buffer[0] = raf.readByte();\n        if ((buffer[0] & 0xF0) == 0xF0) break;\n      }\n    }\n\n    raf.read(buffer, 1, 5);\n\n    mSamplingRateIndex = (buffer[1] & 0x3C) >> 2;\n    mProfile = ((buffer[1] & 0xC0) >> 6) + 1;\n    mChannel = (buffer[1] & 0x01) << 2 | (buffer[2] & 0xC0) >> 6;\n    mActualSamplingRate = AUDIO_SAMPLING_RATES[mSamplingRateIndex];\n\n    // 5 bits for the object type / 4 bits for the sampling rate / 4 bits for the channel / padding\n    mConfig = mProfile << 11 | mSamplingRateIndex << 7 | mChannel << 3;\n\n    Log.i(TAG, \"MPEG VERSION: \" + ((buffer[0] & 0x08) >> 3));\n    Log.i(TAG, \"PROTECTION: \" + (buffer[0] & 0x01));\n    Log.i(TAG, \"PROFILE: \" + AUDIO_OBJECT_TYPES[mProfile]);\n    Log.i(TAG, \"SAMPLING FREQUENCY: \" + mActualSamplingRate);\n    Log.i(TAG, \"CHANNEL: \" + mChannel);\n\n    raf.close();\n\n    if (mSettings != null) {\n      Editor editor = mSettings.edit();\n      editor.putString(\n          \"aac-\" + mQuality.samplingRate, mActualSamplingRate + \",\" + mConfig + \",\" + mChannel);\n      editor.commit();\n    }\n\n    if (!file.delete()) Log.e(TAG, \"Temp file could not be erased\");\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6774, "initialization": ["int len = getUpdateChunkSize()", "RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [154, 308], "initializationEnd": [174, 375], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["error(String,int,*)"], "tryExpressionStart": 275, "tryExpressionEnd": 279, "tryBlockStart": 275, "tryBlockEnd": 998, "catchExpressionStart": 794, "catchExpressionEnd": 814, "catchBlockStart": 794, "catchBlockEnd": 934, "exceptionHandlingCallStart": [822], "exceptionHandlingCallEnd": [927], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [383], "configurationEnd": [414], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 434, "focalAPIEnd": 485, "followUpCheck": "byteCount != len", "checkType": "IF", "followUpCheckExpressionStart": 555, "followUpCheckExpressionEnd": 584, "followUpCheckBlockStart": 555, "followUpCheckBlockEnd": 658, "use": ["copyOf(byte[],byteCount)", "closeQuietly(randomAccessFile)"], "useStart": [603, 951], "useEnd": [631, 991], "hasFinally": 1, "cleanUpCall": ["closeQuietly(RandomAccessFile)"], "finallyExpressionStart": 935, "finallyExpressionEnd": 943, "finallyBlockStart": 935, "finallyBlockEnd": 998, "cleanUpCallStart": [951], "cleanUpCallEnd": [991], "url": "https://github.com/nhnopensource/ngrinder/tree/master/ngrinder-controller/src/main/java/org/ngrinder/perftest/service/AgentManager.java", "rawCode": "  @Override\n  public synchronized AgentUpdateGrinderMessage onAgentDownloadRequested(\n      String version, int offset) {\n    final int updateChunkSize = getUpdateChunkSize();\n    byte[] buffer = new byte[updateChunkSize];\n    RandomAccessFile agentPackageReader = null;\n    try {\n      agentPackageReader = new RandomAccessFile(agentPackageService.createAgentPackage(), \"r\");\n      agentPackageReader.seek(offset);\n      int count = agentPackageReader.read(buffer, 0, updateChunkSize);\n      byte[] bytes = buffer;\n      int next = offset + count;\n      if (count != updateChunkSize) {\n        bytes = Arrays.copyOf(buffer, count);\n        next = 0;\n      }\n      return new AgentUpdateGrinderMessage(\n          version, bytes, offset, next, CRC32ChecksumUtils.getCRC32Checksum(bytes));\n    } catch (Exception e) {\n      LOGGER.error(\n          \"Error while reading agent package, its offset is {} and details {}:\", offset, e);\n    } finally {\n      IOUtils.closeQuietly(agentPackageReader);\n    }\n    return AgentUpdateGrinderMessage.getNullAgentUpdateGrinderMessage(version);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6775, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [80], "configurationEnd": [121], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 127, "focalAPIEnd": 157, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/msloth/contiki-launchpad/tree/master/tools/coffee-manager/se/sics/coffee/CoffeeImageFile.java", "rawCode": "  public void read(byte[] bytes, int size, int offset) throws IOException {\n    imageFile.seek(conf.startOffset + offset);\n    imageFile.read(bytes, 0, size);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6776, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getFilePointer()", "randomAccessFile.seek(long)"], "configurationStart": [110, 145], "configurationEnd": [137, 167], "guardCondition": "length>off", "guardType": "LOOP {", "guardExpressionStart": 298, "guardExpressionEnd": 316, "guardBlockStart": 298, "guardBlockEnd": 482, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 341, "focalAPIEnd": 406, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["OutputStream.write(byte[],int,byteCount)", "randomAccessFile.seek(long)"], "useStart": [418, 509], "useEnd": [444, 541], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.seek(long)"], "finallyExpressionStart": 491, "finallyExpressionEnd": 499, "finallyBlockStart": 491, "finallyBlockEnd": 550, "cleanUpCallStart": [509], "cleanUpCallEnd": [541], "url": "https://github.com/carrotsearch/randomizedtesting/tree/master/junit4-ant/src/main/java/com/carrotsearch/ant/tasks/junit4/LocalSlaveStreamHandler.java", "rawCode": "    @Override\n    public void copyTo(OutputStream os) throws IOException {\n      final long restorePosition = bufferFile.getFilePointer();\n      bufferFile.seek(start);\n      try {\n        long length = end - start;\n        final byte[] buffer = new byte[(int) Math.min(length, 1024 * 4)];\n        while (length > 0) {\n          int bytes = bufferFile.read(buffer, 0, (int) Math.min(length, buffer.length));\n          os.write(buffer, 0, bytes);\n          length -= bytes;\n        }\n      } finally {\n        bufferFile.seek(restorePosition);\n      }\n    }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6777, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 267, "tryExpressionEnd": 271, "tryBlockStart": 267, "tryBlockEnd": 539, "catchExpressionStart": 436, "catchExpressionEnd": 456, "catchBlockStart": 436, "catchBlockEnd": 539, "exceptionHandlingCallStart": [464], "exceptionHandlingCallEnd": [492], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [343], "configurationEnd": [354], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 362, "focalAPIEnd": 377, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/coreidx/src/org/olanto/idxvli/util/BytesAndFiles.java", "rawCode": "  /**\n   * read int  la position pos il est vident que le status ne peut tre test si on travaille avec\n   * -1 !!!\n   *\n   * @param pos position\n   * @param r fichier\n   * @return valeur\n   */\n  public static final int readInt(long pos, RandomAccessFile r) {\n    try {\n      int[] b = new int[1];\n      byte[] byteidx = new byte[4];\n      r.seek(pos);\n      r.read(byteidx);\n      byteToint(b, 4, byteidx);\n      return b[0];\n    } catch (Exception e) {\n      error(\"IO error readInt\", e);\n      return STATUS_ERROR; // en erreur\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6778, "initialization": ["byte[] b = buffer()"], "initializationStart": [143], "initializationEnd": [151], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)", "randomAccessFile.readFully(byte[],int,int)", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[],int,int)"], "configurationStart": [394, 411, 549, 566], "configurationEnd": [405, 436, 560, 587], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 662, "focalAPIEnd": 675, "followUpCheck": "byteCount < 0", "checkType": "IF", "followUpCheckExpressionStart": 683, "followUpCheckExpressionEnd": 693, "followUpCheckBlockStart": 683, "followUpCheckBlockEnd": 700, "use": ["min(byteCount,long)", "MessageDigest.update(byte[],int,byteCount)", "MessageDigest.update(byte[],int,byteCount)"], "useStart": [767, 964, 1001], "useEnd": [793, 992, 1029], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SiteView/NEWECC9.2/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/storage/file/ObjectDirectoryPackParser.java", "rawCode": "  @Override\n  protected void onEndThinPack() throws IOException {\n    final byte[] tailHash = this.tailDigest.digest();\n    final byte[] buf = buffer();\n\n    final MessageDigest origDigest = Constants.newMessageDigest();\n    final MessageDigest tailDigest = Constants.newMessageDigest();\n    final MessageDigest packDigest = Constants.newMessageDigest();\n\n    long origRemaining = origEnd;\n    out.seek(0);\n    out.readFully(buf, 0, 12);\n    origDigest.update(buf, 0, 12);\n    origRemaining -= 12;\n\n    NB.encodeInt32(buf, 8, getObjectCount());\n    out.seek(0);\n    out.write(buf, 0, 12);\n    packDigest.update(buf, 0, 12);\n\n    for (; ; ) {\n      final int n = out.read(buf);\n      if (n < 0) break;\n      if (origRemaining != 0) {\n        final int origCnt = (int) Math.min(n, origRemaining);\n        origDigest.update(buf, 0, origCnt);\n        origRemaining -= origCnt;\n        if (origRemaining == 0) tailDigest.update(buf, origCnt, n - origCnt);\n      } else tailDigest.update(buf, 0, n);\n\n      packDigest.update(buf, 0, n);\n    }\n\n    if (!Arrays.equals(origDigest.digest(), origHash)\n        || !Arrays.equals(tailDigest.digest(), tailHash))\n      throw new IOException(JGitText.get().packCorruptedWhileWritingToFilesystem);\n\n    packHash = packDigest.digest();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6779, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [98], "initializationEnd": [133], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 190, "focalAPIEnd": 207, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [213], "useEnd": [225], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mpatric/mp3agic/tree/master/src/test/java/com/mpatric/mp3agic/TestHelper.java", "rawCode": "  public static byte[] loadFile(String filename) throws IOException {\n    RandomAccessFile file = new RandomAccessFile(filename, \"r\");\n    byte[] buffer = new byte[(int) file.length()];\n    file.read(buffer);\n    file.close();\n    return buffer;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6780, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [196], "initializationEnd": [228], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [246], "configurationEnd": [262], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 285, "focalAPIEnd": 295, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(long)", "randomAccessFile.writeByte(int)", "closeStream(randomAccessFile)"], "useStart": [303, 327, 378], "useEnd": [319, 354, 402], "hasFinally": 1, "cleanUpCall": ["closeStream(RandomAccessFile)"], "finallyExpressionStart": 362, "finallyExpressionEnd": 370, "finallyBlockStart": 362, "finallyBlockEnd": 409, "cleanUpCallStart": [378], "cleanUpCallEnd": [402], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/TestFSEditLogLoader.java", "rawCode": "  /** Corrupt the byte at the given offset in the given file, by subtracting 1 from it. */\n  private void corruptByteInFile(File file, long offset) throws IOException {\n    RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n    try {\n      raf.seek(offset);\n      int origByte = raf.read();\n      raf.seek(offset);\n      raf.writeByte(origByte - 1);\n    } finally {\n      IOUtils.closeStream(raf);\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6781, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 216, "tryExpressionEnd": 220, "tryBlockStart": 216, "tryBlockEnd": 358, "catchExpressionStart": 302, "catchExpressionEnd": 324, "catchBlockStart": 302, "catchBlockEnd": 358, "exceptionHandlingCallStart": [332], "exceptionHandlingCallEnd": [351], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [254], "configurationEnd": [271], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 279, "focalAPIEnd": 294, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rmoore/cs3114/tree/master/heapsort/LRUBuffer.java", "rawCode": "  /**\n   * Internal call to read from the disk. Updates the data buffer with a the data from the disk.\n   * Marks the file as loaded and as clean.\n   */\n  private void readFromDisk() {\n    data = new byte[size];\n    try {\n      Stats.diskReads++;\n\n      disk.seek(offset);\n      disk.read(data);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    loaded = true;\n    dirty = false;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6782, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 38, "tryExpressionEnd": 42, "tryBlockStart": 38, "tryBlockEnd": 197, "catchExpressionStart": 131, "catchExpressionEnd": 153, "catchBlockStart": 131, "catchBlockEnd": 197, "exceptionHandlingCallStart": [167], "exceptionHandlingCallEnd": [190], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [50], "configurationEnd": [82], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 104, "focalAPIEnd": 123, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/childnodeImport/publicobject/tree/master/trunk/src/com/publicobject/io/FileCharSequence.java", "rawCode": "  public char charAt(int index) {\n    try {\n      randomAccess.seek(start + index);\n      return (char) randomAccess.read();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6783, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [175], "configurationEnd": [188], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 297, "focalAPIEnd": 311, "followUpCheck": "byteCount <= 0", "checkType": "IF", "followUpCheckExpressionStart": 347, "followUpCheckExpressionEnd": 363, "followUpCheckBlockStart": 347, "followUpCheckBlockEnd": 468, "use": ["randomAccessFile.length()", "randomAccessFile.seek(long)"], "useStart": [327, 317], "useEnd": [340, 341], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asakusafw/asakusafw/tree/master/windgate-project/asakusa-windgate-core/src/main/java/com/asakusafw/windgate/file/session/FileSessionProvider.java", "rawCode": "  private State getSessionState(String id, File path, RandomAccessFile file) throws IOException {\n    assert id != null;\n    assert path != null;\n    assert file != null;\n    file.seek(0L);\n    LOG.debug(\"Loading session file: {}\", path);\n    byte[] buf = new byte[VALID.length];\n    int length = file.read(buf);\n    file.seek(file.length());\n    if (length <= 0) {\n      return State.INIT;\n    } else if (Arrays.equals(buf, VALID)) {\n      return State.CREATED;\n    }\n    return State.INVALID;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6784, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [635], "initializationEnd": [671], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)", "randomAccessFile.readInt()"], "configurationStart": [685, 857], "configurationEnd": [714, 870], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 951, "focalAPIEnd": 974, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.readByte()", "randomAccessFile.readInt()", "randomAccessFile.readInt()", "randomAccessFile.readInt()", "randomAccessFile.readLong()", "randomAccessFile.close()"], "useStart": [1101, 1236, 1342, 1460, 1587, 2049], "useEnd": [1115, 1249, 1355, 1473, 1601, 2060], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 1972, "finallyExpressionEnd": 1980, "finallyBlockStart": 1972, "finallyBlockEnd": 2167, "cleanUpCallStart": [2049], "cleanUpCallEnd": [2060], "url": "https://github.com/thiago-silva/epic-java/tree/master/src/share/classes/com/sun/tools/javac/file/ZipFileIndex.java", "rawCode": "    private void initEntries() {\n      if (entriesInited) {\n        return;\n      }\n\n      if (!zipFileIndex.readFromIndex) {\n        int from =\n            -Arrays.binarySearch(zipFileIndex.entries, new Entry(dirName, ZipFileIndex.MIN_CHAR))\n                - 1;\n        int to = -Arrays.binarySearch(zipFileIndex.entries, new Entry(dirName, MAX_CHAR)) - 1;\n\n        for (int i = from; i < to; i++) {\n          entries.add(zipFileIndex.entries[i]);\n        }\n      } else {\n        File indexFile = zipFileIndex.getIndexFile();\n        if (indexFile != null) {\n          RandomAccessFile raf = null;\n          try {\n            raf = new RandomAccessFile(indexFile, \"r\");\n            raf.seek(writtenOffsetOffset);\n\n            for (int nFiles = 0; nFiles < numEntries; nFiles++) {\n              // Read the name bytes\n              int zfieNameBytesLen = raf.readInt();\n              byte[] zfieNameBytes = new byte[zfieNameBytesLen];\n              raf.read(zfieNameBytes);\n              String eName = new String(zfieNameBytes, \"UTF-8\");\n\n              // Read isDir\n              boolean eIsDir = raf.readByte() == (byte) 0 ? false : true;\n\n              // Read offset of bytes in the real Jar/Zip file\n              int eOffset = raf.readInt();\n\n              // Read size of the file in the real Jar/Zip file\n              int eSize = raf.readInt();\n\n              // Read compressed size of the file in the real Jar/Zip file\n              int eCsize = raf.readInt();\n\n              // Read java time stamp of the file in the real Jar/Zip file\n              long eJavaTimestamp = raf.readLong();\n\n              Entry rfie = new Entry(dirName, eName);\n              rfie.isDir = eIsDir;\n              rfie.offset = eOffset;\n              rfie.size = eSize;\n              rfie.compressedSize = eCsize;\n              rfie.javatime = eJavaTimestamp;\n              entries.add(rfie);\n            }\n          } catch (Throwable t) {\n            // Do nothing\n          } finally {\n            try {\n              if (raf != null) {\n                raf.close();\n              }\n            } catch (Throwable t) {\n              // Do nothing\n            }\n          }\n        }\n      }\n\n      entriesInited = true;\n    }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6785, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 1169, "focalAPIEnd": 1201, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new MetadataBlockDataPicture(MetadataBlockHeader,randomAccessFile)", "randomAccessFile.getFilePointer()", "randomAccessFile.seek(long)"], "useStart": [1376, 2010, 2001], "useEnd": [1414, 2030, 2053], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeyboy/MUSIC/tree/master/lib/audiotagger/org/jaudiotagger/audio/flac/FlacTagReader.java", "rawCode": "  public FlacTag read(RandomAccessFile raf) throws CannotReadException, IOException {\n    FlacStreamReader flacStream = new FlacStreamReader(raf);\n    flacStream.findStream();\n\n    // Hold the metadata\n    VorbisCommentTag tag = null;\n    List<MetadataBlockDataPicture> images = new ArrayList<MetadataBlockDataPicture>();\n\n    // Seems like we have a valid stream\n    boolean isLastBlock = false;\n    while (!isLastBlock) {\n      if (logger.isLoggable(Level.CONFIG)) {\n        logger.config(\"Looking for MetaBlockHeader at:\" + raf.getFilePointer());\n      }\n\n      // Read the header\n      MetadataBlockHeader mbh = MetadataBlockHeader.readHeader(raf);\n      if (mbh == null) {\n        break;\n      }\n\n      if (logger.isLoggable(Level.CONFIG)) {\n        logger.config(\n            \"Reading MetadataBlockHeader:\" + mbh.toString() + \" ending at \" + raf.getFilePointer());\n      }\n\n      // Is it one containing some sort of metadata, therefore interested in it?\n      switch (mbh.getBlockType()) {\n          // We got a vorbiscomment comment block, parse it\n        case VORBIS_COMMENT:\n          byte[] commentHeaderRawPacket = new byte[mbh.getDataLength()];\n          raf.read(commentHeaderRawPacket);\n          tag = vorbisCommentReader.read(commentHeaderRawPacket, false);\n          break;\n\n        case PICTURE:\n          try {\n            MetadataBlockDataPicture mbdp = new MetadataBlockDataPicture(mbh, raf);\n            images.add(mbdp);\n          } catch (IOException ioe) {\n            logger.warning(\"Unable to read picture metablock, ignoring:\" + ioe.getMessage());\n          } catch (InvalidFrameException ive) {\n            logger.warning(\"Unable to read picture metablock, ignoring\" + ive.getMessage());\n          }\n\n          break;\n\n          // This is not a metadata block we are interested in so we skip to next block\n        default:\n          if (logger.isLoggable(Level.CONFIG)) {\n            logger.config(\"Ignoring MetadataBlock:\" + mbh.getBlockType());\n          }\n          raf.seek(raf.getFilePointer() + mbh.getDataLength());\n          break;\n      }\n\n      isLastBlock = mbh.isLastBlock();\n      mbh = null;\n    }\n\n    // Note there may not be either a tag or any images, no problem this is valid however to make it\n    // easier we\n    // just initialize Flac with an empty VorbisTag\n    if (tag == null) {\n      tag = VorbisCommentTag.createNewTag();\n    }\n    FlacTag flacTag = new FlacTag(tag, images);\n    return flacTag;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6786, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "off<EI_NIDENT", "guardType": "LOOP {", "guardExpressionStart": 616, "guardExpressionEnd": 656, "guardBlockStart": 616, "guardBlockEnd": 709, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 666, "focalAPIEnd": 708, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aurelf/avrora/tree/master/src/cck/elf/ELFHeader.java", "rawCode": "  /**\n   * The <code>read()</code> method reads the header from the specified input stream. It loads the\n   * identification section and checks that the header is present by testing against the magic ELF\n   * values, and reads the rests of the data section, initializes the ELF section.\n   *\n   * @param fs the input stream from which to read the ELF header\n   * @throws IOException if there is a problem reading from the input stream\n   */\n  public void read(RandomAccessFile fs) throws IOException, FormatError {\n    // read the indentification string\n    if (fs.length() < EI_NIDENT) throw new FormatError();\n    for (int index = 0; index < EI_NIDENT; ) index += fs.read(e_ident, index, EI_NIDENT - index);\n    checkIdent();\n    ELFDataInputStream is = new ELFDataInputStream(this, fs);\n    e_type = is.read_Elf32_Half();\n    e_machine = is.read_Elf32_Half();\n    e_version = is.read_Elf32_Word();\n    e_entry = is.read_Elf32_Addr();\n    e_phoff = is.read_Elf32_Off();\n    e_shoff = is.read_Elf32_Off();\n    e_flags = is.read_Elf32_Word();\n    e_ehsize = is.read_Elf32_Half();\n    e_phentsize = is.read_Elf32_Half();\n    e_phnum = is.read_Elf32_Half();\n    e_shentsize = is.read_Elf32_Half();\n    e_shnum = is.read_Elf32_Half();\n    e_shstrndx = is.read_Elf32_Half();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6787, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [704], "initializationEnd": [767], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 263, "tryExpressionEnd": 267, "tryBlockStart": 263, "tryBlockEnd": 1906, "catchExpressionStart": 1825, "catchExpressionEnd": 1845, "catchBlockStart": 1825, "catchBlockEnd": 1906, "exceptionHandlingCallStart": [1853], "exceptionHandlingCallEnd": [1872], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 836, "focalAPIEnd": 861, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ConatyConsulting/jaudiotagger/tree/master/srctest/org/jaudiotagger/tag/vorbiscomment/VorbisWriteTagTest.java", "rawCode": "  /** Test writing to file, comments too large to fit on single page anymore */\n  public void testWriteToFileMuchLarger() {\n    File orig = new File(\"testdata\", \"test.ogg\");\n    if (!orig.isFile()) {\n      return;\n    }\n\n    Exception exceptionCaught = null;\n    try {\n      File testFile =\n          AbstractTestCase.copyAudioToTmp(\n              \"test.ogg\", new File(\"testWriteTagTestRequiresTwoPages.ogg\"));\n\n      AudioFile f = AudioFileIO.read(testFile);\n      assertTrue(f.getTag() instanceof VorbisCommentTag);\n      VorbisCommentTag tag = (VorbisCommentTag) f.getTag();\n\n      // Add new image, requires two fields in oggVorbis with data in base64 encoded form\n      RandomAccessFile imageFile = new RandomAccessFile(new File(\"testdata\", \"coverart.bmp\"), \"r\");\n      byte[] imagedata = new byte[(int) imageFile.length()];\n      imageFile.read(imagedata);\n      char[] testdata = Base64Coder.encode(imagedata);\n      String base64image = new String(testdata);\n      tag.setField(tag.createField(VorbisCommentFieldKey.COVERART, base64image));\n      tag.setField(tag.createField(VorbisCommentFieldKey.COVERARTMIME, \"image/png\"));\n\n      // Save\n      f.commit();\n\n      // Reread\n      f = AudioFileIO.read(testFile);\n      tag = (VorbisCommentTag) f.getTag();\n\n      // Check changes\n      assertEquals(1, tag.get(VorbisCommentFieldKey.COVERART).size());\n      assertEquals(1, tag.get(VorbisCommentFieldKey.COVERARTMIME).size());\n\n      RandomAccessFile raf = new RandomAccessFile(testFile, \"r\");\n      OggFileReader oggFileReader = new OggFileReader();\n      System.out.println(oggFileReader.readOggPageHeader(raf, 0));\n      raf.seek(0);\n      System.out.println(oggFileReader.readOggPageHeader(raf, 1));\n      raf.seek(0);\n      System.out.println(oggFileReader.readOggPageHeader(raf, 2));\n      raf.close();\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      exceptionCaught = e;\n    }\n    assertNull(exceptionCaught);\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6788, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 116, "focalAPIEnd": 129, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/molgenis_apps-legacy/tree/master/modules/xgap/matrix/implementations/binary/BinaryDataMatrixInstance.java", "rawCode": "  private Double readNextDoubleFromRAF(RandomAccessFile raf) throws IOException {\n    byte[] arr = new byte[8];\n    raf.read(arr);\n    double d = byteArrayToDouble(arr);\n    if (d == Double.MAX_VALUE) {\n      return null;\n    }\n    return d;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6789, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [235], "initializationEnd": [266], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 200, "tryExpressionEnd": 204, "tryBlockStart": 200, "tryBlockEnd": 453, "catchExpressionStart": 370, "catchExpressionEnd": 390, "catchBlockStart": 370, "catchBlockEnd": 453, "exceptionHandlingCallStart": [398], "exceptionHandlingCallEnd": [446], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 323, "focalAPIEnd": 343, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [351], "useEnd": [362], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fgeraci/cs352-bittorrent-project/tree/master/src/bt/Utils/Utilities.java", "rawCode": "  /**\n   * Returns a byte stream from the given file.\n   *\n   * @param file\n   * @return byte[] File Bytes\n   */\n  public static byte[] getBytesFromFile(File file) {\n    byte[] bytesArray = null;\n    try {\n      RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n      bytesArray = new byte[(int) raf.length()];\n      raf.read(bytesArray);\n      raf.close();\n    } catch (Exception e) {\n      System.out.println(\"Random Access File failed.\");\n    }\n    return bytesArray;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6790, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 188, "focalAPIEnd": 209, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/io/readBytes/ReadBytesBounds.java", "rawCode": "  static void testRead(int off, int len, boolean expected) throws Throwable {\n    System.err.printf(\"off=%d len=%d expected=%b%n\", off, len, expected);\n    boolean result;\n    try {\n      fis.read(b, off, len);\n      raf.read(b, off, len);\n      result = true;\n    } catch (IndexOutOfBoundsException e) {\n      result = false;\n    }\n\n    if (result != expected) {\n      throw new RuntimeException(\n          String.format(\"Unexpected result off=%d len=%d expected=%b\", off, len, expected));\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6791, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 86, "focalAPIEnd": 101, "followUpCheck": "byteCount != -1", "checkType": "IF", "followUpCheckExpressionStart": 109, "followUpCheckExpressionEnd": 121, "followUpCheckBlockStart": 109, "followUpCheckBlockEnd": 153, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/cagrid-core/tree/master/caGrid/projects/core/src/java/gov/nih/nci/cagrid/common/FixedPortionFileInputStream.java", "rawCode": "  public int read() throws IOException {\n    if (amountRead < length) {\n      int b = randFile.read();\n      if (b != -1) {\n        amountRead++;\n      }\n      return b;\n    } else {\n      return -1;\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6792, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["w(*,String,*)"], "tryExpressionStart": 28, "tryExpressionEnd": 32, "tryBlockStart": 28, "tryBlockEnd": 174, "catchExpressionStart": 92, "catchExpressionEnd": 114, "catchBlockStart": 92, "catchBlockEnd": 174, "exceptionHandlingCallStart": [124], "exceptionHandlingCallEnd": [165], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [42], "configurationEnd": [54], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 64, "focalAPIEnd": 82, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Blakez/android_frameworks_base/tree/master/tests/FrameworkPerf/src/com/android/frameworkperf/TestService.java", "rawCode": "    boolean onRun() {\n      try {\n        mRAF.seek(0);\n        mRAF.read(mBuffer);\n      } catch (IOException e) {\n        Log.w(TAG, \"Failure reading \" + mFile, e);\n      }\n      return true;\n    }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6793, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 785, "focalAPIEnd": 796, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["read(randomAccessFile)", "randomAccessFile.read(byte[])"], "useStart": [1733, 1835], "useEnd": [1756, 1846], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craigpetchell/Jaudiotagger/tree/master/src/org/jaudiotagger/audio/ogg/OggVorbisTagReader.java", "rawCode": "  /**\n   * The Vorbis Comment may span multiple pages so we we need to identify the pages they contain and\n   * then extract the packet data from the pages\n   *\n   * @param startVorbisCommentPage\n   * @param raf\n   * @throws org.jaudiotagger.audio.exceptions.CannotReadException\n   * @throws java.io.IOException\n   * @return\n   */\n  private byte[] convertToVorbisCommentPacket(\n      OggPageHeader startVorbisCommentPage, RandomAccessFile raf)\n      throws IOException, CannotReadException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    byte[] b =\n        new byte\n            [startVorbisCommentPage.getPacketList().get(0).getLength()\n                - (VorbisHeader.FIELD_PACKET_TYPE_LENGTH\n                    + VorbisHeader.FIELD_CAPTURE_PATTERN_LENGTH)];\n    raf.read(b);\n    baos.write(b);\n\n    // Because there is at least one other packet (SetupHeaderPacket) this means the Comment Packet\n    // has finished\n    // on this page so thats all we need and we can return\n    if (startVorbisCommentPage.getPacketList().size() > 1) {\n      logger.config(\"Comments finish on 2nd Page because there is another packet on this page\");\n      return baos.toByteArray();\n    }\n\n    // There is only the VorbisComment packet on page if it has completed on this page we can return\n    if (!startVorbisCommentPage.isLastPacketIncomplete()) {\n      logger.config(\"Comments finish on 2nd Page because this packet is complete\");\n      return baos.toByteArray();\n    }\n\n    // The VorbisComment extends to the next page, so should be at end of page already\n    // so carry on reading pages until we get to the end of comment\n    while (true) {\n      logger.config(\"Reading next page\");\n      OggPageHeader nextPageHeader = OggPageHeader.read(raf);\n      b = new byte[nextPageHeader.getPacketList().get(0).getLength()];\n      raf.read(b);\n      baos.write(b);\n\n      // Because there is at least one other packet (SetupHeaderPacket) this means the Comment\n      // Packet has finished\n      // on this page so thats all we need and we can return\n      if (nextPageHeader.getPacketList().size() > 1) {\n        logger.config(\"Comments finish on Page because there is another packet on this page\");\n        return baos.toByteArray();\n      }\n\n      // There is only the VorbisComment packet on page if it has completed on this page we can\n      // return\n      if (!nextPageHeader.isLastPacketIncomplete()) {\n        logger.config(\"Comments finish on Page because this packet is complete\");\n        return baos.toByteArray();\n      }\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6794, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["make(*)"], "tryExpressionStart": 75, "tryExpressionEnd": 79, "tryBlockStart": 75, "tryBlockEnd": 193, "catchExpressionStart": 137, "catchExpressionEnd": 159, "catchBlockStart": 137, "catchBlockEnd": 193, "exceptionHandlingCallStart": [173], "exceptionHandlingCallEnd": [186], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [87], "configurationEnd": [99], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 107, "focalAPIEnd": 129, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xored/f4/tree/master/com.xored.f4.fantom/fantom/src/sys/java/fan/sys/FileBuf.java", "rawCode": "  public final void getBytes(long pos, byte[] dst, int off, int len) {\n    try {\n      fp.seek(pos);\n      fp.read(dst, off, len);\n    } catch (IOException e) {\n      throw IOErr.make(e);\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6795, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 76, "tryExpressionEnd": 80, "tryBlockStart": 76, "tryBlockEnd": 376, "catchExpressionStart": 320, "catchExpressionEnd": 342, "catchBlockStart": 320, "catchBlockEnd": 376, "exceptionHandlingCallStart": [350], "exceptionHandlingCallEnd": [369], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b,off,len)", "focalAPIStart": 156, "focalAPIEnd": 207, "followUpCheck": "byteCount < mbuf.len - i", "checkType": "IF", "followUpCheckExpressionStart": 217, "followUpCheckExpressionEnd": 238, "followUpCheckBlockStart": 217, "followUpCheckBlockEnd": 305, "use": ["randomAccessFile.seek(int)"], "useStart": [251], "useEnd": [266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_3_2_1/appia/src/org/continuent/appia/test/perf/PerfSession.java", "rawCode": "  private void writePayload(MsgBuffer mbuf, RandomAccessFile payload) {\n    try {\n      int i, r = 0;\n      for (i = 0; i < mbuf.len; i += r) {\n        r = payload.read(mbuf.data, mbuf.off + i, mbuf.len - i);\n        if (r < mbuf.len - i) {\n          payload.seek(0);\n          if (r < 0) r = 0;\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6796, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [701], "initializationEnd": [765], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 829, "focalAPIEnd": 853, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/UNC-Libraries/Carolina-Digital-Repository/tree/master/sword-server/src/test/java/edu/unc/lib/dl/cdr/sword/server/util/DepositReportingUtilTest.java", "rawCode": "  @Test\n  public void retrieveDepositReceiptWithMODSTest() throws Exception {\n    PID pid = new PID(\"uuid:test\");\n\n    TripleStoreQueryService tripleStoreQueryService = mock(TripleStoreQueryService.class);\n\n    Map<String, String> disseminations = new HashMap<String, String>();\n    disseminations.put(\n        pid.getURI() + \"/\" + ContentModelHelper.Datastream.MD_DESCRIPTIVE.getName(), \"text/xml\");\n    disseminations.put(\n        pid.getURI() + \"/\" + ContentModelHelper.Datastream.DATA_FILE.getName(), \"image/jpg\");\n\n    when(tripleStoreQueryService.fetchDisseminatorMimetypes(any(PID.class)))\n        .thenReturn(disseminations);\n\n    @SuppressWarnings(\"resource\")\n    RandomAccessFile modsFile = new RandomAccessFile(\"src/test/resources/modsDocument.xml\", \"r\");\n    byte[] modsBytes = new byte[(int) modsFile.length()];\n    modsFile.read(modsBytes);\n    MIMETypedStream mimeStream = new MIMETypedStream();\n    mimeStream.setStream(modsBytes);\n\n    AccessClient accessClient = mock(AccessClient.class);\n    when(accessClient.getDatastreamDissemination(\n            any(PID.class),\n            eq(ContentModelHelper.Datastream.MD_DESCRIPTIVE.getName()),\n            anyString()))\n        .thenReturn(mimeStream);\n\n    DepositReportingUtil depositReportingUtil = new DepositReportingUtil();\n    depositReportingUtil.setAccessClient(accessClient);\n    depositReportingUtil.setTripleStoreQueryService(tripleStoreQueryService);\n\n    DepositReceipt receipt = depositReportingUtil.retrieveDepositReceipt(pid, config);\n\n    Entry receiptEntry = receipt.getAbderaEntry();\n\n    assertEquals(\"There must be two extension\", 2, receiptEntry.getExtensions().size());\n    assertEquals(\"mods\", receiptEntry.getExtensions().get(0).getQName().getLocalPart());\n\n    List<Link> links = receiptEntry.getLinks(UriRegistry.REL_DERIVED_RESOURCE);\n    assertEquals(2, links.size());\n    // Check derived resources. Order can't be guaranteed since its going into a hashmap, so check\n    // both orders\n    if (links\n        .get(0)\n        .getAttributeValue(\"href\")\n        .equals(\n            config.getSwordPath()\n                + SwordConfigurationImpl.EDIT_MEDIA_PATH\n                + \"/\"\n                + pid.getPid()\n                + \"/\"\n                + ContentModelHelper.Datastream.DATA_FILE.getName())) {\n      assertEquals(\"image/jpg\", links.get(0).getAttributeValue(\"type\"));\n      assertEquals(\"text/xml\", links.get(1).getAttributeValue(\"type\"));\n      assertEquals(\n          \"http://localhost/sword/em/uuid:test/\"\n              + ContentModelHelper.Datastream.MD_DESCRIPTIVE.getName(),\n          links.get(1).getAttributeValue(\"href\"));\n    } else {\n      assertEquals(\"image/jpg\", links.get(1).getAttributeValue(\"type\"));\n      assertEquals(\n          \"http://localhost/sword/em/uuid:test/\"\n              + ContentModelHelper.Datastream.DATA_FILE.getName(),\n          links.get(1).getAttributeValue(\"href\"));\n      assertEquals(\"text/xml\", links.get(0).getAttributeValue(\"type\"));\n      assertEquals(\n          \"http://localhost/sword/em/uuid:test/\"\n              + ContentModelHelper.Datastream.MD_DESCRIPTIVE.getName(),\n          links.get(0).getAttributeValue(\"href\"));\n    }\n\n    links = receiptEntry.getLinks(UriRegistry.REL_STATEMENT);\n    assertEquals(1, links.size());\n    assertEquals(\n        config.getSwordPath() + SwordConfigurationImpl.STATE_PATH + \"/\" + pid.getPid(),\n        links.get(0).getAttributeValue(\"href\"));\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6797, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 381, "focalAPIEnd": 392, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getFilePointer()", "randomAccessFile.read()", "randomAccessFile.seek(long)"], "useStart": [723, 773, 830], "useEnd": [744, 784, 844], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/svnkit/tree/master/svnkit/src/main/java/org/tmatesoft/svn/core/internal/wc/patch/SVNPatchFileStream.java", "rawCode": "  private boolean readLine(StringBuffer input, StringBuffer eolStr, boolean detectEol)\n      throws IOException, SVNException {\n\n    int c;\n    boolean eol;\n    boolean filtered;\n\n    do {\n\n      c = -1;\n      eol = false;\n      filtered = false;\n\n      input.setLength(0);\n      if (eolStr != null) {\n        eolStr.setLength(0);\n      }\n\n      while (!eol) {\n        switch (c = file.read()) {\n          case -1:\n          case '\\n':\n            if (detectEol && eolStr != null) {\n              eolStr.append((char) c);\n            }\n            eol = true;\n            break;\n          case '\\r':\n            if (detectEol && eolStr != null) {\n              eolStr.append((char) c);\n            }\n            long cur = file.getFilePointer();\n            final int c2 = file.read();\n            if (c2 != '\\n') {\n              file.seek(cur);\n            } else {\n              if (detectEol && eolStr != null) {\n                eolStr.append((char) c2);\n              }\n            }\n            eol = true;\n            break;\n          default:\n            input.append((char) c);\n            break;\n        }\n      }\n\n      if (lineFilter != null) {\n        filtered = lineFilter.lineFilter(input.toString());\n        if (filtered) {\n          input.setLength(0);\n        }\n      }\n\n    } while (filtered && !isEOF());\n\n    if (lineTransformer != null) {\n      final String line = lineTransformer.lineTransformer(input.toString());\n      input.setLength(0);\n      input.append(line);\n    }\n\n    return input.length() == 0 && isEOF();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6798, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 128, "focalAPIEnd": 139, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.read(byte[])", "randomAccessFile.read(byte[])", "randomAccessFile.read(byte[])", "randomAccessFile.read(byte[])"], "useStart": [238, 321, 458, 564], "useEnd": [249, 332, 469, 575], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeyboy/MUSIC/tree/master/lib/outag/outag/audioformats/ogg/util/OggTagReader.java", "rawCode": "  public OggTag read(RandomAccessFile raf) throws IOException {\n    OggTag tag = new OggTag();\n\n    byte[] b = new byte[4];\n    raf.read(b);\n    int vendorStringLength = Utils.getNumber(b, 0, 3);\n    b = new byte[vendorStringLength];\n    raf.read(b);\n\n    tag.setVendor(new String(b, \"UTF-8\"));\n\n    b = new byte[4];\n    raf.read(b);\n    int userComments = Utils.getNumber(b, 0, 3);\n\n    for (int i = 0; i < userComments; i++) {\n      b = new byte[4];\n      raf.read(b);\n      int commentLength = Utils.getNumber(b, 0, 3);\n      b = new byte[commentLength];\n      raf.read(b);\n\n      OggTagField field = new OggTagField(b);\n      tag.add(field);\n    }\n\n    return tag;\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6799, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)", "randomAccessFile.seek(long)"], "configurationStart": [182, 437], "configurationEnd": [193, 456], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read(b)", "focalAPIStart": 493, "focalAPIEnd": 509, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vyloy/lnvc/tree/master/vovo/client/src/com/lorent/vovo/util/RecentContactManager.java", "rawCode": "  public Set<RecentContact> getAll() throws IOException {\n    result = new TreeMap<RecentContact, RecentContact>();\n    quickCache = new HashMap<RecentContact, RecentContact>();\n    r.seek(12L);\n    byte[] _contact = new byte[CONTACT_SIZE];\n    AvailablePositionIterator iterator = new AvailablePositionIterator();\n    while (iterator.hasNext()) {\n      RecentContact rc = new RecentContact();\n      rc.position = iterator.next();\n      r.seek(rc.position);\n      rc.info = r.readInt();\n      r.read(_contact);\n      rc.contact = new String(new String(_contact, charset).trim());\n      rc.index = r.readLong();\n      result.put(rc, rc);\n      quickCache.put(rc, rc);\n    }\n    return result.keySet();\n  }\n"}, {"dataset": "randomAccessFileRead", "exampleID": 6800, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [1431], "initializationEnd": [1469], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.length()", "randomAccessFile.seek(long)"], "configurationStart": [1487, 1527], "configurationEnd": [1499, 1544], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "byteCount = randomAccessFile.read()", "focalAPIStart": 1563, "focalAPIEnd": 1573, "followUpCheck": "byteCount != '\\n'", "checkType": "IF", "followUpCheckExpressionStart": 1581, "followUpCheckExpressionEnd": 1598, "followUpCheckBlockStart": 1581, "followUpCheckBlockEnd": 1615, "use": ["randomAccessFile.write(char)", "randomAccessFile.write(int)", "randomAccessFile.close()"], "useStart": [1599, 1627, 1684], "useEnd": [1614, 1678, 1695], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/schoentoon/Connectbot/tree/master/src/com/trilead/ssh2/KnownHosts.java", "rawCode": "  /**\n   * Adds a single public key entry to the a known_hosts file. This method is designed to be used in\n   * a {@link ServerHostKeyVerifier}.\n   *\n   * @param knownHosts the file where the publickey entry will be appended.\n   * @param hostnames a list of hostname patterns - at least one most be specified. Check out the\n   *     OpenSSH sshd man page for a description of the pattern matching algorithm.\n   * @param serverHostKeyAlgorithm as passed to the {@link ServerHostKeyVerifier}.\n   * @param serverHostKey as passed to the {@link ServerHostKeyVerifier}.\n   * @throws IOException\n   */\n  public static final void addHostkeyToFile(\n      File knownHosts, String[] hostnames, String serverHostKeyAlgorithm, byte[] serverHostKey)\n      throws IOException {\n    if ((hostnames == null) || (hostnames.length == 0))\n      throw new IllegalArgumentException(\"Need at least one hostname specification\");\n\n    if ((serverHostKeyAlgorithm == null) || (serverHostKey == null))\n      throw new IllegalArgumentException();\n\n    CharArrayWriter writer = new CharArrayWriter();\n\n    for (int i = 0; i < hostnames.length; i++) {\n      if (i != 0) writer.write(',');\n      writer.write(hostnames[i]);\n    }\n\n    writer.write(' ');\n    writer.write(serverHostKeyAlgorithm);\n    writer.write(' ');\n    writer.write(Base64.encode(serverHostKey));\n    writer.write(\"\\n\");\n\n    char[] entry = writer.toCharArray();\n\n    RandomAccessFile raf = new RandomAccessFile(knownHosts, \"rw\");\n\n    long len = raf.length();\n\n    if (len > 0) {\n      raf.seek(len - 1);\n      int last = raf.read();\n      if (last != '\\n') raf.write('\\n');\n    }\n\n    raf.write(new String(entry).getBytes(\"ISO-8859-1\"));\n    raf.close();\n  }\n"}]